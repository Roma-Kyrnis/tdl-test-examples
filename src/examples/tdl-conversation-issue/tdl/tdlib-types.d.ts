// Autogenerated types for TDLib v1.8.0
declare module 'tdlib-types' {
  export type error = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    code: number,
    /** Error message; subject to future changes */
    message: string,
  }

  export type error$Input = {
    /**
     * An object of this type can be returned on every function call, in case of an
     * error
     */
    readonly _: 'error',
    /**
     * Error code; subject to future changes. If the error code is 406, the error message
     * must not be processed in any way and must not be displayed to the user
     */
    readonly code?: number,
    /** Error message; subject to future changes */
    readonly message?: string,
  }

  export type ok = {
    /**
     * An object of this type is returned on a successful function call for certain
     * functions
     */
    _: 'ok',
  }

  export type tdlibParameters$Input = {
    /** Contains parameters for TDLib initialization */
    readonly _: 'tdlibParameters',
    /**
     * If set to true, the Telegram test environment will be used instead of the production
     * environment
     */
    readonly use_test_dc?: boolean,
    /**
     * The path to the directory for the persistent database; if empty, the current
     * working directory will be used
     */
    readonly database_directory?: string,
    /**
     * The path to the directory for storing files; if empty, database_directory will
     * be used
     */
    readonly files_directory?: string,
    /**
     * If set to true, information about downloaded and uploaded files will be saved
     * between application restarts
     */
    readonly use_file_database?: boolean,
    /**
     * If set to true, the library will maintain a cache of users, basic groups, supergroups,
     * channels and secret chats. Implies use_file_database
     */
    readonly use_chat_info_database?: boolean,
    /**
     * If set to true, the library will maintain a cache of chats and messages. Implies
     * use_chat_info_database
     */
    readonly use_message_database?: boolean,
    /** If set to true, support for secret chats will be enabled */
    readonly use_secret_chats?: boolean,
    /** Application identifier for Telegram API access, which can be obtained at https://my.telegram.org */
    readonly api_id?: number,
    /**
     * Application identifier hash for Telegram API access, which can be obtained at
     * https://my.telegram.org
     */
    readonly api_hash?: string,
    /** IETF language tag of the user's operating system language; must be non-empty */
    readonly system_language_code?: string,
    /** Model of the device the application is being run on; must be non-empty */
    readonly device_model?: string,
    /**
     * Version of the operating system the application is being run on. If empty, the
     * version is automatically detected by TDLib
     */
    readonly system_version?: string,
    /** Application version; must be non-empty */
    readonly application_version?: string,
    /** If set to true, old files will automatically be deleted */
    readonly enable_storage_optimizer?: boolean,
    /**
     * If set to true, original file names will be ignored. Otherwise, downloaded files
     * will be saved under names as close as possible to the original name
     */
    readonly ignore_file_names?: boolean,
  }

  export type authenticationCodeTypeTelegramMessage = {
    /**
     * An authentication code is delivered via a private Telegram message, which can
     * be viewed from another active session
     */
    _: 'authenticationCodeTypeTelegramMessage',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeSms = {
    /**
     * An authentication code is delivered via an SMS message to the specified phone
     * number
     */
    _: 'authenticationCodeTypeSms',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeCall = {
    /**
     * An authentication code is delivered via a phone call to the specified phone
     * number
     */
    _: 'authenticationCodeTypeCall',
    /** Length of the code */
    length: number,
  }

  export type authenticationCodeTypeFlashCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The phone number that calls is the code that must be entered automatically
     */
    _: 'authenticationCodeTypeFlashCall',
    /** Pattern of the phone number from which the call will be made */
    pattern: string,
  }

  export type authenticationCodeTypeMissedCall = {
    /**
     * An authentication code is delivered by an immediately canceled call to the specified
     * phone number. The last digits of the phone number that calls are the code that
     * must be entered manually by the user
     */
    _: 'authenticationCodeTypeMissedCall',
    /** Prefix of the phone number from which the call will be made */
    phone_number_prefix: string,
    /** Number of digits in the code, excluding the prefix */
    length: number,
  }

  export type authenticationCodeInfo = {
    /** Information about the authentication code that was sent */
    _: 'authenticationCodeInfo',
    /** A phone number that is being authenticated */
    phone_number: string,
    /** The way the code was sent to the user */
    type: AuthenticationCodeType,
    /** The way the next code will be sent to the user; may be null */
    next_type?: AuthenticationCodeType,
    /** Timeout before the code can be re-sent, in seconds */
    timeout: number,
  }

  export type emailAddressAuthenticationCodeInfo = {
    /** Information about the email address authentication code that was sent */
    _: 'emailAddressAuthenticationCodeInfo',
    /** Pattern of the email address to which an authentication code was sent */
    email_address_pattern: string,
    /** Length of the code; 0 if unknown */
    length: number,
  }

  export type textEntity = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    offset: number,
    /** Length of the entity, in UTF-16 code units */
    length: number,
    /** Type of the entity */
    type: TextEntityType,
  }

  export type textEntity$Input = {
    /** Represents a part of the text that needs to be formatted in some unusual way */
    readonly _: 'textEntity',
    /** Offset of the entity, in UTF-16 code units */
    readonly offset?: number,
    /** Length of the entity, in UTF-16 code units */
    readonly length?: number,
    /** Type of the entity */
    readonly type?: TextEntityType$Input,
  }

  export type textEntities = {
    /** Contains a list of text entities */
    _: 'textEntities',
    /** List of text entities */
    entities: Array<textEntity>,
  }

  export type formattedText = {
    /** A text with some entities */
    _: 'formattedText',
    /** The text */
    text: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. Bold, Italic, Underline and Strikethrough entities can contain and
     * to be contained in all other entities. All other entities can't contain each
     * other
     */
    entities: Array<textEntity>,
  }

  export type formattedText$Input = {
    /** A text with some entities */
    readonly _: 'formattedText',
    /** The text */
    readonly text?: string,
    /**
     * Entities contained in the text. Entities can be nested, but must not mutually
     * intersect with each other. Pre, Code and PreCode entities can't contain other
     * entities. Bold, Italic, Underline and Strikethrough entities can contain and
     * to be contained in all other entities. All other entities can't contain each
     * other
     */
    readonly entities?: ReadonlyArray<textEntity$Input>,
  }

  export type termsOfService = {
    /** Contains Telegram terms of service */
    _: 'termsOfService',
    /** Text of the terms of service */
    text: formattedText,
    /** The minimum age of a user to be able to accept the terms; 0 if any */
    min_user_age: number,
    /** True, if a blocking popup with terms of service must be shown to the user */
    show_popup: boolean,
  }

  export type authorizationStateWaitTdlibParameters = {
    /** TDLib needs TdlibParameters for initialization */
    _: 'authorizationStateWaitTdlibParameters',
  }

  export type authorizationStateWaitEncryptionKey = {
    /** TDLib needs an encryption key to decrypt the local database */
    _: 'authorizationStateWaitEncryptionKey',
    /** True, if the database is currently encrypted */
    is_encrypted: boolean,
  }

  export type authorizationStateWaitPhoneNumber = {
    /**
     * TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber`
     * to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken`
     * for other authentication options
     */
    _: 'authorizationStateWaitPhoneNumber',
  }

  export type authorizationStateWaitCode = {
    /** TDLib needs the user's authentication code to authorize */
    _: 'authorizationStateWaitCode',
    /** Information about the authorization code that was sent */
    code_info: authenticationCodeInfo,
  }

  export type authorizationStateWaitOtherDeviceConfirmation = {
    /**
     * The user needs to confirm authorization on another logged in device by scanning
     * a QR code with the provided link
     */
    _: 'authorizationStateWaitOtherDeviceConfirmation',
    /** A tg:// URL for the QR code. The link will be updated frequently */
    link: string,
  }

  export type authorizationStateWaitRegistration = {
    /**
     * The user is unregistered and need to accept terms of service and enter their
     * first name and last name to finish registration
     */
    _: 'authorizationStateWaitRegistration',
    /** Telegram terms of service */
    terms_of_service: termsOfService,
  }

  export type authorizationStateWaitPassword = {
    /**
     * The user has been authorized, but needs to enter a password to start using the
     * application
     */
    _: 'authorizationStateWaitPassword',
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email address has been set up */
    has_recovery_email_address: boolean,
    /**
     * Pattern of the email address to which the recovery email was sent; empty until
     * a recovery email has been sent
     */
    recovery_email_address_pattern: string,
  }

  export type authorizationStateReady = {
    /** The user has been successfully authorized. TDLib is now ready to answer queries */
    _: 'authorizationStateReady',
  }

  export type authorizationStateLoggingOut = {
    /** The user is currently logging out */
    _: 'authorizationStateLoggingOut',
  }

  export type authorizationStateClosing = {
    /**
     * TDLib is closing, all subsequent queries will be answered with the error 500.
     * Note that closing TDLib can take a while. All resources will be freed only after
     * authorizationStateClosed has been received
     */
    _: 'authorizationStateClosing',
  }

  export type authorizationStateClosed = {
    /**
     * TDLib client is in its final state. All databases are closed and all resources
     * are released. No other updates will be received after this. All queries will
     * be responded to with error code 500. To continue working, one must create a
     * new instance of the TDLib client
     */
    _: 'authorizationStateClosed',
  }

  export type passwordState = {
    /** Represents the current state of 2-step verification */
    _: 'passwordState',
    /** True, if a 2-step verification password is set */
    has_password: boolean,
    /** Hint for the password; may be empty */
    password_hint: string,
    /** True, if a recovery email is set */
    has_recovery_email_address: boolean,
    /** True, if some Telegram Passport elements were saved */
    has_passport_data: boolean,
    /**
     * Information about the recovery email address to which the confirmation email
     * was sent; may be null
     */
    recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo,
    /**
     * If not 0, point in time (Unix timestamp) after which the password can be reset
     * immediately using resetPassword
     */
    pending_reset_date: number,
  }

  export type recoveryEmailAddress = {
    /** Contains information about the current recovery email address */
    _: 'recoveryEmailAddress',
    /** Recovery email address */
    recovery_email_address: string,
  }

  export type temporaryPasswordState = {
    /**
     * Returns information about the availability of a temporary password, which can
     * be used for payments
     */
    _: 'temporaryPasswordState',
    /** True, if a temporary password is available */
    has_password: boolean,
    /** Time left before the temporary password expires, in seconds */
    valid_for: number,
  }

  export type localFile = {
    /** Represents a local file */
    _: 'localFile',
    /** Local path to the locally available file part; may be empty */
    path: string,
    /** True, if it is possible to download or generate the file */
    can_be_downloaded: boolean,
    /** True, if the file can be deleted */
    can_be_deleted: boolean,
    /**
     * True, if the file is currently being downloaded (or a local copy is being generated
     * by some other means)
     */
    is_downloading_active: boolean,
    /** True, if the local copy is fully available */
    is_downloading_completed: boolean,
    /**
     * Download will be started from this offset. downloaded_prefix_size is calculated
     * from this offset
     */
    download_offset: number,
    /**
     * If is_downloading_completed is false, then only some prefix of the file starting
     * from download_offset is ready to be read. downloaded_prefix_size is the size
     * of that prefix in bytes
     */
    downloaded_prefix_size: number,
    /**
     * Total downloaded file size, in bytes. Can be used only for calculating download
     * progress. The actual file size may be bigger, and some parts of it may contain
     * garbage
     */
    downloaded_size: number,
  }

  export type remoteFile = {
    /** Represents a remote file */
    _: 'remoteFile',
    /**
     * Remote file identifier; may be empty. Can be used by the current user across
     * application restarts or even from other devices. Uniquely identifies a file,
     * but a file can have a lot of different valid identifiers. If the ID starts with
     * "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently
     * unable to download files if only their URL is known. If downloadFile is called
     * on such a file or if it is sent to a secret chat, TDLib starts a file generation
     * process by sending updateFileGenerationStart to the application with the HTTP
     * URL in the original_path and "#url#" as the conversion string. Application must
     * generate the file by downloading it to the specified location
     */
    id: string,
    /**
     * Unique file identifier; may be empty if unknown. The unique file identifier
     * which is the same for the same file even for different users and is persistent
     * over time
     */
    unique_id: string,
    /**
     * True, if the file is currently being uploaded (or a remote copy is being generated
     * by some other means)
     */
    is_uploading_active: boolean,
    /** True, if a remote copy is fully available */
    is_uploading_completed: boolean,
    /** Size of the remote available part of the file, in bytes; 0 if unknown */
    uploaded_size: number,
  }

  export type file = {
    /** Represents a file */
    _: 'file',
    /** Unique file identifier */
    id: number,
    /** File size, in bytes; 0 if unknown */
    size: number,
    /**
     * Approximate file size in bytes in case the exact file size is unknown. Can be
     * used to show download/upload progress
     */
    expected_size: number,
    /** Information about the local copy of the file */
    local: localFile,
    /** Information about the remote copy of the file */
    remote: remoteFile,
  }

  export type inputFileId = {
    /** A file defined by its unique ID */
    _: 'inputFileId',
    /** Unique file identifier */
    id: number,
  }

  export type inputFileId$Input = {
    /** A file defined by its unique ID */
    readonly _: 'inputFileId',
    /** Unique file identifier */
    readonly id?: number,
  }

  export type inputFileRemote = {
    /**
     * A file defined by its remote ID. The remote ID is guaranteed to be usable only
     * if the corresponding file is still accessible to the user and known to TDLib.
     * For example, if the file is from a message, then the message must be not deleted
     * and accessible to the user. If the file database is disabled, then the corresponding
     * object with the file must be preloaded by the application
     */
    _: 'inputFileRemote',
    /** Remote file identifier */
    id: string,
  }

  export type inputFileRemote$Input = {
    /**
     * A file defined by its remote ID. The remote ID is guaranteed to be usable only
     * if the corresponding file is still accessible to the user and known to TDLib.
     * For example, if the file is from a message, then the message must be not deleted
     * and accessible to the user. If the file database is disabled, then the corresponding
     * object with the file must be preloaded by the application
     */
    readonly _: 'inputFileRemote',
    /** Remote file identifier */
    readonly id?: string,
  }

  export type inputFileLocal = {
    /** A file defined by a local path */
    _: 'inputFileLocal',
    /** Local path to the file */
    path: string,
  }

  export type inputFileLocal$Input = {
    /** A file defined by a local path */
    readonly _: 'inputFileLocal',
    /** Local path to the file */
    readonly path?: string,
  }

  export type inputFileGenerated = {
    /** A file generated by the application */
    _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated; may be empty if there
     * is no such file
     */
    original_path: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    conversion: string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    expected_size: number,
  }

  export type inputFileGenerated$Input = {
    /** A file generated by the application */
    readonly _: 'inputFileGenerated',
    /**
     * Local path to a file from which the file is generated; may be empty if there
     * is no such file
     */
    readonly original_path?: string,
    /**
     * String specifying the conversion applied to the original file; must be persistent
     * across application restarts. Conversions beginning with '#' are reserved for
     * internal TDLib usage
     */
    readonly conversion?: string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    readonly expected_size?: number,
  }

  export type photoSize = {
    /** Describes an image in JPEG format */
    _: 'photoSize',
    /** Image type (see https://core.telegram.org/constructor/photoSize) */
    type: string,
    /** Information about the image file */
    photo: file,
    /** Image width */
    width: number,
    /** Image height */
    height: number,
    /**
     * Sizes of progressive JPEG file prefixes, which can be used to preliminarily
     * show the image; in bytes
     */
    progressive_sizes: Array<number>,
  }

  export type minithumbnail = {
    /** Thumbnail image of a very poor quality and low resolution */
    _: 'minithumbnail',
    /** Thumbnail width, usually doesn't exceed 40 */
    width: number,
    /** Thumbnail height, usually doesn't exceed 40 */
    height: number,
    /** The thumbnail in JPEG format */
    data: string,
  }

  export type thumbnailFormatJpeg = {
    /** The thumbnail is in JPEG format */
    _: 'thumbnailFormatJpeg',
  }

  export type thumbnailFormatPng = {
    /** The thumbnail is in PNG format. It will be used only for background patterns */
    _: 'thumbnailFormatPng',
  }

  export type thumbnailFormatWebp = {
    /** The thumbnail is in WEBP format. It will be used only for some stickers */
    _: 'thumbnailFormatWebp',
  }

  export type thumbnailFormatGif = {
    /**
     * The thumbnail is in static GIF format. It will be used only for some bot inline
     * results
     */
    _: 'thumbnailFormatGif',
  }

  export type thumbnailFormatTgs = {
    /** The thumbnail is in TGS format. It will be used only for animated sticker sets */
    _: 'thumbnailFormatTgs',
  }

  export type thumbnailFormatMpeg4 = {
    /**
     * The thumbnail is in MPEG4 format. It will be used only for some animations and
     * videos
     */
    _: 'thumbnailFormatMpeg4',
  }

  export type thumbnail = {
    /** Represents a thumbnail */
    _: 'thumbnail',
    /** Thumbnail format */
    format: ThumbnailFormat,
    /** Thumbnail width */
    width: number,
    /** Thumbnail height */
    height: number,
    /** The thumbnail */
    file: file,
  }

  export type maskPointForehead = {
    /** The mask is placed relatively to the forehead */
    _: 'maskPointForehead',
  }

  export type maskPointForehead$Input = {
    /** The mask is placed relatively to the forehead */
    readonly _: 'maskPointForehead',
  }

  export type maskPointEyes = {
    /** The mask is placed relatively to the eyes */
    _: 'maskPointEyes',
  }

  export type maskPointEyes$Input = {
    /** The mask is placed relatively to the eyes */
    readonly _: 'maskPointEyes',
  }

  export type maskPointMouth = {
    /** The mask is placed relatively to the mouth */
    _: 'maskPointMouth',
  }

  export type maskPointMouth$Input = {
    /** The mask is placed relatively to the mouth */
    readonly _: 'maskPointMouth',
  }

  export type maskPointChin = {
    /** The mask is placed relatively to the chin */
    _: 'maskPointChin',
  }

  export type maskPointChin$Input = {
    /** The mask is placed relatively to the chin */
    readonly _: 'maskPointChin',
  }

  export type maskPosition = {
    /** Position on a photo where a mask is placed */
    _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    point: MaskPoint,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    x_shift: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    y_shift: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    scale: number,
  }

  export type maskPosition$Input = {
    /** Position on a photo where a mask is placed */
    readonly _: 'maskPosition',
    /** Part of the face, relative to which the mask is placed */
    readonly point?: MaskPoint$Input,
    /**
     * Shift by X-axis measured in widths of the mask scaled to the face size, from
     * left to right. (For example, -1.0 will place the mask just to the left of the
     * default mask position)
     */
    readonly x_shift?: number,
    /**
     * Shift by Y-axis measured in heights of the mask scaled to the face size, from
     * top to bottom. (For example, 1.0 will place the mask just below the default
     * mask position)
     */
    readonly y_shift?: number,
    /** Mask scaling coefficient. (For example, 2.0 means a doubled size) */
    readonly scale?: number,
  }

  export type closedVectorPath = {
    /**
     * Represents a closed vector path. The path begins at the end point of the last
     * command
     */
    _: 'closedVectorPath',
    /** List of vector path commands */
    commands: Array<VectorPathCommand>,
  }

  export type pollOption = {
    /** Describes one answer option of a poll */
    _: 'pollOption',
    /** Option text; 1-100 characters */
    text: string,
    /** Number of voters for this option, available only for closed or voted polls */
    voter_count: number,
    /** The percentage of votes for this option; 0-100 */
    vote_percentage: number,
    /** True, if the option was chosen by the user */
    is_chosen: boolean,
    /** True, if the option is being chosen by a pending setPollAnswer request */
    is_being_chosen: boolean,
  }

  export type pollTypeRegular = {
    /** A regular poll */
    _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    allow_multiple_answers: boolean,
  }

  export type pollTypeRegular$Input = {
    /** A regular poll */
    readonly _: 'pollTypeRegular',
    /** True, if multiple answer options can be chosen simultaneously */
    readonly allow_multiple_answers?: boolean,
  }

  export type pollTypeQuiz = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    correct_option_id: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    explanation: formattedText,
  }

  export type pollTypeQuiz$Input = {
    /**
     * A poll in quiz mode, which has exactly one correct answer option and can be
     * answered only once
     */
    readonly _: 'pollTypeQuiz',
    /** 0-based identifier of the correct answer option; -1 for a yet unanswered poll */
    readonly correct_option_id?: number,
    /**
     * Text that is shown when the user chooses an incorrect answer or taps on the
     * lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered
     * poll
     */
    readonly explanation?: formattedText$Input,
  }

  export type animation = {
    /** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
    _: 'animation',
    /** Duration of the animation, in seconds; as defined by the sender */
    duration: number,
    /** Width of the animation */
    width: number,
    /** Height of the animation */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file, usually "image/gif" or "video/mp4" */
    mime_type: string,
    /**
     * True, if stickers were added to the animation. The list of corresponding sticker
     * set can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Animation minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Animation thumbnail in JPEG or MPEG4 format; may be null */
    thumbnail?: thumbnail,
    /** File containing the animation */
    animation: file,
  }

  export type audio = {
    /** Describes an audio file. Audio is usually in MP3 or M4A format */
    _: 'audio',
    /** Duration of the audio, in seconds; as defined by the sender */
    duration: number,
    /** Title of the audio; as defined by the sender */
    title: string,
    /** Performer of the audio; as defined by the sender */
    performer: string,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** The MIME type of the file; as defined by the sender */
    mime_type: string,
    /** The minithumbnail of the album cover; may be null */
    album_cover_minithumbnail?: minithumbnail,
    /**
     * The thumbnail of the album cover in JPEG format; as defined by the sender. The
     * full size thumbnail is supposed to be extracted from the downloaded file; may
     * be null
     */
    album_cover_thumbnail?: thumbnail,
    /** File containing the audio */
    audio: file,
  }

  export type document = {
    /** Describes a document of any type */
    _: 'document',
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** Document minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /**
     * Document thumbnail in JPEG or PNG format (PNG will be used only for background
     * patterns); as defined by the sender; may be null
     */
    thumbnail?: thumbnail,
    /** File containing the document */
    document: file,
  }

  export type photo = {
    /** Describes a photo */
    _: 'photo',
    /**
     * True, if stickers were added to the photo. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo, in different sizes */
    sizes: Array<photoSize>,
  }

  export type sticker = {
    /** Describes a sticker */
    _: 'sticker',
    /** The identifier of the sticker set to which the sticker belongs; 0 if none */
    set_id: number | string,
    /** Sticker width; as defined by the sender */
    width: number,
    /** Sticker height; as defined by the sender */
    height: number,
    /** Emoji corresponding to the sticker */
    emoji: string,
    /** True, if the sticker is an animated sticker in TGS format */
    is_animated: boolean,
    /** True, if the sticker is a mask */
    is_mask: boolean,
    /** Position where the mask is placed; may be null */
    mask_position?: maskPosition,
    /**
     * Sticker's outline represented as a list of closed vector paths; may be empty.
     * The coordinate system origin is in the upper-left corner
     */
    outline: Array<closedVectorPath>,
    /** Sticker thumbnail in WEBP or JPEG format; may be null */
    thumbnail?: thumbnail,
    /** File containing the sticker */
    sticker: file,
  }

  export type video = {
    /** Describes a video file */
    _: 'video',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /** Video width; as defined by the sender */
    width: number,
    /** Video height; as defined by the sender */
    height: number,
    /** Original name of the file; as defined by the sender */
    file_name: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /**
     * True, if stickers were added to the video. The list of corresponding sticker
     * sets can be received using getAttachedStickerSets
     */
    has_stickers: boolean,
    /** True, if the video is supposed to be streamed */
    supports_streaming: boolean,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** File containing the video */
    video: file,
  }

  export type videoNote = {
    /**
     * Describes a video note. The video must be equal in width and height, cropped
     * to a circle, and stored in MPEG4 format
     */
    _: 'videoNote',
    /** Duration of the video, in seconds; as defined by the sender */
    duration: number,
    /** Video width and height; as defined by the sender */
    length: number,
    /** Video minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Video thumbnail in JPEG format; as defined by the sender; may be null */
    thumbnail?: thumbnail,
    /** File containing the video */
    video: file,
  }

  export type voiceNote = {
    /**
     * Describes a voice note. The voice note must be encoded with the Opus codec,
     * and stored inside an OGG container. Voice notes can have only a single audio
     * channel
     */
    _: 'voiceNote',
    /** Duration of the voice note, in seconds; as defined by the sender */
    duration: number,
    /** A waveform representation of the voice note in 5-bit format */
    waveform: string,
    /** MIME type of the file; as defined by the sender */
    mime_type: string,
    /** File containing the voice note */
    voice: file,
  }

  export type animatedEmoji = {
    /** Describes an animated representation of an emoji */
    _: 'animatedEmoji',
    /** Animated sticker for the emoji */
    sticker: sticker,
    /** Emoji modifier fitzpatrick type; 0-6; 0 if none */
    fitzpatrick_type: number,
    /**
     * File containing the sound to be played when the animated emoji is clicked if
     * any; may be null. The sound is encoded with the Opus codec, and stored inside
     * an OGG container
     */
    sound?: file,
  }

  export type contact = {
    /** Describes a user contact */
    _: 'contact',
    /** Phone number of the user */
    phone_number: string,
    /** First name of the user; 1-255 characters in length */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    vcard: string,
    /** Identifier of the user, if known; otherwise 0 */
    user_id: number,
  }

  export type contact$Input = {
    /** Describes a user contact */
    readonly _: 'contact',
    /** Phone number of the user */
    readonly phone_number?: string,
    /** First name of the user; 1-255 characters in length */
    readonly first_name?: string,
    /** Last name of the user */
    readonly last_name?: string,
    /** Additional data about the user in a form of vCard; 0-2048 bytes in length */
    readonly vcard?: string,
    /** Identifier of the user, if known; otherwise 0 */
    readonly user_id?: number,
  }

  export type location = {
    /** Describes a location on planet Earth */
    _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    latitude: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    longitude: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    horizontal_accuracy: number,
  }

  export type location$Input = {
    /** Describes a location on planet Earth */
    readonly _: 'location',
    /** Latitude of the location in degrees; as defined by the sender */
    readonly latitude?: number,
    /** Longitude of the location, in degrees; as defined by the sender */
    readonly longitude?: number,
    /**
     * The estimated horizontal accuracy of the location, in meters; as defined by
     * the sender. 0 if unknown
     */
    readonly horizontal_accuracy?: number,
  }

  export type venue = {
    /** Describes a venue */
    _: 'venue',
    /** Venue location; as defined by the sender */
    location: location,
    /** Venue name; as defined by the sender */
    title: string,
    /** Venue address; as defined by the sender */
    address: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    provider: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    id: string,
    /** Type of the venue in the provider database; as defined by the sender */
    type: string,
  }

  export type venue$Input = {
    /** Describes a venue */
    readonly _: 'venue',
    /** Venue location; as defined by the sender */
    readonly location?: location$Input,
    /** Venue name; as defined by the sender */
    readonly title?: string,
    /** Venue address; as defined by the sender */
    readonly address?: string,
    /**
     * Provider of the venue database; as defined by the sender. Currently, only "foursquare"
     * and "gplaces" (Google Places) need to be supported
     */
    readonly provider?: string,
    /** Identifier of the venue in the provider database; as defined by the sender */
    readonly id?: string,
    /** Type of the venue in the provider database; as defined by the sender */
    readonly type?: string,
  }

  export type game = {
    /** Describes a game */
    _: 'game',
    /** Game ID */
    id: number | string,
    /** Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name} */
    short_name: string,
    /** Game title */
    title: string,
    /** Game text, usually containing scoreboards for a game */
    text: formattedText,
    /** Game description */
    description: string,
    /** Game photo */
    photo: photo,
    /** Game animation; may be null */
    animation?: animation,
  }

  export type poll = {
    /** Describes a poll */
    _: 'poll',
    /** Unique poll identifier */
    id: number | string,
    /** Poll question; 1-300 characters */
    question: string,
    /** List of poll answer options */
    options: Array<pollOption>,
    /** Total number of voters, participating in the poll */
    total_voter_count: number,
    /** User identifiers of recent voters, if the poll is non-anonymous */
    recent_voter_user_ids: Array<number>,
    /** True, if the poll is anonymous */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /** Amount of time the poll will be active after creation, in seconds */
    open_period: number,
    /** Point in time (Unix timestamp) when the poll will automatically be closed */
    close_date: number,
    /** True, if the poll is closed */
    is_closed: boolean,
  }

  export type profilePhoto = {
    /** Describes a user profile photo */
    _: 'profilePhoto',
    /**
     * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list
     * of user profile photos
     */
    id: number | string,
    /**
     * A small (160x160) user profile photo. The file can be downloaded only before
     * the photo is changed
     */
    small: file,
    /**
     * A big (640x640) user profile photo. The file can be downloaded only before the
     * photo is changed
     */
    big: file,
    /** User profile photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
  }

  export type chatPhotoInfo = {
    /** Contains basic information about the photo of a chat */
    _: 'chatPhotoInfo',
    /**
     * A small (160x160) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    small: file,
    /**
     * A big (640x640) chat photo variant in JPEG format. The file can be downloaded
     * only before the photo is changed
     */
    big: file,
    /** Chat photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** True, if the photo has animated variant */
    has_animation: boolean,
  }

  export type userTypeRegular = {
    /** A regular user */
    _: 'userTypeRegular',
  }

  export type userTypeDeleted = {
    /**
     * A deleted user or deleted bot. No information on the user besides the user identifier
     * is available. It is not possible to perform any active actions on this type
     * of user
     */
    _: 'userTypeDeleted',
  }

  export type userTypeBot = {
    /** A bot (see https://core.telegram.org/bots) */
    _: 'userTypeBot',
    /** True, if the bot can be invited to basic group and supergroup chats */
    can_join_groups: boolean,
    /**
     * True, if the bot can read all messages in basic group or supergroup chats and
     * not just those addressed to the bot. In private and channel chats a bot can
     * always read all messages
     */
    can_read_all_group_messages: boolean,
    /** True, if the bot supports inline queries */
    is_inline: boolean,
    /** Placeholder for inline queries (displayed on the application input field) */
    inline_query_placeholder: string,
    /**
     * True, if the location of the user is expected to be sent with every inline query
     * to this bot
     */
    need_location: boolean,
  }

  export type userTypeUnknown = {
    /**
     * No information on the user besides the user identifier is available, yet this
     * user has not been deleted. This object is extremely rare and must be handled
     * like a deleted user. It is not possible to perform any actions on users of this
     * type
     */
    _: 'userTypeUnknown',
  }

  export type botCommand = {
    /** Represents a command supported by a bot */
    _: 'botCommand',
    /** Text of the bot command */
    command: string,
    /** Description of the bot command */
    description: string,
  }

  export type botCommand$Input = {
    /** Represents a command supported by a bot */
    readonly _: 'botCommand',
    /** Text of the bot command */
    readonly command?: string,
    /** Description of the bot command */
    readonly description?: string,
  }

  export type botCommands = {
    /** Contains a list of bot commands */
    _: 'botCommands',
    /** Bot's user identifier */
    bot_user_id: number,
    /** List of bot commands */
    commands: Array<botCommand>,
  }

  export type chatLocation = {
    /** Represents a location to which a chat is connected */
    _: 'chatLocation',
    /** The location */
    location: location,
    /** Location address; 1-64 characters, as defined by the chat owner */
    address: string,
  }

  export type chatLocation$Input = {
    /** Represents a location to which a chat is connected */
    readonly _: 'chatLocation',
    /** The location */
    readonly location?: location$Input,
    /** Location address; 1-64 characters, as defined by the chat owner */
    readonly address?: string,
  }

  export type animatedChatPhoto = {
    /** Animated variant of a chat photo in MPEG4 format */
    _: 'animatedChatPhoto',
    /** Animation width and height */
    length: number,
    /** Information about the animation file */
    file: file,
    /** Timestamp of the frame, used as a static chat photo */
    main_frame_timestamp: number,
  }

  export type chatPhoto = {
    /** Describes a chat or user profile photo */
    _: 'chatPhoto',
    /** Unique photo identifier */
    id: number | string,
    /** Point in time (Unix timestamp) when the photo has been added */
    added_date: number,
    /** Photo minithumbnail; may be null */
    minithumbnail?: minithumbnail,
    /** Available variants of the photo in JPEG format, in different size */
    sizes: Array<photoSize>,
    /** Animated variant of the photo in MPEG4 format; may be null */
    animation?: animatedChatPhoto,
  }

  export type chatPhotos = {
    /** Contains a list of chat or user profile photos */
    _: 'chatPhotos',
    /** Total number of photos */
    total_count: number,
    /** List of photos */
    photos: Array<chatPhoto>,
  }

  export type inputChatPhotoPrevious$Input = {
    /** A previously used profile photo of the current user */
    readonly _: 'inputChatPhotoPrevious',
    /** Identifier of the current user's profile photo to reuse */
    readonly chat_photo_id?: number | string,
  }

  export type inputChatPhotoStatic$Input = {
    /** A static photo in JPEG format */
    readonly _: 'inputChatPhotoStatic',
    /**
     * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly photo?: InputFile$Input,
  }

  export type inputChatPhotoAnimation$Input = {
    /**
     * An animation in MPEG4 format; must be square, at most 10 seconds long, have
     * width between 160 and 800 and be at most 2MB in size
     */
    readonly _: 'inputChatPhotoAnimation',
    /**
     * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated
     * are allowed
     */
    readonly animation?: InputFile$Input,
    /** Timestamp of the frame, which will be used as static chat photo */
    readonly main_frame_timestamp?: number,
  }

  export type user = {
    /** Represents a user */
    _: 'user',
    /** User identifier */
    id: number,
    /** First name of the user */
    first_name: string,
    /** Last name of the user */
    last_name: string,
    /** Username of the user */
    username: string,
    /** Phone number of the user */
    phone_number: string,
    /** Current online status of the user */
    status: UserStatus,
    /** Profile photo of the user; may be null */
    profile_photo?: profilePhoto,
    /** The user is a contact of the current user */
    is_contact: boolean,
    /**
     * The user is a contact of the current user and the current user is a contact
     * of the user
     */
    is_mutual_contact: boolean,
    /** True, if the user is verified */
    is_verified: boolean,
    /** True, if the user is Telegram support account */
    is_support: boolean,
    /**
     * If non-empty, it contains a human-readable description of the reason why access
     * to this user must be restricted
     */
    restriction_reason: string,
    /** True, if many users reported this user as a scam */
    is_scam: boolean,
    /** True, if many users reported this user as a fake account */
    is_fake: boolean,
    /**
     * If false, the user is inaccessible, and the only information known about the
     * user is inside this class. It can't be passed to any method except GetUser
     */
    have_access: boolean,
    /** Type of the user */
    type: UserType,
    /** IETF language tag of the user's language; only available to bots */
    language_code: string,
  }

  export type userFullInfo = {
    /** Contains full information about a user */
    _: 'userFullInfo',
    /** User profile photo; may be null */
    photo?: chatPhoto,
    /** True, if the user is blocked by the current user */
    is_blocked: boolean,
    /** True, if the user can be called */
    can_be_called: boolean,
    /** True, if a video call can be created with the user */
    supports_video_calls: boolean,
    /** True, if the user can't be called due to their privacy settings */
    has_private_calls: boolean,
    /**
     * True, if the user can't be linked in forwarded messages due to their privacy
     * settings
     */
    has_private_forwards: boolean,
    /**
     * True, if the current user needs to explicitly allow to share their phone number
     * with the user when the method addContact is used
     */
    need_phone_number_privacy_exception: boolean,
    /** A short user bio */
    bio: string,
    /**
     * For bots, the text that is shown on the bot's profile page and is sent together
     * with the link when users share the bot
     */
    share_text: string,
    /** For bots, the text shown in the chat with the bot if the chat is empty */
    description: string,
    /**
     * Number of group chats where both the other user and the current user are a member;
     * 0 for the current user
     */
    group_in_common_count: number,
    /** For bots, list of the bot commands */
    commands: Array<botCommand>,
  }

  export type users = {
    /** Represents a list of users */
    _: 'users',
    /** Approximate total count of users found */
    total_count: number,
    /** A list of user identifiers */
    user_ids: Array<number>,
  }

  export type chatAdministrator = {
    /** Contains information about a chat administrator */
    _: 'chatAdministrator',
    /** User identifier of the administrator */
    user_id: number,
    /** Custom title of the administrator */
    custom_title: string,
    /** True, if the user is the owner of the chat */
    is_owner: boolean,
  }

  export type chatAdministrators = {
    /** Represents a list of chat administrators */
    _: 'chatAdministrators',
    /** A list of chat administrators */
    administrators: Array<chatAdministrator>,
  }

  export type chatPermissions = {
    /** Describes actions that a user is allowed to take in a chat */
    _: 'chatPermissions',
    /** True, if the user can send text messages, contacts, locations, and venues */
    can_send_messages: boolean,
    /**
     * True, if the user can send audio files, documents, photos, videos, video notes,
     * and voice notes. Implies can_send_messages permissions
     */
    can_send_media_messages: boolean,
    /** True, if the user can send polls. Implies can_send_messages permissions */
    can_send_polls: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots. Implies can_send_messages permissions
     */
    can_send_other_messages: boolean,
    /**
     * True, if the user may add a web page preview to their messages. Implies can_send_messages
     * permissions
     */
    can_add_web_page_previews: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /** True, if the user can invite new users to the chat */
    can_invite_users: boolean,
    /** True, if the user can pin messages */
    can_pin_messages: boolean,
  }

  export type chatPermissions$Input = {
    /** Describes actions that a user is allowed to take in a chat */
    readonly _: 'chatPermissions',
    /** True, if the user can send text messages, contacts, locations, and venues */
    readonly can_send_messages?: boolean,
    /**
     * True, if the user can send audio files, documents, photos, videos, video notes,
     * and voice notes. Implies can_send_messages permissions
     */
    readonly can_send_media_messages?: boolean,
    /** True, if the user can send polls. Implies can_send_messages permissions */
    readonly can_send_polls?: boolean,
    /**
     * True, if the user can send animations, games, stickers, and dice and use inline
     * bots. Implies can_send_messages permissions
     */
    readonly can_send_other_messages?: boolean,
    /**
     * True, if the user may add a web page preview to their messages. Implies can_send_messages
     * permissions
     */
    readonly can_add_web_page_previews?: boolean,
    /** True, if the user can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /** True, if the user can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /** True, if the user can pin messages */
    readonly can_pin_messages?: boolean,
  }

  export type chatMemberStatusCreator = {
    /** The user is the owner of the chat and has all the administrator privileges */
    _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
     * only
     */
    custom_title: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
    /** True, if the user is a member of the chat */
    is_member: boolean,
  }

  export type chatMemberStatusCreator$Input = {
    /** The user is the owner of the chat and has all the administrator privileges */
    readonly _: 'chatMemberStatusCreator',
    /**
     * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups
     * only
     */
    readonly custom_title?: string,
    /**
     * True, if the creator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
  }

  export type chatMemberStatusAdministrator = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emojis; applicable
     * to supergroups only
     */
    custom_title: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    can_be_edited: boolean,
    /**
     * True, if the administrator can get chat event log, get chat statistics, get
     * message statistics in channels, get channel members, see anonymous administrators
     * in supergroups and ignore slow mode. Implied by any other privilege; applicable
     * to supergroups and channels only
     */
    can_manage_chat: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    can_change_info: boolean,
    /**
     * True, if the administrator can create channel posts; applicable to channels
     * only
     */
    can_post_messages: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    can_edit_messages: boolean,
    /** True, if the administrator can delete messages of other users */
    can_delete_messages: boolean,
    /** True, if the administrator can invite new users to the chat */
    can_invite_users: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members; always
     * true for channels
     */
    can_restrict_members: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    can_pin_messages: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    can_promote_members: boolean,
    /** True, if the administrator can manage video chats */
    can_manage_video_chats: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    is_anonymous: boolean,
  }

  export type chatMemberStatusAdministrator$Input = {
    /**
     * The user is a member of the chat and has some additional privileges. In basic
     * groups, administrators can edit and delete messages sent by others, add new
     * members, ban unprivileged members, and manage video chats. In supergroups and
     * channels, there are more detailed options for administrator privileges
     */
    readonly _: 'chatMemberStatusAdministrator',
    /**
     * A custom title of the administrator; 0-16 characters without emojis; applicable
     * to supergroups only
     */
    readonly custom_title?: string,
    /**
     * True, if the current user can edit the administrator privileges for the called
     * user
     */
    readonly can_be_edited?: boolean,
    /**
     * True, if the administrator can get chat event log, get chat statistics, get
     * message statistics in channels, get channel members, see anonymous administrators
     * in supergroups and ignore slow mode. Implied by any other privilege; applicable
     * to supergroups and channels only
     */
    readonly can_manage_chat?: boolean,
    /** True, if the administrator can change the chat title, photo, and other settings */
    readonly can_change_info?: boolean,
    /**
     * True, if the administrator can create channel posts; applicable to channels
     * only
     */
    readonly can_post_messages?: boolean,
    /**
     * True, if the administrator can edit messages of other users and pin messages;
     * applicable to channels only
     */
    readonly can_edit_messages?: boolean,
    /** True, if the administrator can delete messages of other users */
    readonly can_delete_messages?: boolean,
    /** True, if the administrator can invite new users to the chat */
    readonly can_invite_users?: boolean,
    /**
     * True, if the administrator can restrict, ban, or unban chat members; always
     * true for channels
     */
    readonly can_restrict_members?: boolean,
    /**
     * True, if the administrator can pin messages; applicable to basic groups and
     * supergroups only
     */
    readonly can_pin_messages?: boolean,
    /**
     * True, if the administrator can add new administrators with a subset of their
     * own privileges or demote administrators that were directly or indirectly promoted
     * by them
     */
    readonly can_promote_members?: boolean,
    /** True, if the administrator can manage video chats */
    readonly can_manage_video_chats?: boolean,
    /**
     * True, if the administrator isn't shown in the chat member list and sends messages
     * anonymously; applicable to supergroups only
     */
    readonly is_anonymous?: boolean,
  }

  export type chatMemberStatusMember = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    _: 'chatMemberStatusMember',
  }

  export type chatMemberStatusMember$Input = {
    /** The user is a member of the chat, without any additional privileges or restrictions */
    readonly _: 'chatMemberStatusMember',
  }

  export type chatMemberStatusRestricted = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    is_member: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    restricted_until_date: number,
    /** User permissions in the chat */
    permissions: chatPermissions,
  }

  export type chatMemberStatusRestricted$Input = {
    /**
     * The user is under certain restrictions in the chat. Not supported in basic groups
     * and channels
     */
    readonly _: 'chatMemberStatusRestricted',
    /** True, if the user is a member of the chat */
    readonly is_member?: boolean,
    /**
     * Point in time (Unix timestamp) when restrictions will be lifted from the user;
     * 0 if never. If the user is restricted for more than 366 days or for less than
     * 30 seconds from the current time, the user is considered to be restricted forever
     */
    readonly restricted_until_date?: number,
    /** User permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type chatMemberStatusLeft = {
    /** The user or the chat is not a chat member */
    _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusLeft$Input = {
    /** The user or the chat is not a chat member */
    readonly _: 'chatMemberStatusLeft',
  }

  export type chatMemberStatusBanned = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    banned_until_date: number,
  }

  export type chatMemberStatusBanned$Input = {
    /**
     * The user or the chat was banned (and hence is not a member of the chat). Implies
     * the user can't return to the chat, view messages, or be used as a participant
     * identifier to join a video chat of the chat
     */
    readonly _: 'chatMemberStatusBanned',
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Always 0 in basic
     * groups
     */
    readonly banned_until_date?: number,
  }

  export type chatMember = {
    /** Describes a user or a chat as a member of another chat */
    _: 'chatMember',
    /**
     * Identifier of the chat member. Currently, other chats can be only Left or Banned.
     * Only supergroups and channels can have other chats as Left or Banned members
     * and these chats must be supergroups or channels
     */
    member_id: MessageSender,
    /**
     * Identifier of a user that invited/promoted/banned this member in the chat; 0
     * if unknown
     */
    inviter_user_id: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
    /** Status of the member in the chat */
    status: ChatMemberStatus,
  }

  export type chatMembers = {
    /** Contains a list of chat members */
    _: 'chatMembers',
    /** Approximate total count of chat members found */
    total_count: number,
    /** A list of chat members */
    members: Array<chatMember>,
  }

  export type chatMembersFilterContacts$Input = {
    /** Returns contacts of the user */
    readonly _: 'chatMembersFilterContacts',
  }

  export type chatMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'chatMembersFilterAdministrators',
  }

  export type chatMembersFilterMembers$Input = {
    /** Returns all chat members, including restricted chat members */
    readonly _: 'chatMembersFilterMembers',
  }

  export type chatMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the chat */
    readonly _: 'chatMembersFilterMention',
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type chatMembersFilterRestricted$Input = {
    /**
     * Returns users under certain restrictions in the chat; can be used only by administrators
     * in a supergroup
     */
    readonly _: 'chatMembersFilterRestricted',
  }

  export type chatMembersFilterBanned$Input = {
    /**
     * Returns users banned from the chat; can be used only by administrators in a
     * supergroup or in a channel
     */
    readonly _: 'chatMembersFilterBanned',
  }

  export type chatMembersFilterBots$Input = {
    /** Returns bot members of the chat */
    readonly _: 'chatMembersFilterBots',
  }

  export type supergroupMembersFilterRecent$Input = {
    /** Returns recently active users in reverse chronological order */
    readonly _: 'supergroupMembersFilterRecent',
  }

  export type supergroupMembersFilterContacts$Input = {
    /** Returns contacts of the user, which are members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterContacts',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterAdministrators$Input = {
    /** Returns the owner and administrators */
    readonly _: 'supergroupMembersFilterAdministrators',
  }

  export type supergroupMembersFilterSearch$Input = {
    /** Used to search for supergroup or channel members via a (string) query */
    readonly _: 'supergroupMembersFilterSearch',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterRestricted$Input = {
    /** Returns restricted supergroup members; can be used only by administrators */
    readonly _: 'supergroupMembersFilterRestricted',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterBanned$Input = {
    /** Returns users banned from the supergroup or channel; can be used only by administrators */
    readonly _: 'supergroupMembersFilterBanned',
    /** Query to search for */
    readonly query?: string,
  }

  export type supergroupMembersFilterMention$Input = {
    /** Returns users which can be mentioned in the supergroup */
    readonly _: 'supergroupMembersFilterMention',
    /** Query to search for */
    readonly query?: string,
    /** If non-zero, the identifier of the current message thread */
    readonly message_thread_id?: number,
  }

  export type supergroupMembersFilterBots$Input = {
    /** Returns bot members of the supergroup or channel */
    readonly _: 'supergroupMembersFilterBots',
  }

  export type chatInviteLink = {
    /** Contains a chat invite link */
    _: 'chatInviteLink',
    /** Chat invite link */
    invite_link: string,
    /** Name of the link */
    name: string,
    /** User identifier of an administrator created the link */
    creator_user_id: number,
    /** Point in time (Unix timestamp) when the link was created */
    date: number,
    /**
     * Point in time (Unix timestamp) when the link was last edited; 0 if never or
     * unknown
     */
    edit_date: number,
    /** Point in time (Unix timestamp) when the link will expire; 0 if never */
    expiration_date: number,
    /**
     * The maximum number of members, which can join the chat using the link simultaneously;
     * 0 if not limited. Always 0 if the link requires approval
     */
    member_limit: number,
    /** Number of chat members, which joined the chat using the link */
    member_count: number,
    /** Number of pending join requests created using this link */
    pending_join_request_count: number,
    /**
     * True, if the link only creates join request. If true, total number of joining
     * members will be unlimited
     */
    creates_join_request: boolean,
    /**
     * True, if the link is primary. Primary invite link can't have name, expiration
     * date, or usage limit. There is exactly one primary invite link for each administrator
     * with can_invite_users right at a given time
     */
    is_primary: boolean,
    /** True, if the link was revoked */
    is_revoked: boolean,
  }

  export type chatInviteLinks = {
    /** Contains a list of chat invite links */
    _: 'chatInviteLinks',
    /** Approximate total count of chat invite links found */
    total_count: number,
    /** List of invite links */
    invite_links: Array<chatInviteLink>,
  }

  export type chatInviteLinkCount = {
    /**
     * Describes a chat administrator with a number of active and revoked chat invite
     * links
     */
    _: 'chatInviteLinkCount',
    /** Administrator's user identifier */
    user_id: number,
    /** Number of active invite links */
    invite_link_count: number,
    /** Number of revoked invite links */
    revoked_invite_link_count: number,
  }

  export type chatInviteLinkCounts = {
    /** Contains a list of chat invite link counts */
    _: 'chatInviteLinkCounts',
    /** List of invite link counts */
    invite_link_counts: Array<chatInviteLinkCount>,
  }

  export type chatInviteLinkMember = {
    /** Describes a chat member joined a chat via an invite link */
    _: 'chatInviteLinkMember',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    joined_chat_date: number,
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
  }

  export type chatInviteLinkMember$Input = {
    /** Describes a chat member joined a chat via an invite link */
    readonly _: 'chatInviteLinkMember',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user joined the chat */
    readonly joined_chat_date?: number,
    /** User identifier of the chat administrator, approved user join request */
    readonly approver_user_id?: number,
  }

  export type chatInviteLinkMembers = {
    /** Contains a list of chat members joined a chat via an invite link */
    _: 'chatInviteLinkMembers',
    /** Approximate total count of chat members found */
    total_count: number,
    /** List of chat members, joined a chat via an invite link */
    members: Array<chatInviteLinkMember>,
  }

  export type chatInviteLinkInfo = {
    /** Contains information about a chat invite link */
    _: 'chatInviteLinkInfo',
    /**
     * Chat identifier of the invite link; 0 if the user has no access to the chat
     * before joining
     */
    chat_id: number,
    /**
     * If non-zero, the amount of time for which read access to the chat will remain
     * available, in seconds
     */
    accessible_for: number,
    /** Type of the chat */
    type: ChatType,
    /** Title of the chat */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Chat description */
    description: string,
    /** Number of members in the chat */
    member_count: number,
    /** User identifiers of some chat members that may be known to the current user */
    member_user_ids: Array<number>,
    /** True, if the link only creates join request */
    creates_join_request: boolean,
    /**
     * True, if the chat is a public supergroup or channel, i.e. it has a username
     * or it is a location-based supergroup
     */
    is_public: boolean,
  }

  export type chatJoinRequest = {
    /** Describes a user that sent a join request and waits for administrator approval */
    _: 'chatJoinRequest',
    /** User identifier */
    user_id: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    date: number,
    /** A short bio of the user */
    bio: string,
  }

  export type chatJoinRequest$Input = {
    /** Describes a user that sent a join request and waits for administrator approval */
    readonly _: 'chatJoinRequest',
    /** User identifier */
    readonly user_id?: number,
    /** Point in time (Unix timestamp) when the user sent the join request */
    readonly date?: number,
    /** A short bio of the user */
    readonly bio?: string,
  }

  export type chatJoinRequests = {
    /** Contains a list of requests to join a chat */
    _: 'chatJoinRequests',
    /** Approximate total count of requests found */
    total_count: number,
    /** List of the requests */
    requests: Array<chatJoinRequest>,
  }

  export type chatJoinRequestsInfo = {
    /** Contains information about pending join requests for a chat */
    _: 'chatJoinRequestsInfo',
    /** Total number of pending join requests */
    total_count: number,
    /** Identifiers of at most 3 users sent the newest pending join requests */
    user_ids: Array<number>,
  }

  export type basicGroup = {
    /**
     * Represents a basic group of 0-200 users (must be upgraded to a supergroup to
     * accommodate more than 200 users)
     */
    _: 'basicGroup',
    /** Group identifier */
    id: number,
    /** Number of members in the group */
    member_count: number,
    /** Status of the current user in the group */
    status: ChatMemberStatus,
    /** True, if the group is active */
    is_active: boolean,
    /** Identifier of the supergroup to which this group was upgraded; 0 if none */
    upgraded_to_supergroup_id: number,
  }

  export type basicGroupFullInfo = {
    /** Contains full information about a basic group */
    _: 'basicGroupFullInfo',
    /** Chat photo; may be null */
    photo?: chatPhoto,
    /** Group description. Updated only after the basic group is opened */
    description: string,
    /** User identifier of the creator of the group; 0 if unknown */
    creator_user_id: number,
    /** Group members */
    members: Array<chatMember>,
    /**
     * Primary invite link for this group; may be null. For chat administrators with
     * can_invite_users right only. Updated only after the basic group is opened
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
  }

  export type supergroup = {
    /**
     * Represents a supergroup or channel with zero or more members (subscribers in
     * the case of channels). From the point of view of the system, a channel is a
     * special kind of a supergroup: only administrators can post and see the list
     * of members, and posts from all administrators use the name and photo of the
     * channel instead of individual names and profile photos. Unlike supergroups,
     * channels can have an unlimited number of subscribers
     */
    _: 'supergroup',
    /** Supergroup or channel identifier */
    id: number,
    /** Username of the supergroup or channel; empty for private supergroups or channels */
    username: string,
    /**
     * Point in time (Unix timestamp) when the current user joined, or the point in
     * time when the supergroup or channel was created, in case the user is not a member
     */
    date: number,
    /**
     * Status of the current user in the supergroup or channel; custom title will be
     * always empty
     */
    status: ChatMemberStatus,
    /**
     * Number of members in the supergroup or channel; 0 if unknown. Currently, it
     * is guaranteed to be known only if the supergroup or channel was received through
     * searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats,
     * getGroupsInCommon, or getUserPrivacySettingRules
     */
    member_count: number,
    /**
     * True, if the channel has a discussion group, or the supergroup is the designated
     * discussion group for a channel
     */
    has_linked_chat: boolean,
    /**
     * True, if the supergroup is connected to a location, i.e. the supergroup is a
     * location-based supergroup
     */
    has_location: boolean,
    /**
     * True, if messages sent to the channel need to contain information about the
     * sender. This field is only applicable to channels
     */
    sign_messages: boolean,
    /** True, if the slow mode is enabled in the supergroup */
    is_slow_mode_enabled: boolean,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
    /**
     * True, if the supergroup is a broadcast group, i.e. only administrators can send
     * messages and there is no limit on the number of members
     */
    is_broadcast_group: boolean,
    /** True, if the supergroup or channel is verified */
    is_verified: boolean,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this supergroup or channel must be restricted
     */
    restriction_reason: string,
    /** True, if many users reported this supergroup or channel as a scam */
    is_scam: boolean,
    /** True, if many users reported this supergroup or channel as a fake account */
    is_fake: boolean,
  }

  export type supergroupFullInfo = {
    /** Contains full information about a supergroup or channel */
    _: 'supergroupFullInfo',
    /** Chat photo; may be null */
    photo?: chatPhoto,
    /** Supergroup or channel description */
    description: string,
    /** Number of members in the supergroup or channel; 0 if unknown */
    member_count: number,
    /** Number of privileged users in the supergroup or channel; 0 if unknown */
    administrator_count: number,
    /** Number of restricted users in the supergroup; 0 if unknown */
    restricted_count: number,
    /** Number of users banned from chat; 0 if unknown */
    banned_count: number,
    /**
     * Chat identifier of a discussion group for the channel, or a channel, for which
     * the supergroup is the designated discussion group; 0 if none or unknown
     */
    linked_chat_id: number,
    /**
     * Delay between consecutive sent messages for non-administrator supergroup members,
     * in seconds
     */
    slow_mode_delay: number,
    /**
     * Time left before next message can be sent in the supergroup, in seconds. An
     * updateSupergroupFullInfo update is not triggered when value of this field changes,
     * but both new and old values are non-zero
     */
    slow_mode_delay_expires_in: number,
    /** True, if members of the chat can be retrieved */
    can_get_members: boolean,
    /** True, if the chat username can be changed */
    can_set_username: boolean,
    /** True, if the supergroup sticker set can be changed */
    can_set_sticker_set: boolean,
    /** True, if the supergroup location can be changed */
    can_set_location: boolean,
    /** True, if the supergroup or channel statistics are available */
    can_get_statistics: boolean,
    /**
     * True, if new chat members will have access to old messages. In public or discussion
     * groups and both public and private channels, old messages are always available,
     * so this option affects only private supergroups without a linked chat. The value
     * of this field is only available for chat administrators
     */
    is_all_history_available: boolean,
    /** Identifier of the supergroup sticker set; 0 if none */
    sticker_set_id: number | string,
    /** Location to which the supergroup is connected; may be null */
    location?: chatLocation,
    /**
     * Primary invite link for this chat; may be null. For chat administrators with
     * can_invite_users right only
     */
    invite_link?: chatInviteLink,
    /** List of commands of bots in the group */
    bot_commands: Array<botCommands>,
    /** Identifier of the basic group from which supergroup was upgraded; 0 if none */
    upgraded_from_basic_group_id: number,
    /**
     * Identifier of the last message in the basic group from which supergroup was
     * upgraded; 0 if none
     */
    upgraded_from_max_message_id: number,
  }

  export type secretChatStatePending = {
    /** The secret chat is not yet created; waiting for the other user to get online */
    _: 'secretChatStatePending',
  }

  export type secretChatStateReady = {
    /** The secret chat is ready to use */
    _: 'secretChatStateReady',
  }

  export type secretChatStateClosed = {
    /** The secret chat is closed */
    _: 'secretChatStateClosed',
  }

  export type secretChat = {
    /** Represents a secret chat */
    _: 'secretChat',
    /** Secret chat identifier */
    id: number,
    /** Identifier of the chat partner */
    user_id: number,
    /** State of the secret chat */
    state: SecretChatState,
    /** True, if the chat was created by the current user; otherwise false */
    is_outbound: boolean,
    /**
     * Hash of the currently used key for comparison with the hash of the chat partner's
     * key. This is a string of 36 little-endian bytes, which must be split into groups
     * of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775,
     * and 2F99C9. The pixels must be used to make a 12x12 square image filled from
     * left to right, top to bottom. Alternatively, the first 32 bytes of the hash
     * can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
     */
    key_hash: string,
    /**
     * Secret chat layer; determines features supported by the chat partner's application.
     * Nested text entities and underline and strikethrough entities are supported
     * if the layer >= 101
     */
    layer: number,
  }

  export type messageSenderUser = {
    /** The message was sent by a known user */
    _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    user_id: number,
  }

  export type messageSenderUser$Input = {
    /** The message was sent by a known user */
    readonly _: 'messageSenderUser',
    /** Identifier of the user that sent the message */
    readonly user_id?: number,
  }

  export type messageSenderChat = {
    /** The message was sent on behalf of a chat */
    _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    chat_id: number,
  }

  export type messageSenderChat$Input = {
    /** The message was sent on behalf of a chat */
    readonly _: 'messageSenderChat',
    /** Identifier of the chat that sent the message */
    readonly chat_id?: number,
  }

  export type messageSenders = {
    /** Represents a list of message senders */
    _: 'messageSenders',
    /** Approximate total count of messages senders found */
    total_count: number,
    /** List of message senders */
    senders: Array<MessageSender>,
  }

  export type messageForwardOriginUser = {
    /** The message was originally sent by a known user */
    _: 'messageForwardOriginUser',
    /** Identifier of the user that originally sent the message */
    sender_user_id: number,
  }

  export type messageForwardOriginChat = {
    /** The message was originally sent on behalf of a chat */
    _: 'messageForwardOriginChat',
    /** Identifier of the chat that originally sent the message */
    sender_chat_id: number,
    /**
     * For messages originally sent by an anonymous chat administrator, original message
     * author signature
     */
    author_signature: string,
  }

  export type messageForwardOriginHiddenUser = {
    /**
     * The message was originally sent by a user, which is hidden by their privacy
     * settings
     */
    _: 'messageForwardOriginHiddenUser',
    /** Name of the sender */
    sender_name: string,
  }

  export type messageForwardOriginChannel = {
    /** The message was originally a post in a channel */
    _: 'messageForwardOriginChannel',
    /** Identifier of the chat from which the message was originally forwarded */
    chat_id: number,
    /** Message identifier of the original message */
    message_id: number,
    /** Original post author signature */
    author_signature: string,
  }

  export type messageForwardOriginMessageImport = {
    /** The message was imported from an exported message history */
    _: 'messageForwardOriginMessageImport',
    /** Name of the sender */
    sender_name: string,
  }

  export type messageForwardInfo = {
    /** Contains information about a forwarded message */
    _: 'messageForwardInfo',
    /** Origin of a forwarded message */
    origin: MessageForwardOrigin,
    /** Point in time (Unix timestamp) when the message was originally sent */
    date: number,
    /** The type of a public service announcement for the forwarded message */
    public_service_announcement_type: string,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, the identifier of
     * the chat from which the message was forwarded last time; 0 if unknown
     */
    from_chat_id: number,
    /**
     * For messages forwarded to the chat with the current user (Saved Messages), to
     * the Replies bot chat, or to the channel's discussion group, the identifier of
     * the original message from which the new message was forwarded last time; 0 if
     * unknown
     */
    from_message_id: number,
  }

  export type messageReplyInfo = {
    /** Contains information about replies to a message */
    _: 'messageReplyInfo',
    /** Number of times the message was directly or indirectly replied */
    reply_count: number,
    /**
     * Identifiers of at most 3 recent repliers to the message; available in channels
     * with a discussion supergroup. The users and chats are expected to be inaccessible:
     * only their photo and name will be available
     */
    recent_replier_ids: Array<MessageSender>,
    /** Identifier of the last read incoming reply to the message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing reply to the message */
    last_read_outbox_message_id: number,
    /** Identifier of the last reply to the message */
    last_message_id: number,
  }

  export type messageInteractionInfo = {
    /** Contains information about interactions with a message */
    _: 'messageInteractionInfo',
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
    /**
     * Information about direct or indirect replies to the message; may be null. Currently,
     * available only in channels with a discussion supergroup and discussion supergroups
     * for messages, which are not replies itself
     */
    reply_info?: messageReplyInfo,
  }

  export type messageSendingStatePending = {
    /** The message is being sent now, but has not yet been delivered to the server */
    _: 'messageSendingStatePending',
  }

  export type messageSendingStateFailed = {
    /** The message failed to be sent */
    _: 'messageSendingStateFailed',
    /** An error code; 0 if unknown */
    error_code: number,
    /** Error message */
    error_message: string,
    /** True, if the message can be re-sent */
    can_retry: boolean,
    /** True, if the message can be re-sent only on behalf of a different sender */
    need_another_sender: boolean,
    /**
     * Time left before the message can be re-sent, in seconds. No update is sent when
     * this field changes
     */
    retry_after: number,
  }

  export type message = {
    /** Describes a message */
    _: 'message',
    /** Message identifier; unique for the chat to which the message belongs */
    id: number,
    /** Identifier of the sender of the message */
    sender_id: MessageSender,
    /** Chat identifier */
    chat_id: number,
    /** The sending state of the message; may be null */
    sending_state?: MessageSendingState,
    /** The scheduling state of the message; may be null */
    scheduling_state?: MessageSchedulingState,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** True, if the message is pinned */
    is_pinned: boolean,
    /**
     * True, if the message can be edited. For live location and poll messages this
     * fields shows whether editMessageLiveLocation or stopPoll can be used with this
     * message by the application
     */
    can_be_edited: boolean,
    /** True, if the message can be forwarded */
    can_be_forwarded: boolean,
    /** True, if content of the message can be saved locally or copied */
    can_be_saved: boolean,
    /**
     * True, if the message can be deleted only for the current user while other users
     * will continue to see it
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the message can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /** True, if the message statistics are available */
    can_get_statistics: boolean,
    /** True, if the message thread info is available */
    can_get_message_thread: boolean,
    /** True, if chat members already viewed the message can be received through getMessageViewers */
    can_get_viewers: boolean,
    /**
     * True, if media timestamp links can be generated for media timestamp entities
     * in the message text, caption or web page description
     */
    can_get_media_timestamp_links: boolean,
    /**
     * True, if media timestamp entities refers to a media in this message as opposed
     * to a media in the replied message
     */
    has_timestamped_media: boolean,
    /**
     * True, if the message is a channel post. All messages to channels are channel
     * posts, all other messages are not channel posts
     */
    is_channel_post: boolean,
    /** True, if the message contains an unread mention for the current user */
    contains_unread_mention: boolean,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
    /** Point in time (Unix timestamp) when the message was last edited */
    edit_date: number,
    /** Information about the initial message sender; may be null */
    forward_info?: messageForwardInfo,
    /** Information about interactions with the message; may be null */
    interaction_info?: messageInteractionInfo,
    /**
     * If non-zero, the identifier of the chat to which the replied message belongs;
     * Currently, only messages in the Replies chat can have different reply_in_chat_id
     * and chat_id
     */
    reply_in_chat_id: number,
    /**
     * If non-zero, the identifier of the message this message is replying to; can
     * be the identifier of a deleted message
     */
    reply_to_message_id: number,
    /**
     * If non-zero, the identifier of the message thread the message belongs to; unique
     * within the chat to which the message belongs
     */
    message_thread_id: number,
    /**
     * For self-destructing messages, the message's TTL (Time To Live), in seconds;
     * 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once
     * the TTL expires
     */
    ttl: number,
    /**
     * Time left before the message expires, in seconds. If the TTL timer isn't started
     * yet, equals to the value of the ttl field
     */
    ttl_expires_in: number,
    /** If non-zero, the user identifier of the bot through which this message was sent */
    via_bot_user_id: number,
    /** For channel posts and anonymous group messages, optional author signature */
    author_signature: string,
    /**
     * Unique identifier of an album this message belongs to. Only audios, documents,
     * photos and videos can be grouped together in albums
     */
    media_album_id: number | string,
    /**
     * If non-empty, contains a human-readable description of the reason why access
     * to this message must be restricted
     */
    restriction_reason: string,
    /** Content of the message */
    content: MessageContent,
    /** Reply markup for the message; may be null */
    reply_markup?: ReplyMarkup,
  }

  export type messages = {
    /** Contains a list of messages */
    _: 'messages',
    /** Approximate total count of messages found */
    total_count: number,
    /** List of messages; messages may be null */
    messages: Array<message | null>,
  }

  export type foundMessages = {
    /** Contains a list of messages found by a search */
    _: 'foundMessages',
    /** Approximate total count of messages found; -1 if unknown */
    total_count: number,
    /** List of messages */
    messages: Array<message>,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
  }

  export type messagePosition = {
    /** Contains information about a message in a specific position */
    _: 'messagePosition',
    /** 0-based message position in the full list of suitable messages */
    position: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was sent */
    date: number,
  }

  export type messagePositions = {
    /** Contains a list of message positions */
    _: 'messagePositions',
    /** Total count of messages found */
    total_count: number,
    /** List of message positions */
    positions: Array<messagePosition>,
  }

  export type messageCalendarDay = {
    /** Contains information about found messages sent on a specific day */
    _: 'messageCalendarDay',
    /** Total number of found messages sent on the day */
    total_count: number,
    /** First message sent on the day */
    message: message,
  }

  export type messageCalendar = {
    /**
     * Contains information about found messages, split by days according to the option
     * "utc_time_offset"
     */
    _: 'messageCalendar',
    /** Total number of found messages */
    total_count: number,
    /** Information about messages sent */
    days: Array<messageCalendarDay>,
  }

  export type sponsoredMessage = {
    /** Describes a sponsored message */
    _: 'sponsoredMessage',
    /**
     * Message identifier; unique for the chat to which the sponsored message belongs
     * among both ordinary and sponsored messages
     */
    message_id: number,
    /** Chat identifier */
    sponsor_chat_id: number,
    /**
     * An internal link to be opened when the sponsored message is clicked; may be
     * null. If null, the sponsor chat needs to be opened instead
     */
    link?: InternalLinkType,
    /** Content of the message. Currently, can be only of the type messageText */
    content: MessageContent,
  }

  export type notificationSettingsScopePrivateChats = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopePrivateChats$Input = {
    /**
     * Notification settings applied to all private and secret chats when the corresponding
     * chat setting has a default value
     */
    readonly _: 'notificationSettingsScopePrivateChats',
  }

  export type notificationSettingsScopeGroupChats = {
    /**
     * Notification settings applied to all basic groups and supergroups when the corresponding
     * chat setting has a default value
     */
    _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeGroupChats$Input = {
    /**
     * Notification settings applied to all basic groups and supergroups when the corresponding
     * chat setting has a default value
     */
    readonly _: 'notificationSettingsScopeGroupChats',
  }

  export type notificationSettingsScopeChannelChats = {
    /**
     * Notification settings applied to all channels when the corresponding chat setting
     * has a default value
     */
    _: 'notificationSettingsScopeChannelChats',
  }

  export type notificationSettingsScopeChannelChats$Input = {
    /**
     * Notification settings applied to all channels when the corresponding chat setting
     * has a default value
     */
    readonly _: 'notificationSettingsScopeChannelChats',
  }

  export type chatNotificationSettings = {
    /** Contains information about notification settings for a chat */
    _: 'chatNotificationSettings',
    /**
     * If true, mute_for is ignored and the value for the relevant type of chat is
     * used instead
     */
    use_default_mute_for: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /**
     * If true, sound is ignored and the value for the relevant type of chat is used
     * instead
     */
    use_default_sound: boolean,
    /**
     * The name of an audio file to be used for notification sounds; only applies to
     * iOS applications
     */
    sound: string,
    /**
     * If true, show_preview is ignored and the value for the relevant type of chat
     * is used instead
     */
    use_default_show_preview: boolean,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * If true, disable_pinned_message_notifications is ignored and the value for the
     * relevant type of chat is used instead
     */
    use_default_disable_pinned_message_notifications: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * If true, disable_mention_notifications is ignored and the value for the relevant
     * type of chat is used instead
     */
    use_default_disable_mention_notifications: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type chatNotificationSettings$Input = {
    /** Contains information about notification settings for a chat */
    readonly _: 'chatNotificationSettings',
    /**
     * If true, mute_for is ignored and the value for the relevant type of chat is
     * used instead
     */
    readonly use_default_mute_for?: boolean,
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /**
     * If true, sound is ignored and the value for the relevant type of chat is used
     * instead
     */
    readonly use_default_sound?: boolean,
    /**
     * The name of an audio file to be used for notification sounds; only applies to
     * iOS applications
     */
    readonly sound?: string,
    /**
     * If true, show_preview is ignored and the value for the relevant type of chat
     * is used instead
     */
    readonly use_default_show_preview?: boolean,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /**
     * If true, disable_pinned_message_notifications is ignored and the value for the
     * relevant type of chat is used instead
     */
    readonly use_default_disable_pinned_message_notifications?: boolean,
    /**
     * If true, notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * If true, disable_mention_notifications is ignored and the value for the relevant
     * type of chat is used instead
     */
    readonly use_default_disable_mention_notifications?: boolean,
    /**
     * If true, notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type scopeNotificationSettings = {
    /** Contains information about notification settings for several chats */
    _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    mute_for: number,
    /**
     * The name of an audio file to be used for notification sounds; only applies to
     * iOS applications
     */
    sound: string,
    /** True, if message content must be displayed in notifications */
    show_preview: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    disable_pinned_message_notifications: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    disable_mention_notifications: boolean,
  }

  export type scopeNotificationSettings$Input = {
    /** Contains information about notification settings for several chats */
    readonly _: 'scopeNotificationSettings',
    /** Time left before notifications will be unmuted, in seconds */
    readonly mute_for?: number,
    /**
     * The name of an audio file to be used for notification sounds; only applies to
     * iOS applications
     */
    readonly sound?: string,
    /** True, if message content must be displayed in notifications */
    readonly show_preview?: boolean,
    /**
     * True, if notifications for incoming pinned messages will be created as for an
     * ordinary unread message
     */
    readonly disable_pinned_message_notifications?: boolean,
    /**
     * True, if notifications for messages with mentions will be created as for an
     * ordinary unread message
     */
    readonly disable_mention_notifications?: boolean,
  }

  export type draftMessage = {
    /** Contains information about a message draft */
    _: 'draftMessage',
    /** Identifier of the message to reply to; 0 if none */
    reply_to_message_id: number,
    /** Point in time (Unix timestamp) when the draft was created */
    date: number,
    /** Content of the message draft; must be of the type inputMessageText */
    input_message_text: InputMessageContent,
  }

  export type draftMessage$Input = {
    /** Contains information about a message draft */
    readonly _: 'draftMessage',
    /** Identifier of the message to reply to; 0 if none */
    readonly reply_to_message_id?: number,
    /** Point in time (Unix timestamp) when the draft was created */
    readonly date?: number,
    /** Content of the message draft; must be of the type inputMessageText */
    readonly input_message_text?: InputMessageContent$Input,
  }

  export type chatTypePrivate = {
    /** An ordinary chat with a user */
    _: 'chatTypePrivate',
    /** User identifier */
    user_id: number,
  }

  export type chatTypeBasicGroup = {
    /** A basic group (a chat with 0-200 other users) */
    _: 'chatTypeBasicGroup',
    /** Basic group identifier */
    basic_group_id: number,
  }

  export type chatTypeSupergroup = {
    /** A supergroup or channel (with unlimited members) */
    _: 'chatTypeSupergroup',
    /** Supergroup or channel identifier */
    supergroup_id: number,
    /** True, if the supergroup is a channel */
    is_channel: boolean,
  }

  export type chatTypeSecret = {
    /** A secret chat with a user */
    _: 'chatTypeSecret',
    /** Secret chat identifier */
    secret_chat_id: number,
    /** User identifier of the secret chat peer */
    user_id: number,
  }

  export type chatFilter = {
    /** Represents a filter of user chats */
    _: 'chatFilter',
    /** The title of the filter; 1-12 characters without line feeds */
    title: string,
    /**
     * The chosen icon name for short filter representation. If non-empty, must be
     * one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private",
     * "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love",
     * "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work". If empty, use
     * getChatFilterDefaultIconName to get default icon name for the filter
     */
    icon_name: string,
    /** The chat identifiers of pinned chats in the filtered chat list */
    pinned_chat_ids: Array<number>,
    /** The chat identifiers of always included chats in the filtered chat list */
    included_chat_ids: Array<number>,
    /** The chat identifiers of always excluded chats in the filtered chat list */
    excluded_chat_ids: Array<number>,
    /** True, if muted chats need to be excluded */
    exclude_muted: boolean,
    /** True, if read chats need to be excluded */
    exclude_read: boolean,
    /** True, if archived chats need to be excluded */
    exclude_archived: boolean,
    /** True, if contacts need to be included */
    include_contacts: boolean,
    /** True, if non-contact users need to be included */
    include_non_contacts: boolean,
    /** True, if bots need to be included */
    include_bots: boolean,
    /** True, if basic groups and supergroups need to be included */
    include_groups: boolean,
    /** True, if channels need to be included */
    include_channels: boolean,
  }

  export type chatFilter$Input = {
    /** Represents a filter of user chats */
    readonly _: 'chatFilter',
    /** The title of the filter; 1-12 characters without line feeds */
    readonly title?: string,
    /**
     * The chosen icon name for short filter representation. If non-empty, must be
     * one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private",
     * "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love",
     * "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work". If empty, use
     * getChatFilterDefaultIconName to get default icon name for the filter
     */
    readonly icon_name?: string,
    /** The chat identifiers of pinned chats in the filtered chat list */
    readonly pinned_chat_ids?: ReadonlyArray<number>,
    /** The chat identifiers of always included chats in the filtered chat list */
    readonly included_chat_ids?: ReadonlyArray<number>,
    /** The chat identifiers of always excluded chats in the filtered chat list */
    readonly excluded_chat_ids?: ReadonlyArray<number>,
    /** True, if muted chats need to be excluded */
    readonly exclude_muted?: boolean,
    /** True, if read chats need to be excluded */
    readonly exclude_read?: boolean,
    /** True, if archived chats need to be excluded */
    readonly exclude_archived?: boolean,
    /** True, if contacts need to be included */
    readonly include_contacts?: boolean,
    /** True, if non-contact users need to be included */
    readonly include_non_contacts?: boolean,
    /** True, if bots need to be included */
    readonly include_bots?: boolean,
    /** True, if basic groups and supergroups need to be included */
    readonly include_groups?: boolean,
    /** True, if channels need to be included */
    readonly include_channels?: boolean,
  }

  export type chatFilterInfo = {
    /** Contains basic information about a chat filter */
    _: 'chatFilterInfo',
    /** Unique chat filter identifier */
    id: number,
    /** The title of the filter; 1-12 characters without line feeds */
    title: string,
    /**
     * The chosen or default icon name for short filter representation. One of "All",
     * "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup",
     * "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party",
     * "Sport", "Study", "Trade", "Travel", "Work"
     */
    icon_name: string,
  }

  export type recommendedChatFilter = {
    /** Describes a recommended chat filter */
    _: 'recommendedChatFilter',
    /** The chat filter */
    filter: chatFilter,
    /** Chat filter description */
    description: string,
  }

  export type recommendedChatFilters = {
    /** Contains a list of recommended chat filters */
    _: 'recommendedChatFilters',
    /** List of recommended chat filters */
    chat_filters: Array<recommendedChatFilter>,
  }

  export type chatListMain = {
    /** A main list of chats */
    _: 'chatListMain',
  }

  export type chatListMain$Input = {
    /** A main list of chats */
    readonly _: 'chatListMain',
  }

  export type chatListArchive = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    _: 'chatListArchive',
  }

  export type chatListArchive$Input = {
    /**
     * A list of chats usually located at the top of the main chat list. Unmuted chats
     * are automatically moved from the Archive to the Main chat list when a new message
     * arrives
     */
    readonly _: 'chatListArchive',
  }

  export type chatListFilter = {
    /** A list of chats belonging to a chat filter */
    _: 'chatListFilter',
    /** Chat filter identifier */
    chat_filter_id: number,
  }

  export type chatListFilter$Input = {
    /** A list of chats belonging to a chat filter */
    readonly _: 'chatListFilter',
    /** Chat filter identifier */
    readonly chat_filter_id?: number,
  }

  export type chatLists = {
    /** Contains a list of chat lists */
    _: 'chatLists',
    /** List of chat lists */
    chat_lists: Array<ChatList>,
  }

  export type chatSourceMtprotoProxy = {
    /** The chat is sponsored by the user's MTProxy server */
    _: 'chatSourceMtprotoProxy',
  }

  export type chatSourcePublicServiceAnnouncement = {
    /** The chat contains a public service announcement */
    _: 'chatSourcePublicServiceAnnouncement',
    /** The type of the announcement */
    type: string,
    /** The text of the announcement */
    text: string,
  }

  export type chatPosition = {
    /** Describes a position of a chat in a chat list */
    _: 'chatPosition',
    /** The chat list */
    list: ChatList,
    /**
     * A parameter used to determine order of the chat in the chat list. Chats must
     * be sorted by the pair (order, chat.id) in descending order
     */
    order: number | string,
    /** True, if the chat is pinned in the chat list */
    is_pinned: boolean,
    /** Source of the chat in the chat list; may be null */
    source?: ChatSource,
  }

  export type videoChat = {
    /** Describes a video chat */
    _: 'videoChat',
    /**
     * Group call identifier of an active video chat; 0 if none. Full information about
     * the video chat can be received through the method getGroupCall
     */
    group_call_id: number,
    /** True, if the video chat has participants */
    has_participants: boolean,
    /** Default group call participant identifier to join the video chat; may be null */
    default_participant_id?: MessageSender,
  }

  export type chat = {
    /** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
    _: 'chat',
    /** Chat unique identifier */
    id: number,
    /** Type of the chat */
    type: ChatType,
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Actions that non-administrator chat members are allowed to take in the chat */
    permissions: chatPermissions,
    /** Last message in the chat; may be null */
    last_message?: message,
    /** Positions of the chat in chat lists */
    positions: Array<chatPosition>,
    /**
     * Identifier of a user or chat that is selected to send messages in the chat;
     * may be null if the user can't change message sender
     */
    message_sender_id?: MessageSender,
    /** True, if chat content can't be saved locally, forwarded, or copied */
    has_protected_content: boolean,
    /** True, if the chat is marked as unread */
    is_marked_as_unread: boolean,
    /**
     * True, if the chat is blocked by the current user and private messages from the
     * chat can't be received
     */
    is_blocked: boolean,
    /** True, if the chat has scheduled messages */
    has_scheduled_messages: boolean,
    /**
     * True, if the chat messages can be deleted only for the current user while other
     * users will continue to see the messages
     */
    can_be_deleted_only_for_self: boolean,
    /** True, if the chat messages can be deleted for all users */
    can_be_deleted_for_all_users: boolean,
    /**
     * True, if the chat can be reported to Telegram moderators through reportChat
     * or reportChatPhoto
     */
    can_be_reported: boolean,
    /**
     * Default value of the disable_notification parameter, used when a message is
     * sent to the chat
     */
    default_disable_notification: boolean,
    /** Number of unread messages in the chat */
    unread_count: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** Identifier of the last read outgoing message */
    last_read_outbox_message_id: number,
    /** Number of unread messages with a mention/reply in the chat */
    unread_mention_count: number,
    /** Notification settings for this chat */
    notification_settings: chatNotificationSettings,
    /**
     * Current message Time To Live setting (self-destruct timer) for the chat; 0 if
     * not defined. TTL is counted from the time message or its content is viewed in
     * secret chats and from the send date in other chats
     */
    message_ttl: number,
    /** If non-empty, name of a theme, set for the chat */
    theme_name: string,
    /**
     * Information about actions which must be possible to do through the chat action
     * bar; may be null
     */
    action_bar?: ChatActionBar,
    /** Information about video chat of the chat */
    video_chat: videoChat,
    /** Information about pending join requests; may be null */
    pending_join_requests?: chatJoinRequestsInfo,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
    /** A draft of a message in the chat; may be null */
    draft_message?: draftMessage,
    /**
     * Application-specific data associated with the chat. (For example, the chat scroll
     * position or local chat notification settings can be stored here.) Persistent
     * if the message database is used
     */
    client_data: string,
  }

  export type chats = {
    /** Represents a list of chats */
    _: 'chats',
    /** Approximate total count of chats found */
    total_count: number,
    /** List of chat identifiers */
    chat_ids: Array<number>,
  }

  export type chatNearby = {
    /** Describes a chat located nearby */
    _: 'chatNearby',
    /** Chat identifier */
    chat_id: number,
    /** Distance to the chat location, in meters */
    distance: number,
  }

  export type chatsNearby = {
    /** Represents a list of chats located nearby */
    _: 'chatsNearby',
    /** List of users nearby */
    users_nearby: Array<chatNearby>,
    /** List of location-based supergroups nearby */
    supergroups_nearby: Array<chatNearby>,
  }

  export type publicChatTypeHasUsername$Input = {
    /** The chat is public, because it has username */
    readonly _: 'publicChatTypeHasUsername',
  }

  export type publicChatTypeIsLocationBased$Input = {
    /** The chat is public, because it is a location-based supergroup */
    readonly _: 'publicChatTypeIsLocationBased',
  }

  export type chatActionBarReportSpam = {
    /**
     * The chat can be reported as spam using the method reportChat with the reason
     * chatReportReasonSpam
     */
    _: 'chatActionBarReportSpam',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
  }

  export type chatActionBarReportUnrelatedLocation = {
    /**
     * The chat is a location-based supergroup, which can be reported as having unrelated
     * location using the method reportChat with the reason chatReportReasonUnrelatedLocation
     */
    _: 'chatActionBarReportUnrelatedLocation',
  }

  export type chatActionBarInviteMembers = {
    /** The chat is a recently created group chat to which new members can be invited */
    _: 'chatActionBarInviteMembers',
  }

  export type chatActionBarReportAddBlock = {
    /**
     * The chat is a private or secret chat, which can be reported using the method
     * reportChat, or the other user can be blocked using the method toggleMessageSenderIsBlocked,
     * or the other user can be added to the contact list using the method addContact
     */
    _: 'chatActionBarReportAddBlock',
    /**
     * If true, the chat was automatically archived and can be moved back to the main
     * chat list using addChatToList simultaneously with setting chat notification
     * settings to default using setChatNotificationSettings
     */
    can_unarchive: boolean,
    /**
     * If non-negative, the current user was found by the peer through searchChatsNearby
     * and this is the distance between the users
     */
    distance: number,
  }

  export type chatActionBarAddContact = {
    /**
     * The chat is a private or secret chat and the other user can be added to the
     * contact list using the method addContact
     */
    _: 'chatActionBarAddContact',
  }

  export type chatActionBarSharePhoneNumber = {
    /**
     * The chat is a private or secret chat with a mutual contact and the user's phone
     * number can be shared with the other user using the method sharePhoneNumber
     */
    _: 'chatActionBarSharePhoneNumber',
  }

  export type chatActionBarJoinRequest = {
    /**
     * The chat is a private chat with an administrator of a chat to which the user
     * sent join request
     */
    _: 'chatActionBarJoinRequest',
    /** Title of the chat to which the join request was sent */
    title: string,
    /** True, if the join request was sent to a channel chat */
    is_channel: boolean,
    /** Point in time (Unix timestamp) when the join request was sent */
    request_date: number,
  }

  export type keyboardButtonTypeText = {
    /** A simple button, with text that must be sent when the button is pressed */
    _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeText$Input = {
    /** A simple button, with text that must be sent when the button is pressed */
    readonly _: 'keyboardButtonTypeText',
  }

  export type keyboardButtonTypeRequestPhoneNumber = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestPhoneNumber$Input = {
    /**
     * A button that sends the user's phone number when pressed; available only in
     * private chats
     */
    readonly _: 'keyboardButtonTypeRequestPhoneNumber',
  }

  export type keyboardButtonTypeRequestLocation = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestLocation$Input = {
    /**
     * A button that sends the user's location when pressed; available only in private
     * chats
     */
    readonly _: 'keyboardButtonTypeRequestLocation',
  }

  export type keyboardButtonTypeRequestPoll = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    force_regular: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    force_quiz: boolean,
  }

  export type keyboardButtonTypeRequestPoll$Input = {
    /**
     * A button that allows the user to create and send a poll when pressed; available
     * only in private chats
     */
    readonly _: 'keyboardButtonTypeRequestPoll',
    /** If true, only regular polls must be allowed to create */
    readonly force_regular?: boolean,
    /** If true, only polls in quiz mode must be allowed to create */
    readonly force_quiz?: boolean,
  }

  export type keyboardButton = {
    /** Represents a single button in a bot keyboard */
    _: 'keyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: KeyboardButtonType,
  }

  export type keyboardButton$Input = {
    /** Represents a single button in a bot keyboard */
    readonly _: 'keyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: KeyboardButtonType$Input,
  }

  export type inlineKeyboardButtonTypeUrl = {
    /** A button that opens a specified URL */
    _: 'inlineKeyboardButtonTypeUrl',
    /** HTTP or tg:// URL to open */
    url: string,
  }

  export type inlineKeyboardButtonTypeUrl$Input = {
    /** A button that opens a specified URL */
    readonly _: 'inlineKeyboardButtonTypeUrl',
    /** HTTP or tg:// URL to open */
    readonly url?: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user if allowed to do so
     */
    _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to open */
    url: string,
    /** Unique button identifier */
    id: number,
    /** If non-empty, new text of the button in forwarded messages */
    forward_text: string,
  }

  export type inlineKeyboardButtonTypeLoginUrl$Input = {
    /**
     * A button that opens a specified URL and automatically authorize the current
     * user if allowed to do so
     */
    readonly _: 'inlineKeyboardButtonTypeLoginUrl',
    /** An HTTP URL to open */
    readonly url?: string,
    /** Unique button identifier */
    readonly id?: number,
    /** If non-empty, new text of the button in forwarded messages */
    readonly forward_text?: string,
  }

  export type inlineKeyboardButtonTypeCallback = {
    /** A button that sends a callback query to a bot */
    _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    data: string,
  }

  export type inlineKeyboardButtonTypeCallback$Input = {
    /** A button that sends a callback query to a bot */
    readonly _: 'inlineKeyboardButtonTypeCallback',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword = {
    /**
     * A button that asks for password of the current user and then sends a callback
     * query to a bot
     */
    _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    data: string,
  }

  export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
    /**
     * A button that asks for password of the current user and then sends a callback
     * query to a bot
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackWithPassword',
    /** Data to be sent to the bot via a callback query */
    readonly data?: string,
  }

  export type inlineKeyboardButtonTypeCallbackGame = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeCallbackGame$Input = {
    /**
     * A button with a game that sends a callback query to a bot. This button must
     * be in the first column and row of the keyboard and can be attached only to a
     * message with content of the type messageGame
     */
    readonly _: 'inlineKeyboardButtonTypeCallbackGame',
  }

  export type inlineKeyboardButtonTypeSwitchInline = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    query: string,
    /** True, if the inline query must be sent from the current chat */
    in_current_chat: boolean,
  }

  export type inlineKeyboardButtonTypeSwitchInline$Input = {
    /**
     * A button that forces an inline query to the bot to be inserted in the input
     * field
     */
    readonly _: 'inlineKeyboardButtonTypeSwitchInline',
    /** Inline query to be sent to the bot */
    readonly query?: string,
    /** True, if the inline query must be sent from the current chat */
    readonly in_current_chat?: boolean,
  }

  export type inlineKeyboardButtonTypeBuy = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeBuy$Input = {
    /**
     * A button to buy something. This button must be in the first column and row of
     * the keyboard and can be attached only to a message with content of the type
     * messageInvoice
     */
    readonly _: 'inlineKeyboardButtonTypeBuy',
  }

  export type inlineKeyboardButtonTypeUser = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    user_id: number,
  }

  export type inlineKeyboardButtonTypeUser$Input = {
    /**
     * A button with a user reference to be handled in the same way as textEntityTypeMentionName
     * entities
     */
    readonly _: 'inlineKeyboardButtonTypeUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type inlineKeyboardButton = {
    /** Represents a single button in an inline keyboard */
    _: 'inlineKeyboardButton',
    /** Text of the button */
    text: string,
    /** Type of the button */
    type: InlineKeyboardButtonType,
  }

  export type inlineKeyboardButton$Input = {
    /** Represents a single button in an inline keyboard */
    readonly _: 'inlineKeyboardButton',
    /** Text of the button */
    readonly text?: string,
    /** Type of the button */
    readonly type?: InlineKeyboardButtonType$Input,
  }

  export type replyMarkupRemoveKeyboard = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    is_personal: boolean,
  }

  export type replyMarkupRemoveKeyboard$Input = {
    /**
     * Instructs application to remove the keyboard once this message has been received.
     * This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup
     * with message_id == 0 will be sent
     */
    readonly _: 'replyMarkupRemoveKeyboard',
    /**
     * True, if the keyboard is removed only for the mentioned users or the target
     * user of a reply
     */
    readonly is_personal?: boolean,
  }

  export type replyMarkupForceReply = {
    /** Instructs application to force a reply to this message */
    _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupForceReply$Input = {
    /** Instructs application to force a reply to this message */
    readonly _: 'replyMarkupForceReply',
    /**
     * True, if a forced reply must automatically be shown to the current user. For
     * outgoing messages, specify true to show the forced reply only for the mentioned
     * users and for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the reply
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupShowKeyboard = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    rows: Array<Array<keyboardButton>>,
    /** True, if the application needs to resize the keyboard vertically */
    resize_keyboard: boolean,
    /** True, if the application needs to hide the keyboard after use */
    one_time: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    is_personal: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    input_field_placeholder: string,
  }

  export type replyMarkupShowKeyboard$Input = {
    /** Contains a custom keyboard layout to quickly reply to bots */
    readonly _: 'replyMarkupShowKeyboard',
    /** A list of rows of bot keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<keyboardButton$Input>>,
    /** True, if the application needs to resize the keyboard vertically */
    readonly resize_keyboard?: boolean,
    /** True, if the application needs to hide the keyboard after use */
    readonly one_time?: boolean,
    /**
     * True, if the keyboard must automatically be shown to the current user. For outgoing
     * messages, specify true to show the keyboard only for the mentioned users and
     * for the target user of a reply
     */
    readonly is_personal?: boolean,
    /**
     * If non-empty, the placeholder to be shown in the input field when the keyboard
     * is active; 0-64 characters
     */
    readonly input_field_placeholder?: string,
  }

  export type replyMarkupInlineKeyboard = {
    /** Contains an inline keyboard layout */
    _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    rows: Array<Array<inlineKeyboardButton>>,
  }

  export type replyMarkupInlineKeyboard$Input = {
    /** Contains an inline keyboard layout */
    readonly _: 'replyMarkupInlineKeyboard',
    /** A list of rows of inline keyboard buttons */
    readonly rows?: ReadonlyArray<ReadonlyArray<inlineKeyboardButton$Input>>,
  }

  export type loginUrlInfoOpen = {
    /** An HTTP url needs to be open */
    _: 'loginUrlInfoOpen',
    /** The URL to open */
    url: string,
    /** True, if there is no need to show an ordinary open URL confirm */
    skip_confirm: boolean,
  }

  export type loginUrlInfoRequestConfirmation = {
    /** An authorization confirmation dialog needs to be shown to the user */
    _: 'loginUrlInfoRequestConfirmation',
    /** An HTTP URL to be opened */
    url: string,
    /** A domain of the URL */
    domain: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /**
     * True, if the user needs to be requested to give the permission to the bot to
     * send them messages
     */
    request_write_access: boolean,
  }

  export type messageThreadInfo = {
    /** Contains information about a message thread */
    _: 'messageThreadInfo',
    /** Identifier of the chat to which the message thread belongs */
    chat_id: number,
    /** Message thread identifier, unique within the chat */
    message_thread_id: number,
    /** Information about the message thread */
    reply_info: messageReplyInfo,
    /** Approximate number of unread messages in the message thread */
    unread_message_count: number,
    /**
     * The messages from which the thread starts. The messages are returned in a reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    messages: Array<message>,
    /** A draft of a message in the message thread; may be null */
    draft_message?: draftMessage,
  }

  export type richTextPlain = {
    /** A plain text */
    _: 'richTextPlain',
    /** Text */
    text: string,
  }

  export type richTextBold = {
    /** A bold rich text */
    _: 'richTextBold',
    /** Text */
    text: RichText,
  }

  export type richTextItalic = {
    /** An italicized rich text */
    _: 'richTextItalic',
    /** Text */
    text: RichText,
  }

  export type richTextUnderline = {
    /** An underlined rich text */
    _: 'richTextUnderline',
    /** Text */
    text: RichText,
  }

  export type richTextStrikethrough = {
    /** A strikethrough rich text */
    _: 'richTextStrikethrough',
    /** Text */
    text: RichText,
  }

  export type richTextFixed = {
    /** A fixed-width rich text */
    _: 'richTextFixed',
    /** Text */
    text: RichText,
  }

  export type richTextUrl = {
    /** A rich text URL link */
    _: 'richTextUrl',
    /** Text */
    text: RichText,
    /** URL */
    url: string,
    /** True, if the URL has cached instant view server-side */
    is_cached: boolean,
  }

  export type richTextEmailAddress = {
    /** A rich text email link */
    _: 'richTextEmailAddress',
    /** Text */
    text: RichText,
    /** Email address */
    email_address: string,
  }

  export type richTextSubscript = {
    /** A subscript rich text */
    _: 'richTextSubscript',
    /** Text */
    text: RichText,
  }

  export type richTextSuperscript = {
    /** A superscript rich text */
    _: 'richTextSuperscript',
    /** Text */
    text: RichText,
  }

  export type richTextMarked = {
    /** A marked rich text */
    _: 'richTextMarked',
    /** Text */
    text: RichText,
  }

  export type richTextPhoneNumber = {
    /** A rich text phone number */
    _: 'richTextPhoneNumber',
    /** Text */
    text: RichText,
    /** Phone number */
    phone_number: string,
  }

  export type richTextIcon = {
    /** A small image inside the text */
    _: 'richTextIcon',
    /** The image represented as a document. The image can be in GIF, JPEG or PNG format */
    document: document,
    /** Width of a bounding box in which the image must be shown; 0 if unknown */
    width: number,
    /** Height of a bounding box in which the image must be shown; 0 if unknown */
    height: number,
  }

  export type richTextReference = {
    /** A reference to a richTexts object on the same web page */
    _: 'richTextReference',
    /** The text */
    text: RichText,
    /**
     * The name of a richTextAnchor object, which is the first element of the target
     * richTexts object
     */
    anchor_name: string,
    /** An HTTP URL, opening the reference */
    url: string,
  }

  export type richTextAnchor = {
    /** An anchor */
    _: 'richTextAnchor',
    /** Anchor name */
    name: string,
  }

  export type richTextAnchorLink = {
    /** A link to an anchor on the same web page */
    _: 'richTextAnchorLink',
    /** The link text */
    text: RichText,
    /** The anchor name. If the name is empty, the link must bring back to top */
    anchor_name: string,
    /** An HTTP URL, opening the anchor */
    url: string,
  }

  export type richTexts = {
    /** A concatenation of rich texts */
    _: 'richTexts',
    /** Texts */
    texts: Array<RichText>,
  }

  export type pageBlockCaption = {
    /**
     * Contains a caption of an instant view web page block, consisting of a text and
     * a trailing credit
     */
    _: 'pageBlockCaption',
    /** Content of the caption */
    text: RichText,
    /** Block credit (like HTML tag <cite>) */
    credit: RichText,
  }

  export type pageBlockListItem = {
    /** Describes an item of a list page block */
    _: 'pageBlockListItem',
    /** Item label */
    label: string,
    /** Item blocks */
    page_blocks: Array<PageBlock>,
  }

  export type pageBlockHorizontalAlignmentLeft = {
    /** The content must be left-aligned */
    _: 'pageBlockHorizontalAlignmentLeft',
  }

  export type pageBlockHorizontalAlignmentCenter = {
    /** The content must be center-aligned */
    _: 'pageBlockHorizontalAlignmentCenter',
  }

  export type pageBlockHorizontalAlignmentRight = {
    /** The content must be right-aligned */
    _: 'pageBlockHorizontalAlignmentRight',
  }

  export type pageBlockVerticalAlignmentTop = {
    /** The content must be top-aligned */
    _: 'pageBlockVerticalAlignmentTop',
  }

  export type pageBlockVerticalAlignmentMiddle = {
    /** The content must be middle-aligned */
    _: 'pageBlockVerticalAlignmentMiddle',
  }

  export type pageBlockVerticalAlignmentBottom = {
    /** The content must be bottom-aligned */
    _: 'pageBlockVerticalAlignmentBottom',
  }

  export type pageBlockTableCell = {
    /** Represents a cell of a table */
    _: 'pageBlockTableCell',
    /** Cell text; may be null. If the text is null, then the cell must be invisible */
    text?: RichText,
    /** True, if it is a header cell */
    is_header: boolean,
    /** The number of columns the cell spans */
    colspan: number,
    /** The number of rows the cell spans */
    rowspan: number,
    /** Horizontal cell content alignment */
    align: PageBlockHorizontalAlignment,
    /** Vertical cell content alignment */
    valign: PageBlockVerticalAlignment,
  }

  export type pageBlockRelatedArticle = {
    /** Contains information about a related article */
    _: 'pageBlockRelatedArticle',
    /** Related article URL */
    url: string,
    /** Article title; may be empty */
    title: string,
    /** Article description; may be empty */
    description: string,
    /** Article photo; may be null */
    photo?: photo,
    /** Article author; may be empty */
    author: string,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockTitle = {
    /** The title of a page */
    _: 'pageBlockTitle',
    /** Title */
    title: RichText,
  }

  export type pageBlockSubtitle = {
    /** The subtitle of a page */
    _: 'pageBlockSubtitle',
    /** Subtitle */
    subtitle: RichText,
  }

  export type pageBlockAuthorDate = {
    /** The author and publishing date of a page */
    _: 'pageBlockAuthorDate',
    /** Author */
    author: RichText,
    /** Point in time (Unix timestamp) when the article was published; 0 if unknown */
    publish_date: number,
  }

  export type pageBlockHeader = {
    /** A header */
    _: 'pageBlockHeader',
    /** Header */
    header: RichText,
  }

  export type pageBlockSubheader = {
    /** A subheader */
    _: 'pageBlockSubheader',
    /** Subheader */
    subheader: RichText,
  }

  export type pageBlockKicker = {
    /** A kicker */
    _: 'pageBlockKicker',
    /** Kicker */
    kicker: RichText,
  }

  export type pageBlockParagraph = {
    /** A text paragraph */
    _: 'pageBlockParagraph',
    /** Paragraph text */
    text: RichText,
  }

  export type pageBlockPreformatted = {
    /** A preformatted text paragraph */
    _: 'pageBlockPreformatted',
    /** Paragraph text */
    text: RichText,
    /** Programming language for which the text needs to be formatted */
    language: string,
  }

  export type pageBlockFooter = {
    /** The footer of a page */
    _: 'pageBlockFooter',
    /** Footer */
    footer: RichText,
  }

  export type pageBlockDivider = {
    /** An empty block separating a page */
    _: 'pageBlockDivider',
  }

  export type pageBlockAnchor = {
    /**
     * An invisible anchor on a page, which can be used in a URL to open the page from
     * the specified anchor
     */
    _: 'pageBlockAnchor',
    /** Name of the anchor */
    name: string,
  }

  export type pageBlockList = {
    /** A list of data blocks */
    _: 'pageBlockList',
    /** The items of the list */
    items: Array<pageBlockListItem>,
  }

  export type pageBlockBlockQuote = {
    /** A block quote */
    _: 'pageBlockBlockQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockPullQuote = {
    /** A pull quote */
    _: 'pageBlockPullQuote',
    /** Quote text */
    text: RichText,
    /** Quote credit */
    credit: RichText,
  }

  export type pageBlockAnimation = {
    /** An animation */
    _: 'pageBlockAnimation',
    /** Animation file; may be null */
    animation?: animation,
    /** Animation caption */
    caption: pageBlockCaption,
    /** True, if the animation must be played automatically */
    need_autoplay: boolean,
  }

  export type pageBlockAudio = {
    /** An audio file */
    _: 'pageBlockAudio',
    /** Audio file; may be null */
    audio?: audio,
    /** Audio file caption */
    caption: pageBlockCaption,
  }

  export type pageBlockPhoto = {
    /** A photo */
    _: 'pageBlockPhoto',
    /** Photo file; may be null */
    photo?: photo,
    /** Photo caption */
    caption: pageBlockCaption,
    /** URL that needs to be opened when the photo is clicked */
    url: string,
  }

  export type pageBlockVideo = {
    /** A video */
    _: 'pageBlockVideo',
    /** Video file; may be null */
    video?: video,
    /** Video caption */
    caption: pageBlockCaption,
    /** True, if the video must be played automatically */
    need_autoplay: boolean,
    /** True, if the video must be looped */
    is_looped: boolean,
  }

  export type pageBlockVoiceNote = {
    /** A voice note */
    _: 'pageBlockVoiceNote',
    /** Voice note; may be null */
    voice_note?: voiceNote,
    /** Voice note caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCover = {
    /** A page cover */
    _: 'pageBlockCover',
    /** Cover */
    cover: PageBlock,
  }

  export type pageBlockEmbedded = {
    /** An embedded web page */
    _: 'pageBlockEmbedded',
    /** Web page URL, if available */
    url: string,
    /** HTML-markup of the embedded page */
    html: string,
    /** Poster photo, if available; may be null */
    poster_photo?: photo,
    /** Block width; 0 if unknown */
    width: number,
    /** Block height; 0 if unknown */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
    /** True, if the block must be full width */
    is_full_width: boolean,
    /** True, if scrolling needs to be allowed */
    allow_scrolling: boolean,
  }

  export type pageBlockEmbeddedPost = {
    /** An embedded post */
    _: 'pageBlockEmbeddedPost',
    /** Web page URL */
    url: string,
    /** Post author */
    author: string,
    /** Post author photo; may be null */
    author_photo?: photo,
    /** Point in time (Unix timestamp) when the post was created; 0 if unknown */
    date: number,
    /** Post content */
    page_blocks: Array<PageBlock>,
    /** Post caption */
    caption: pageBlockCaption,
  }

  export type pageBlockCollage = {
    /** A collage */
    _: 'pageBlockCollage',
    /** Collage item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockSlideshow = {
    /** A slideshow */
    _: 'pageBlockSlideshow',
    /** Slideshow item contents */
    page_blocks: Array<PageBlock>,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type pageBlockChatLink = {
    /** A link to a chat */
    _: 'pageBlockChatLink',
    /** Chat title */
    title: string,
    /** Chat photo; may be null */
    photo?: chatPhotoInfo,
    /** Chat username, by which all other information about the chat can be resolved */
    username: string,
  }

  export type pageBlockTable = {
    /** A table */
    _: 'pageBlockTable',
    /** Table caption */
    caption: RichText,
    /** Table cells */
    cells: Array<Array<pageBlockTableCell>>,
    /** True, if the table is bordered */
    is_bordered: boolean,
    /** True, if the table is striped */
    is_striped: boolean,
  }

  export type pageBlockDetails = {
    /** A collapsible block */
    _: 'pageBlockDetails',
    /** Always visible heading for the block */
    header: RichText,
    /** Block contents */
    page_blocks: Array<PageBlock>,
    /** True, if the block is open by default */
    is_open: boolean,
  }

  export type pageBlockRelatedArticles = {
    /** Related articles */
    _: 'pageBlockRelatedArticles',
    /** Block header */
    header: RichText,
    /** List of related articles */
    articles: Array<pageBlockRelatedArticle>,
  }

  export type pageBlockMap = {
    /** A map */
    _: 'pageBlockMap',
    /** Location of the map center */
    location: location,
    /** Map zoom level */
    zoom: number,
    /** Map width */
    width: number,
    /** Map height */
    height: number,
    /** Block caption */
    caption: pageBlockCaption,
  }

  export type webPageInstantView = {
    /** Describes an instant view page for a web page */
    _: 'webPageInstantView',
    /** Content of the web page */
    page_blocks: Array<PageBlock>,
    /** Number of the instant view views; 0 if unknown */
    view_count: number,
    /** Version of the instant view; currently, can be 1 or 2 */
    version: number,
    /** True, if the instant view must be shown from right to left */
    is_rtl: boolean,
    /**
     * True, if the instant view contains the full page. A network request might be
     * needed to get the full web page instant view
     */
    is_full: boolean,
    /** An internal link to be opened to leave feedback about the instant view */
    feedback_link: InternalLinkType,
  }

  export type webPage = {
    /** Describes a web page preview */
    _: 'webPage',
    /** Original URL of the link */
    url: string,
    /** URL to display */
    display_url: string,
    /**
     * Type of the web page. Can be: article, photo, audio, video, document, profile,
     * app, or something else
     */
    type: string,
    /** Short name of the site (e.g., Google Docs, App Store) */
    site_name: string,
    /** Title of the content */
    title: string,
    /** Description of the content */
    description: formattedText,
    /** Image representing the content; may be null */
    photo?: photo,
    /** URL to show in the embedded preview */
    embed_url: string,
    /** MIME type of the embedded preview, (e.g., text/html or video/mp4) */
    embed_type: string,
    /** Width of the embedded preview */
    embed_width: number,
    /** Height of the embedded preview */
    embed_height: number,
    /** Duration of the content, in seconds */
    duration: number,
    /** Author of the content */
    author: string,
    /** Preview of the content as an animation, if available; may be null */
    animation?: animation,
    /** Preview of the content as an audio file, if available; may be null */
    audio?: audio,
    /** Preview of the content as a document, if available; may be null */
    document?: document,
    /**
     * Preview of the content as a sticker for small WEBP files, if available; may
     * be null
     */
    sticker?: sticker,
    /** Preview of the content as a video, if available; may be null */
    video?: video,
    /** Preview of the content as a video note, if available; may be null */
    video_note?: videoNote,
    /** Preview of the content as a voice note, if available; may be null */
    voice_note?: voiceNote,
    /**
     * Version of instant view, available for the web page (currently, can be 1 or
     * 2), 0 if none
     */
    instant_view_version: number,
  }

  export type countryInfo = {
    /** Contains information about a country */
    _: 'countryInfo',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** Native name of the country */
    name: string,
    /** English name of the country */
    english_name: string,
    /** True, if the country must be hidden from the list of all countries */
    is_hidden: boolean,
    /** List of country calling codes */
    calling_codes: Array<string>,
  }

  export type countries = {
    /** Contains information about countries */
    _: 'countries',
    /** The list of countries */
    countries: Array<countryInfo>,
  }

  export type phoneNumberInfo = {
    /** Contains information about a phone number */
    _: 'phoneNumberInfo',
    /** Information about the country to which the phone number belongs; may be null */
    country?: countryInfo,
    /** The part of the phone number denoting country calling code or its part */
    country_calling_code: string,
    /**
     * The phone number without country calling code formatted accordingly to local
     * rules. Expected digits are returned as '-', but even more digits might be entered
     * by the user
     */
    formatted_phone_number: string,
  }

  export type bankCardActionOpenUrl = {
    /** Describes an action associated with a bank card number */
    _: 'bankCardActionOpenUrl',
    /** Action text */
    text: string,
    /** The URL to be opened */
    url: string,
  }

  export type bankCardInfo = {
    /** Information about a bank card */
    _: 'bankCardInfo',
    /** Title of the bank card description */
    title: string,
    /** Actions that can be done with the bank card number */
    actions: Array<bankCardActionOpenUrl>,
  }

  export type address = {
    /** Describes an address */
    _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    country_code: string,
    /** State, if applicable */
    state: string,
    /** City */
    city: string,
    /** First line of the address */
    street_line1: string,
    /** Second line of the address */
    street_line2: string,
    /** Address postal code */
    postal_code: string,
  }

  export type address$Input = {
    /** Describes an address */
    readonly _: 'address',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
    /** State, if applicable */
    readonly state?: string,
    /** City */
    readonly city?: string,
    /** First line of the address */
    readonly street_line1?: string,
    /** Second line of the address */
    readonly street_line2?: string,
    /** Address postal code */
    readonly postal_code?: string,
  }

  export type labeledPricePart = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    _: 'labeledPricePart',
    /** Label for this portion of the product price */
    label: string,
    /** Currency amount in the smallest units of the currency */
    amount: number,
  }

  export type labeledPricePart$Input = {
    /** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
    readonly _: 'labeledPricePart',
    /** Label for this portion of the product price */
    readonly label?: string,
    /** Currency amount in the smallest units of the currency */
    readonly amount?: number,
  }

  export type invoice = {
    /** Product invoice */
    _: 'invoice',
    /** ISO 4217 currency code */
    currency: string,
    /** A list of objects used to calculate the total price of the product */
    price_parts: Array<labeledPricePart>,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    max_tip_amount: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    suggested_tip_amounts: Array<number>,
    /** True, if the payment is a test payment */
    is_test: boolean,
    /** True, if the user's name is needed for payment */
    need_name: boolean,
    /** True, if the user's phone number is needed for payment */
    need_phone_number: boolean,
    /** True, if the user's email address is needed for payment */
    need_email_address: boolean,
    /** True, if the user's shipping address is needed for payment */
    need_shipping_address: boolean,
    /** True, if the user's phone number will be sent to the provider */
    send_phone_number_to_provider: boolean,
    /** True, if the user's email address will be sent to the provider */
    send_email_address_to_provider: boolean,
    /** True, if the total price depends on the shipping method */
    is_flexible: boolean,
  }

  export type invoice$Input = {
    /** Product invoice */
    readonly _: 'invoice',
    /** ISO 4217 currency code */
    readonly currency?: string,
    /** A list of objects used to calculate the total price of the product */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
    /** The maximum allowed amount of tip in the smallest units of the currency */
    readonly max_tip_amount?: number,
    /** Suggested amounts of tip in the smallest units of the currency */
    readonly suggested_tip_amounts?: ReadonlyArray<number>,
    /** True, if the payment is a test payment */
    readonly is_test?: boolean,
    /** True, if the user's name is needed for payment */
    readonly need_name?: boolean,
    /** True, if the user's phone number is needed for payment */
    readonly need_phone_number?: boolean,
    /** True, if the user's email address is needed for payment */
    readonly need_email_address?: boolean,
    /** True, if the user's shipping address is needed for payment */
    readonly need_shipping_address?: boolean,
    /** True, if the user's phone number will be sent to the provider */
    readonly send_phone_number_to_provider?: boolean,
    /** True, if the user's email address will be sent to the provider */
    readonly send_email_address_to_provider?: boolean,
    /** True, if the total price depends on the shipping method */
    readonly is_flexible?: boolean,
  }

  export type orderInfo = {
    /** Order information */
    _: 'orderInfo',
    /** Name of the user */
    name: string,
    /** Phone number of the user */
    phone_number: string,
    /** Email address of the user */
    email_address: string,
    /** Shipping address for this order; may be null */
    shipping_address?: address,
  }

  export type orderInfo$Input = {
    /** Order information */
    readonly _: 'orderInfo',
    /** Name of the user */
    readonly name?: string,
    /** Phone number of the user */
    readonly phone_number?: string,
    /** Email address of the user */
    readonly email_address?: string,
    /** Shipping address for this order; may be null */
    readonly shipping_address?: address$Input,
  }

  export type shippingOption = {
    /** One shipping option */
    _: 'shippingOption',
    /** Shipping option identifier */
    id: string,
    /** Option title */
    title: string,
    /** A list of objects used to calculate the total shipping costs */
    price_parts: Array<labeledPricePart>,
  }

  export type shippingOption$Input = {
    /** One shipping option */
    readonly _: 'shippingOption',
    /** Shipping option identifier */
    readonly id?: string,
    /** Option title */
    readonly title?: string,
    /** A list of objects used to calculate the total shipping costs */
    readonly price_parts?: ReadonlyArray<labeledPricePart$Input>,
  }

  export type savedCredentials = {
    /** Contains information about saved card credentials */
    _: 'savedCredentials',
    /** Unique identifier of the saved credentials */
    id: string,
    /** Title of the saved credentials */
    title: string,
  }

  export type inputCredentialsSaved$Input = {
    /**
     * Applies if a user chooses some previously saved payment credentials. To use
     * their previously saved credentials, the user must have a valid temporary password
     */
    readonly _: 'inputCredentialsSaved',
    /** Identifier of the saved credentials */
    readonly saved_credentials_id?: string,
  }

  export type inputCredentialsNew$Input = {
    /** Applies if a user enters new credentials on a payment provider website */
    readonly _: 'inputCredentialsNew',
    /** JSON-encoded data with the credential identifier from the payment provider */
    readonly data?: string,
    /** True, if the credential identifier can be saved on the server side */
    readonly allow_save?: boolean,
  }

  export type inputCredentialsApplePay$Input = {
    /** Applies if a user enters new credentials using Apple Pay */
    readonly _: 'inputCredentialsApplePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type inputCredentialsGooglePay$Input = {
    /** Applies if a user enters new credentials using Google Pay */
    readonly _: 'inputCredentialsGooglePay',
    /** JSON-encoded data with the credential identifier */
    readonly data?: string,
  }

  export type paymentsProviderStripe = {
    /** Stripe payment provider */
    _: 'paymentsProviderStripe',
    /** Stripe API publishable key */
    publishable_key: string,
    /** True, if the user country must be provided */
    need_country: boolean,
    /** True, if the user ZIP/postal code must be provided */
    need_postal_code: boolean,
    /** True, if the cardholder name must be provided */
    need_cardholder_name: boolean,
  }

  export type paymentFormTheme$Input = {
    /** Theme colors for a payment form */
    readonly _: 'paymentFormTheme',
    /** A color of the payment form background in the RGB24 format */
    readonly background_color?: number,
    /** A color of text in the RGB24 format */
    readonly text_color?: number,
    /** A color of hints in the RGB24 format */
    readonly hint_color?: number,
    /** A color of links in the RGB24 format */
    readonly link_color?: number,
    /** A color of the buttons in the RGB24 format */
    readonly button_color?: number,
    /** A color of text on the buttons in the RGB24 format */
    readonly button_text_color?: number,
  }

  export type paymentForm = {
    /** Contains information about an invoice payment form */
    _: 'paymentForm',
    /** The payment form identifier */
    id: number | string,
    /** Full information of the invoice */
    invoice: invoice,
    /** Payment form URL */
    url: string,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** User identifier of the payment provider bot */
    payments_provider_user_id: number,
    /**
     * Information about the payment provider, if available, to support it natively
     * without the need for opening the URL; may be null
     */
    payments_provider?: paymentsProviderStripe,
    /** Saved server-side order information; may be null */
    saved_order_info?: orderInfo,
    /** Information about saved card credentials; may be null */
    saved_credentials?: savedCredentials,
    /** True, if the user can choose to save credentials */
    can_save_credentials: boolean,
    /**
     * True, if the user will be able to save credentials protected by a password they
     * set up
     */
    need_password: boolean,
  }

  export type validatedOrderInfo = {
    /**
     * Contains a temporary identifier of validated order information, which is stored
     * for one hour. Also contains the available shipping options
     */
    _: 'validatedOrderInfo',
    /** Temporary identifier of the order information */
    order_info_id: string,
    /** Available shipping options */
    shipping_options: Array<shippingOption>,
  }

  export type paymentResult = {
    /** Contains the result of a payment request */
    _: 'paymentResult',
    /**
     * True, if the payment request was successful; otherwise the verification_url
     * will be non-empty
     */
    success: boolean,
    /** URL for additional payment credentials verification */
    verification_url: string,
  }

  export type paymentReceipt = {
    /** Contains information about a successful payment */
    _: 'paymentReceipt',
    /** Product title */
    title: string,
    /** Product description */
    description: string,
    /** Product photo; may be null */
    photo?: photo,
    /** Point in time (Unix timestamp) when the payment was made */
    date: number,
    /** User identifier of the seller bot */
    seller_bot_user_id: number,
    /** User identifier of the payment provider bot */
    payments_provider_user_id: number,
    /** Information about the invoice */
    invoice: invoice,
    /** Order information; may be null */
    order_info?: orderInfo,
    /** Chosen shipping option; may be null */
    shipping_option?: shippingOption,
    /** Title of the saved credentials chosen by the buyer */
    credentials_title: string,
    /** The amount of tip chosen by the buyer in the smallest units of the currency */
    tip_amount: number,
  }

  export type datedFile = {
    /** File with the date it was uploaded */
    _: 'datedFile',
    /** The file */
    file: file,
    /** Point in time (Unix timestamp) when the file was uploaded */
    date: number,
  }

  export type passportElementTypePersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePersonalDetails$Input = {
    /** A Telegram Passport element containing the user's personal details */
    readonly _: 'passportElementTypePersonalDetails',
  }

  export type passportElementTypePassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementTypePassport',
  }

  export type passportElementTypePassport$Input = {
    /** A Telegram Passport element containing the user's passport */
    readonly _: 'passportElementTypePassport',
  }

  export type passportElementTypeDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeDriverLicense$Input = {
    /** A Telegram Passport element containing the user's driver license */
    readonly _: 'passportElementTypeDriverLicense',
  }

  export type passportElementTypeIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeIdentityCard$Input = {
    /** A Telegram Passport element containing the user's identity card */
    readonly _: 'passportElementTypeIdentityCard',
  }

  export type passportElementTypeInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeInternalPassport$Input = {
    /** A Telegram Passport element containing the user's internal passport */
    readonly _: 'passportElementTypeInternalPassport',
  }

  export type passportElementTypeAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementTypeAddress',
  }

  export type passportElementTypeAddress$Input = {
    /** A Telegram Passport element containing the user's address */
    readonly _: 'passportElementTypeAddress',
  }

  export type passportElementTypeUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeUtilityBill$Input = {
    /** A Telegram Passport element containing the user's utility bill */
    readonly _: 'passportElementTypeUtilityBill',
  }

  export type passportElementTypeBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeBankStatement$Input = {
    /** A Telegram Passport element containing the user's bank statement */
    readonly _: 'passportElementTypeBankStatement',
  }

  export type passportElementTypeRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypeRentalAgreement$Input = {
    /** A Telegram Passport element containing the user's rental agreement */
    readonly _: 'passportElementTypeRentalAgreement',
  }

  export type passportElementTypePassportRegistration = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypePassportRegistration$Input = {
    /** A Telegram Passport element containing the registration page of the user's passport */
    readonly _: 'passportElementTypePassportRegistration',
  }

  export type passportElementTypeTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypeTemporaryRegistration$Input = {
    /** A Telegram Passport element containing the user's temporary registration */
    readonly _: 'passportElementTypeTemporaryRegistration',
  }

  export type passportElementTypePhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypePhoneNumber$Input = {
    /** A Telegram Passport element containing the user's phone number */
    readonly _: 'passportElementTypePhoneNumber',
  }

  export type passportElementTypeEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementTypeEmailAddress',
  }

  export type passportElementTypeEmailAddress$Input = {
    /** A Telegram Passport element containing the user's email address */
    readonly _: 'passportElementTypeEmailAddress',
  }

  export type date = {
    /** Represents a date according to the Gregorian calendar */
    _: 'date',
    /** Day of the month; 1-31 */
    day: number,
    /** Month; 1-12 */
    month: number,
    /** Year; 1-9999 */
    year: number,
  }

  export type date$Input = {
    /** Represents a date according to the Gregorian calendar */
    readonly _: 'date',
    /** Day of the month; 1-31 */
    readonly day?: number,
    /** Month; 1-12 */
    readonly month?: number,
    /** Year; 1-9999 */
    readonly year?: number,
  }

  export type personalDetails = {
    /** Contains the user's personal details */
    _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    first_name: string,
    /** Middle name of the user written in English; 0-255 characters */
    middle_name: string,
    /** Last name of the user written in English; 1-255 characters */
    last_name: string,
    /** Native first name of the user; 1-255 characters */
    native_first_name: string,
    /** Native middle name of the user; 0-255 characters */
    native_middle_name: string,
    /** Native last name of the user; 1-255 characters */
    native_last_name: string,
    /** Birthdate of the user */
    birthdate: date,
    /** Gender of the user, "male" or "female" */
    gender: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    country_code: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    residence_country_code: string,
  }

  export type personalDetails$Input = {
    /** Contains the user's personal details */
    readonly _: 'personalDetails',
    /** First name of the user written in English; 1-255 characters */
    readonly first_name?: string,
    /** Middle name of the user written in English; 0-255 characters */
    readonly middle_name?: string,
    /** Last name of the user written in English; 1-255 characters */
    readonly last_name?: string,
    /** Native first name of the user; 1-255 characters */
    readonly native_first_name?: string,
    /** Native middle name of the user; 0-255 characters */
    readonly native_middle_name?: string,
    /** Native last name of the user; 1-255 characters */
    readonly native_last_name?: string,
    /** Birthdate of the user */
    readonly birthdate?: date$Input,
    /** Gender of the user, "male" or "female" */
    readonly gender?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's country */
    readonly country_code?: string,
    /** A two-letter ISO 3166-1 alpha-2 country code of the user's residence country */
    readonly residence_country_code?: string,
  }

  export type identityDocument = {
    /** An identity document */
    _: 'identityDocument',
    /** Document number; 1-24 characters */
    number: string,
    /** Document expiry date; may be null if not applicable */
    expiry_date?: date,
    /** Front side of the document */
    front_side: datedFile,
    /**
     * Reverse side of the document; only for driver license and identity card; may
     * be null
     */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputIdentityDocument$Input = {
    /** An identity document to be saved to Telegram Passport */
    readonly _: 'inputIdentityDocument',
    /** Document number; 1-24 characters */
    readonly number?: string,
    /** Document expiry date; pass null if not applicable */
    readonly expiry_date?: date$Input,
    /** Front side of the document */
    readonly front_side?: InputFile$Input,
    /**
     * Reverse side of the document; only for driver license and identity card; pass
     * null otherwise
     */
    readonly reverse_side?: InputFile$Input,
    /** Selfie with the document; pass null if unavailable */
    readonly selfie?: InputFile$Input,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type personalDocument = {
    /** A personal document, containing some information about a user */
    _: 'personalDocument',
    /** List of files containing the pages of the document */
    files: Array<datedFile>,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
  }

  export type inputPersonalDocument$Input = {
    /** A personal document to be saved to Telegram Passport */
    readonly _: 'inputPersonalDocument',
    /** List of files containing the pages of the document */
    readonly files?: ReadonlyArray<InputFile$Input>,
    /** List of files containing a certified English translation of the document */
    readonly translation?: ReadonlyArray<InputFile$Input>,
  }

  export type passportElementPersonalDetails = {
    /** A Telegram Passport element containing the user's personal details */
    _: 'passportElementPersonalDetails',
    /** Personal details of the user */
    personal_details: personalDetails,
  }

  export type passportElementPassport = {
    /** A Telegram Passport element containing the user's passport */
    _: 'passportElementPassport',
    /** Passport */
    passport: identityDocument,
  }

  export type passportElementDriverLicense = {
    /** A Telegram Passport element containing the user's driver license */
    _: 'passportElementDriverLicense',
    /** Driver license */
    driver_license: identityDocument,
  }

  export type passportElementIdentityCard = {
    /** A Telegram Passport element containing the user's identity card */
    _: 'passportElementIdentityCard',
    /** Identity card */
    identity_card: identityDocument,
  }

  export type passportElementInternalPassport = {
    /** A Telegram Passport element containing the user's internal passport */
    _: 'passportElementInternalPassport',
    /** Internal passport */
    internal_passport: identityDocument,
  }

  export type passportElementAddress = {
    /** A Telegram Passport element containing the user's address */
    _: 'passportElementAddress',
    /** Address */
    address: address,
  }

  export type passportElementUtilityBill = {
    /** A Telegram Passport element containing the user's utility bill */
    _: 'passportElementUtilityBill',
    /** Utility bill */
    utility_bill: personalDocument,
  }

  export type passportElementBankStatement = {
    /** A Telegram Passport element containing the user's bank statement */
    _: 'passportElementBankStatement',
    /** Bank statement */
    bank_statement: personalDocument,
  }

  export type passportElementRentalAgreement = {
    /** A Telegram Passport element containing the user's rental agreement */
    _: 'passportElementRentalAgreement',
    /** Rental agreement */
    rental_agreement: personalDocument,
  }

  export type passportElementPassportRegistration = {
    /** A Telegram Passport element containing the user's passport registration pages */
    _: 'passportElementPassportRegistration',
    /** Passport registration pages */
    passport_registration: personalDocument,
  }

  export type passportElementTemporaryRegistration = {
    /** A Telegram Passport element containing the user's temporary registration */
    _: 'passportElementTemporaryRegistration',
    /** Temporary registration */
    temporary_registration: personalDocument,
  }

  export type passportElementPhoneNumber = {
    /** A Telegram Passport element containing the user's phone number */
    _: 'passportElementPhoneNumber',
    /** Phone number */
    phone_number: string,
  }

  export type passportElementEmailAddress = {
    /** A Telegram Passport element containing the user's email address */
    _: 'passportElementEmailAddress',
    /** Email address */
    email_address: string,
  }

  export type inputPassportElementPersonalDetails$Input = {
    /** A Telegram Passport element to be saved containing the user's personal details */
    readonly _: 'inputPassportElementPersonalDetails',
    /** Personal details of the user */
    readonly personal_details?: personalDetails$Input,
  }

  export type inputPassportElementPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's passport */
    readonly _: 'inputPassportElementPassport',
    /** The passport to be saved */
    readonly passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementDriverLicense$Input = {
    /** A Telegram Passport element to be saved containing the user's driver license */
    readonly _: 'inputPassportElementDriverLicense',
    /** The driver license to be saved */
    readonly driver_license?: inputIdentityDocument$Input,
  }

  export type inputPassportElementIdentityCard$Input = {
    /** A Telegram Passport element to be saved containing the user's identity card */
    readonly _: 'inputPassportElementIdentityCard',
    /** The identity card to be saved */
    readonly identity_card?: inputIdentityDocument$Input,
  }

  export type inputPassportElementInternalPassport$Input = {
    /** A Telegram Passport element to be saved containing the user's internal passport */
    readonly _: 'inputPassportElementInternalPassport',
    /** The internal passport to be saved */
    readonly internal_passport?: inputIdentityDocument$Input,
  }

  export type inputPassportElementAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's address */
    readonly _: 'inputPassportElementAddress',
    /** The address to be saved */
    readonly address?: address$Input,
  }

  export type inputPassportElementUtilityBill$Input = {
    /** A Telegram Passport element to be saved containing the user's utility bill */
    readonly _: 'inputPassportElementUtilityBill',
    /** The utility bill to be saved */
    readonly utility_bill?: inputPersonalDocument$Input,
  }

  export type inputPassportElementBankStatement$Input = {
    /** A Telegram Passport element to be saved containing the user's bank statement */
    readonly _: 'inputPassportElementBankStatement',
    /** The bank statement to be saved */
    readonly bank_statement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementRentalAgreement$Input = {
    /** A Telegram Passport element to be saved containing the user's rental agreement */
    readonly _: 'inputPassportElementRentalAgreement',
    /** The rental agreement to be saved */
    readonly rental_agreement?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPassportRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's passport registration */
    readonly _: 'inputPassportElementPassportRegistration',
    /** The passport registration page to be saved */
    readonly passport_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementTemporaryRegistration$Input = {
    /** A Telegram Passport element to be saved containing the user's temporary registration */
    readonly _: 'inputPassportElementTemporaryRegistration',
    /** The temporary registration document to be saved */
    readonly temporary_registration?: inputPersonalDocument$Input,
  }

  export type inputPassportElementPhoneNumber$Input = {
    /** A Telegram Passport element to be saved containing the user's phone number */
    readonly _: 'inputPassportElementPhoneNumber',
    /** The phone number to be saved */
    readonly phone_number?: string,
  }

  export type inputPassportElementEmailAddress$Input = {
    /** A Telegram Passport element to be saved containing the user's email address */
    readonly _: 'inputPassportElementEmailAddress',
    /** The email address to be saved */
    readonly email_address?: string,
  }

  export type passportElements = {
    /** Contains information about saved Telegram Passport elements */
    _: 'passportElements',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
  }

  export type passportElementErrorSourceUnspecified = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    _: 'passportElementErrorSourceUnspecified',
  }

  export type passportElementErrorSourceDataField = {
    /**
     * One of the data fields contains an error. The error will be considered resolved
     * when the value of the field changes
     */
    _: 'passportElementErrorSourceDataField',
    /** Field name */
    field_name: string,
  }

  export type passportElementErrorSourceFrontSide = {
    /**
     * The front side of the document contains an error. The error will be considered
     * resolved when the file with the front side changes
     */
    _: 'passportElementErrorSourceFrontSide',
  }

  export type passportElementErrorSourceReverseSide = {
    /**
     * The reverse side of the document contains an error. The error will be considered
     * resolved when the file with the reverse side changes
     */
    _: 'passportElementErrorSourceReverseSide',
  }

  export type passportElementErrorSourceSelfie = {
    /**
     * The selfie with the document contains an error. The error will be considered
     * resolved when the file with the selfie changes
     */
    _: 'passportElementErrorSourceSelfie',
  }

  export type passportElementErrorSourceTranslationFile = {
    /**
     * One of files with the translation of the document contains an error. The error
     * will be considered resolved when the file changes
     */
    _: 'passportElementErrorSourceTranslationFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceTranslationFiles = {
    /**
     * The translation of the document contains an error. The error will be considered
     * resolved when the list of translation files changes
     */
    _: 'passportElementErrorSourceTranslationFiles',
  }

  export type passportElementErrorSourceFile = {
    /**
     * The file contains an error. The error will be considered resolved when the file
     * changes
     */
    _: 'passportElementErrorSourceFile',
    /** Index of a file with the error */
    file_index: number,
  }

  export type passportElementErrorSourceFiles = {
    /**
     * The list of attached files contains an error. The error will be considered resolved
     * when the list of files changes
     */
    _: 'passportElementErrorSourceFiles',
  }

  export type passportElementError = {
    /** Contains the description of an error in a Telegram Passport element */
    _: 'passportElementError',
    /** Type of the Telegram Passport element which has the error */
    type: PassportElementType,
    /** Error message */
    message: string,
    /** Error source */
    source: PassportElementErrorSource,
  }

  export type passportSuitableElement = {
    /**
     * Contains information about a Telegram Passport element that was requested by
     * a service
     */
    _: 'passportSuitableElement',
    /** Type of the element */
    type: PassportElementType,
    /** True, if a selfie is required with the identity document */
    is_selfie_required: boolean,
    /** True, if a certified English translation is required with the document */
    is_translation_required: boolean,
    /**
     * True, if personal details must include the user's name in the language of their
     * country of residence
     */
    is_native_name_required: boolean,
  }

  export type passportRequiredElement = {
    /**
     * Contains a description of the required Telegram Passport element that was requested
     * by a service
     */
    _: 'passportRequiredElement',
    /** List of Telegram Passport elements any of which is enough to provide */
    suitable_elements: Array<passportSuitableElement>,
  }

  export type passportAuthorizationForm = {
    /** Contains information about a Telegram Passport authorization form that was requested */
    _: 'passportAuthorizationForm',
    /** Unique identifier of the authorization form */
    id: number,
    /** Telegram Passport elements that must be provided to complete the form */
    required_elements: Array<passportRequiredElement>,
    /** URL for the privacy policy of the service; may be empty */
    privacy_policy_url: string,
  }

  export type passportElementsWithErrors = {
    /** Contains information about a Telegram Passport elements and corresponding errors */
    _: 'passportElementsWithErrors',
    /** Telegram Passport elements */
    elements: Array<PassportElement>,
    /** Errors in the elements that are already available */
    errors: Array<passportElementError>,
  }

  export type encryptedCredentials = {
    /** Contains encrypted Telegram Passport data credentials */
    _: 'encryptedCredentials',
    /** The encrypted credentials */
    data: string,
    /** The decrypted data hash */
    hash: string,
    /** Secret for data decryption, encrypted with the service's public key */
    secret: string,
  }

  export type encryptedPassportElement = {
    /**
     * Contains information about an encrypted Telegram Passport element; for bots
     * only
     */
    _: 'encryptedPassportElement',
    /** Type of Telegram Passport element */
    type: PassportElementType,
    /** Encrypted JSON-encoded data about the user */
    data: string,
    /** The front side of an identity document */
    front_side: datedFile,
    /** The reverse side of an identity document; may be null */
    reverse_side?: datedFile,
    /** Selfie with the document; may be null */
    selfie?: datedFile,
    /** List of files containing a certified English translation of the document */
    translation: Array<datedFile>,
    /** List of attached files */
    files: Array<datedFile>,
    /** Unencrypted data, phone number or email address */
    value: string,
    /** Hash of the entire element */
    hash: string,
  }

  export type inputPassportElementErrorSourceUnspecified$Input = {
    /**
     * The element contains an error in an unspecified place. The error will be considered
     * resolved when new data is added
     */
    readonly _: 'inputPassportElementErrorSourceUnspecified',
    /** Current hash of the entire element */
    readonly element_hash?: string,
  }

  export type inputPassportElementErrorSourceDataField$Input = {
    /**
     * A data field contains an error. The error is considered resolved when the field's
     * value changes
     */
    readonly _: 'inputPassportElementErrorSourceDataField',
    /** Field name */
    readonly field_name?: string,
    /** Current data hash */
    readonly data_hash?: string,
  }

  export type inputPassportElementErrorSourceFrontSide$Input = {
    /**
     * The front side of the document contains an error. The error is considered resolved
     * when the file with the front side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceFrontSide',
    /** Current hash of the file containing the front side */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceReverseSide$Input = {
    /**
     * The reverse side of the document contains an error. The error is considered
     * resolved when the file with the reverse side of the document changes
     */
    readonly _: 'inputPassportElementErrorSourceReverseSide',
    /** Current hash of the file containing the reverse side */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceSelfie$Input = {
    /**
     * The selfie contains an error. The error is considered resolved when the file
     * with the selfie changes
     */
    readonly _: 'inputPassportElementErrorSourceSelfie',
    /** Current hash of the file containing the selfie */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceTranslationFile$Input = {
    /**
     * One of the files containing the translation of the document contains an error.
     * The error is considered resolved when the file with the translation changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFile',
    /** Current hash of the file containing the translation */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceTranslationFiles$Input = {
    /**
     * The translation of the document contains an error. The error is considered resolved
     * when the list of files changes
     */
    readonly _: 'inputPassportElementErrorSourceTranslationFiles',
    /** Current hashes of all files with the translation */
    readonly file_hashes?: ReadonlyArray<string>,
  }

  export type inputPassportElementErrorSourceFile$Input = {
    /** The file contains an error. The error is considered resolved when the file changes */
    readonly _: 'inputPassportElementErrorSourceFile',
    /** Current hash of the file which has the error */
    readonly file_hash?: string,
  }

  export type inputPassportElementErrorSourceFiles$Input = {
    /**
     * The list of attached files contains an error. The error is considered resolved
     * when the file list changes
     */
    readonly _: 'inputPassportElementErrorSourceFiles',
    /** Current hashes of all attached files */
    readonly file_hashes?: ReadonlyArray<string>,
  }

  export type inputPassportElementError$Input = {
    /**
     * Contains the description of an error in a Telegram Passport element; for bots
     * only
     */
    readonly _: 'inputPassportElementError',
    /** Type of Telegram Passport element that has the error */
    readonly type?: PassportElementType$Input,
    /** Error message */
    readonly message?: string,
    /** Error source */
    readonly source?: InputPassportElementErrorSource$Input,
  }

  export type messageText = {
    /** A text message */
    _: 'messageText',
    /** Text of the message */
    text: formattedText,
    /** A preview of the web page that's mentioned in the text; may be null */
    web_page?: webPage,
  }

  export type messageAnimation = {
    /** An animation message (GIF-style). */
    _: 'messageAnimation',
    /** The animation description */
    animation: animation,
    /** Animation caption */
    caption: formattedText,
    /**
     * True, if the animation thumbnail must be blurred and the animation must be shown
     * only while tapped
     */
    is_secret: boolean,
  }

  export type messageAudio = {
    /** An audio message */
    _: 'messageAudio',
    /** The audio description */
    audio: audio,
    /** Audio caption */
    caption: formattedText,
  }

  export type messageDocument = {
    /** A document message (general file) */
    _: 'messageDocument',
    /** The document description */
    document: document,
    /** Document caption */
    caption: formattedText,
  }

  export type messagePhoto = {
    /** A photo message */
    _: 'messagePhoto',
    /** The photo description */
    photo: photo,
    /** Photo caption */
    caption: formattedText,
    /** True, if the photo must be blurred and must be shown only while tapped */
    is_secret: boolean,
  }

  export type messageExpiredPhoto = {
    /** An expired photo message (self-destructed after TTL has elapsed) */
    _: 'messageExpiredPhoto',
  }

  export type messageSticker = {
    /** A sticker message */
    _: 'messageSticker',
    /** The sticker description */
    sticker: sticker,
  }

  export type messageVideo = {
    /** A video message */
    _: 'messageVideo',
    /** The video description */
    video: video,
    /** Video caption */
    caption: formattedText,
    /**
     * True, if the video thumbnail must be blurred and the video must be shown only
     * while tapped
     */
    is_secret: boolean,
  }

  export type messageExpiredVideo = {
    /** An expired video message (self-destructed after TTL has elapsed) */
    _: 'messageExpiredVideo',
  }

  export type messageVideoNote = {
    /** A video note message */
    _: 'messageVideoNote',
    /** The video note description */
    video_note: videoNote,
    /** True, if at least one of the recipients has viewed the video note */
    is_viewed: boolean,
    /**
     * True, if the video note thumbnail must be blurred and the video note must be
     * shown only while tapped
     */
    is_secret: boolean,
  }

  export type messageVoiceNote = {
    /** A voice note message */
    _: 'messageVoiceNote',
    /** The voice note description */
    voice_note: voiceNote,
    /** Voice note caption */
    caption: formattedText,
    /** True, if at least one of the recipients has listened to the voice note */
    is_listened: boolean,
  }

  export type messageLocation = {
    /** A message with a location */
    _: 'messageLocation',
    /** The location description */
    location: location,
    /**
     * Time relative to the message send date, for which the location can be updated,
     * in seconds
     */
    live_period: number,
    /**
     * Left time for which the location can be updated, in seconds. updateMessageContent
     * is not sent when this field changes
     */
    expires_in: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * If 0 the direction is unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). 0 if the notification is disabled. Available only
     * for the message sender
     */
    proximity_alert_radius: number,
  }

  export type messageVenue = {
    /** A message with information about a venue */
    _: 'messageVenue',
    /** The venue description */
    venue: venue,
  }

  export type messageContact = {
    /** A message with a user contact */
    _: 'messageContact',
    /** The contact description */
    contact: contact,
  }

  export type messageAnimatedEmoji = {
    /** A message with an animated emoji */
    _: 'messageAnimatedEmoji',
    /** The animated emoji */
    animated_emoji: animatedEmoji,
    /** The corresponding emoji */
    emoji: string,
  }

  export type messageDice = {
    /** A dice message. The dice value is randomly generated by the server */
    _: 'messageDice',
    /**
     * The animated stickers with the initial dice animation; may be null if unknown.
     * updateMessageContent will be sent when the sticker became known
     */
    initial_state?: DiceStickers,
    /**
     * The animated stickers with the final dice animation; may be null if unknown.
     * updateMessageContent will be sent when the sticker became known
     */
    final_state?: DiceStickers,
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** The dice value. If the value is 0, the dice don't have final state yet */
    value: number,
    /**
     * Number of frame after which a success animation like a shower of confetti needs
     * to be shown on updateMessageSendSucceeded
     */
    success_animation_frame_number: number,
  }

  export type messageGame = {
    /** A message with a game */
    _: 'messageGame',
    /** The game description */
    game: game,
  }

  export type messagePoll = {
    /** A message with a poll */
    _: 'messagePoll',
    /** The poll description */
    poll: poll,
  }

  export type messageInvoice = {
    /** A message with an invoice from a bot */
    _: 'messageInvoice',
    /** Product title */
    title: string,
    /** Product description */
    description: string,
    /** Product photo; may be null */
    photo?: photo,
    /** Currency for the product price */
    currency: string,
    /** Product total price in the smallest units of the currency */
    total_amount: number,
    /** Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter} */
    start_parameter: string,
    /** True, if the invoice is a test invoice */
    is_test: boolean,
    /** True, if the shipping address must be specified */
    need_shipping_address: boolean,
    /** The identifier of the message with the receipt, after the product has been purchased */
    receipt_message_id: number,
  }

  export type messageCall = {
    /** A message with information about an ended call */
    _: 'messageCall',
    /** True, if the call was a video call */
    is_video: boolean,
    /** Reason why the call was discarded */
    discard_reason: CallDiscardReason,
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageVideoChatScheduled = {
    /** A new video chat was scheduled */
    _: 'messageVideoChatScheduled',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator
     */
    start_date: number,
  }

  export type messageVideoChatStarted = {
    /** A newly created video chat */
    _: 'messageVideoChatStarted',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type messageVideoChatEnded = {
    /** A message with information about an ended video chat */
    _: 'messageVideoChatEnded',
    /** Call duration, in seconds */
    duration: number,
  }

  export type messageInviteVideoChatParticipants = {
    /** A message with information about an invite to a video chat */
    _: 'messageInviteVideoChatParticipants',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
    /** Invited user identifiers */
    user_ids: Array<number>,
  }

  export type messageBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'messageBasicGroupChatCreate',
    /** Title of the basic group */
    title: string,
    /** User identifiers of members in the basic group */
    member_user_ids: Array<number>,
  }

  export type messageSupergroupChatCreate = {
    /** A newly created supergroup or channel */
    _: 'messageSupergroupChatCreate',
    /** Title of the supergroup or channel */
    title: string,
  }

  export type messageChatChangeTitle = {
    /** An updated chat title */
    _: 'messageChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type messageChatChangePhoto = {
    /** An updated chat photo */
    _: 'messageChatChangePhoto',
    /** New chat photo */
    photo: chatPhoto,
  }

  export type messageChatDeletePhoto = {
    /** A deleted chat photo */
    _: 'messageChatDeletePhoto',
  }

  export type messageChatAddMembers = {
    /** New chat members were added */
    _: 'messageChatAddMembers',
    /** User identifiers of the new members */
    member_user_ids: Array<number>,
  }

  export type messageChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'messageChatJoinByLink',
  }

  export type messageChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'messageChatJoinByRequest',
  }

  export type messageChatDeleteMember = {
    /** A chat member was deleted */
    _: 'messageChatDeleteMember',
    /** User identifier of the deleted chat member */
    user_id: number,
  }

  export type messageChatUpgradeTo = {
    /** A basic group was upgraded to a supergroup and was deactivated as the result */
    _: 'messageChatUpgradeTo',
    /** Identifier of the supergroup to which the basic group was upgraded */
    supergroup_id: number,
  }

  export type messageChatUpgradeFrom = {
    /** A supergroup has been created from a basic group */
    _: 'messageChatUpgradeFrom',
    /** Title of the newly created supergroup */
    title: string,
    /** The identifier of the original basic group */
    basic_group_id: number,
  }

  export type messagePinMessage = {
    /** A message has been pinned */
    _: 'messagePinMessage',
    /**
     * Identifier of the pinned message, can be an identifier of a deleted message
     * or 0
     */
    message_id: number,
  }

  export type messageScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'messageScreenshotTaken',
  }

  export type messageChatSetTheme = {
    /** A theme in the chat has been changed */
    _: 'messageChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was
     * reset to the default one
     */
    theme_name: string,
  }

  export type messageChatSetTtl = {
    /** The TTL (Time To Live) setting for messages in the chat has been changed */
    _: 'messageChatSetTtl',
    /** New message TTL */
    ttl: number,
  }

  export type messageCustomServiceAction = {
    /** A non-standard action has happened in the chat */
    _: 'messageCustomServiceAction',
    /** Message text to be shown in the chat */
    text: string,
  }

  export type messageGameScore = {
    /** A new high score was achieved in a game */
    _: 'messageGameScore',
    /** Identifier of the message with the game, can be an identifier of a deleted message */
    game_message_id: number,
    /**
     * Identifier of the game; may be different from the games presented in the message
     * with the game
     */
    game_id: number | string,
    /** New score */
    score: number,
  }

  export type messagePaymentSuccessful = {
    /** A payment has been completed */
    _: 'messagePaymentSuccessful',
    /** Identifier of the chat, containing the corresponding invoice message; 0 if unknown */
    invoice_chat_id: number,
    /**
     * Identifier of the message with the corresponding invoice; can be an identifier
     * of a deleted message
     */
    invoice_message_id: number,
    /** Currency for the price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
  }

  export type messagePaymentSuccessfulBot = {
    /** A payment has been completed; for bots only */
    _: 'messagePaymentSuccessfulBot',
    /** Currency for price of the product */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload */
    invoice_payload: string,
    /** Identifier of the shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
    /** Telegram payment identifier */
    telegram_payment_charge_id: string,
    /** Provider payment identifier */
    provider_payment_charge_id: string,
  }

  export type messageContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'messageContactRegistered',
  }

  export type messageWebsiteConnected = {
    /**
     * The current user has connected a website by logging in using Telegram Login
     * Widget on it
     */
    _: 'messageWebsiteConnected',
    /** Domain name of the connected website */
    domain_name: string,
  }

  export type messagePassportDataSent = {
    /** Telegram Passport data has been sent */
    _: 'messagePassportDataSent',
    /** List of Telegram Passport element types sent */
    types: Array<PassportElementType>,
  }

  export type messagePassportDataReceived = {
    /** Telegram Passport data has been received; for bots only */
    _: 'messagePassportDataReceived',
    /** List of received Telegram Passport elements */
    elements: Array<encryptedPassportElement>,
    /** Encrypted data credentials */
    credentials: encryptedCredentials,
  }

  export type messageProximityAlertTriggered = {
    /** A user in the chat came within proximity alert range */
    _: 'messageProximityAlertTriggered',
    /** The identifier of a user or chat that triggered the proximity alert */
    traveler_id: MessageSender,
    /** The identifier of a user or chat that subscribed for the proximity alert */
    watcher_id: MessageSender,
    /** The distance between the users */
    distance: number,
  }

  export type messageUnsupported = {
    /** Message content that is not supported in the current TDLib version */
    _: 'messageUnsupported',
  }

  export type textEntityTypeMention = {
    /** A mention of a user by their username */
    _: 'textEntityTypeMention',
  }

  export type textEntityTypeMention$Input = {
    /** A mention of a user by their username */
    readonly _: 'textEntityTypeMention',
  }

  export type textEntityTypeHashtag = {
    /** A hashtag text, beginning with "#" */
    _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeHashtag$Input = {
    /** A hashtag text, beginning with "#" */
    readonly _: 'textEntityTypeHashtag',
  }

  export type textEntityTypeCashtag = {
    /**
     * A cashtag text, beginning with "$" and consisting of capital English letters
     * (e.g., "$USD")
     */
    _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeCashtag$Input = {
    /**
     * A cashtag text, beginning with "$" and consisting of capital English letters
     * (e.g., "$USD")
     */
    readonly _: 'textEntityTypeCashtag',
  }

  export type textEntityTypeBotCommand = {
    /** A bot command, beginning with "/" */
    _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeBotCommand$Input = {
    /** A bot command, beginning with "/" */
    readonly _: 'textEntityTypeBotCommand',
  }

  export type textEntityTypeUrl = {
    /** An HTTP URL */
    _: 'textEntityTypeUrl',
  }

  export type textEntityTypeUrl$Input = {
    /** An HTTP URL */
    readonly _: 'textEntityTypeUrl',
  }

  export type textEntityTypeEmailAddress = {
    /** An email address */
    _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypeEmailAddress$Input = {
    /** An email address */
    readonly _: 'textEntityTypeEmailAddress',
  }

  export type textEntityTypePhoneNumber = {
    /** A phone number */
    _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypePhoneNumber$Input = {
    /** A phone number */
    readonly _: 'textEntityTypePhoneNumber',
  }

  export type textEntityTypeBankCardNumber = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBankCardNumber$Input = {
    /**
     * A bank card number. The getBankCardInfo method can be used to get information
     * about the bank card
     */
    readonly _: 'textEntityTypeBankCardNumber',
  }

  export type textEntityTypeBold = {
    /** A bold text */
    _: 'textEntityTypeBold',
  }

  export type textEntityTypeBold$Input = {
    /** A bold text */
    readonly _: 'textEntityTypeBold',
  }

  export type textEntityTypeItalic = {
    /** An italic text */
    _: 'textEntityTypeItalic',
  }

  export type textEntityTypeItalic$Input = {
    /** An italic text */
    readonly _: 'textEntityTypeItalic',
  }

  export type textEntityTypeUnderline = {
    /** An underlined text */
    _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeUnderline$Input = {
    /** An underlined text */
    readonly _: 'textEntityTypeUnderline',
  }

  export type textEntityTypeStrikethrough = {
    /** A strikethrough text */
    _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeStrikethrough$Input = {
    /** A strikethrough text */
    readonly _: 'textEntityTypeStrikethrough',
  }

  export type textEntityTypeCode = {
    /** Text that must be formatted as if inside a code HTML tag */
    _: 'textEntityTypeCode',
  }

  export type textEntityTypeCode$Input = {
    /** Text that must be formatted as if inside a code HTML tag */
    readonly _: 'textEntityTypeCode',
  }

  export type textEntityTypePre = {
    /** Text that must be formatted as if inside a pre HTML tag */
    _: 'textEntityTypePre',
  }

  export type textEntityTypePre$Input = {
    /** Text that must be formatted as if inside a pre HTML tag */
    readonly _: 'textEntityTypePre',
  }

  export type textEntityTypePreCode = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    language: string,
  }

  export type textEntityTypePreCode$Input = {
    /** Text that must be formatted as if inside pre, and code HTML tags */
    readonly _: 'textEntityTypePreCode',
    /** Programming language of the code; as defined by the sender */
    readonly language?: string,
  }

  export type textEntityTypeTextUrl = {
    /** A text description shown instead of a raw URL */
    _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    url: string,
  }

  export type textEntityTypeTextUrl$Input = {
    /** A text description shown instead of a raw URL */
    readonly _: 'textEntityTypeTextUrl',
    /** HTTP or tg:// URL to be opened when the link is clicked */
    readonly url?: string,
  }

  export type textEntityTypeMentionName = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    user_id: number,
  }

  export type textEntityTypeMentionName$Input = {
    /**
     * A text shows instead of a raw mention of the user (e.g., when the user has no
     * username)
     */
    readonly _: 'textEntityTypeMentionName',
    /** Identifier of the mentioned user */
    readonly user_id?: number,
  }

  export type textEntityTypeMediaTimestamp = {
    /** A media timestamp */
    _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note playing must start,
     * in seconds. The media can be in the content or the web page preview of the current
     * message, or in the same places in the replied message
     */
    media_timestamp: number,
  }

  export type textEntityTypeMediaTimestamp$Input = {
    /** A media timestamp */
    readonly _: 'textEntityTypeMediaTimestamp',
    /**
     * Timestamp from which a video/audio/video note/voice note playing must start,
     * in seconds. The media can be in the content or the web page preview of the current
     * message, or in the same places in the replied message
     */
    readonly media_timestamp?: number,
  }

  export type inputThumbnail = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    thumbnail: InputFile,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    width: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    height: number,
  }

  export type inputThumbnail$Input = {
    /**
     * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for
     * stickers, and less than 200 KB in size
     */
    readonly _: 'inputThumbnail',
    /** Thumbnail file to send. Sending thumbnails by file_id is currently not supported */
    readonly thumbnail?: InputFile$Input,
    /** Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown */
    readonly width?: number,
    /** Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown */
    readonly height?: number,
  }

  export type messageSchedulingStateSendAtDate = {
    /** The message will be sent at the specified date */
    _: 'messageSchedulingStateSendAtDate',
    /** Date the message will be sent. The date must be within 367 days in the future */
    send_date: number,
  }

  export type messageSchedulingStateSendAtDate$Input = {
    /** The message will be sent at the specified date */
    readonly _: 'messageSchedulingStateSendAtDate',
    /** Date the message will be sent. The date must be within 367 days in the future */
    readonly send_date?: number,
  }

  export type messageSchedulingStateSendWhenOnline = {
    /**
     * The message will be sent when the peer will be online. Applicable to private
     * chats only and when the exact online status of the peer is known
     */
    _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSchedulingStateSendWhenOnline$Input = {
    /**
     * The message will be sent when the peer will be online. Applicable to private
     * chats only and when the exact online status of the peer is known
     */
    readonly _: 'messageSchedulingStateSendWhenOnline',
  }

  export type messageSendOptions$Input = {
    /** Options to be used when a message is sent */
    readonly _: 'messageSendOptions',
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** Pass true if the message is sent from the background */
    readonly from_background?: boolean,
    /**
     * Message scheduling state; pass null to send message immediately. Messages sent
     * to a secret chat, live location messages and self-destructing messages can't
     * be scheduled
     */
    readonly scheduling_state?: MessageSchedulingState$Input,
  }

  export type messageCopyOptions = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages and messageInvoice can't be copied
     */
    _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local
     */
    send_copy: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    replace_caption: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    new_caption: formattedText,
  }

  export type messageCopyOptions$Input = {
    /**
     * Options to be used when a message content is copied without reference to the
     * original sender. Service messages and messageInvoice can't be copied
     */
    readonly _: 'messageCopyOptions',
    /**
     * True, if content of the message needs to be copied without reference to the
     * original sender. Always true if the message is forwarded to a secret chat or
     * is local
     */
    readonly send_copy?: boolean,
    /**
     * True, if media caption of the message copy needs to be replaced. Ignored if
     * send_copy is false
     */
    readonly replace_caption?: boolean,
    /**
     * New message caption; pass null to copy message without caption. Ignored if replace_caption
     * is false
     */
    readonly new_caption?: formattedText$Input,
  }

  export type inputMessageText = {
    /** A text message */
    _: 'inputMessageText',
    /**
     * Formatted text to be sent; 1-GetOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and
     * MentionName entities are allowed to be specified manually
     */
    text: formattedText,
    /** True, if rich web page previews for URLs in the message text must be disabled */
    disable_web_page_preview: boolean,
    /** True, if a chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageText$Input = {
    /** A text message */
    readonly _: 'inputMessageText',
    /**
     * Formatted text to be sent; 1-GetOption("message_text_length_max") characters.
     * Only Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and
     * MentionName entities are allowed to be specified manually
     */
    readonly text?: formattedText$Input,
    /** True, if rich web page previews for URLs in the message text must be disabled */
    readonly disable_web_page_preview?: boolean,
    /** True, if a chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageAnimation = {
    /** An animation message (GIF-style). */
    _: 'inputMessageAnimation',
    /** Animation file to be sent */
    animation: InputFile,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the animation, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the animation, in seconds */
    duration: number,
    /** Width of the animation; may be replaced by the server */
    width: number,
    /** Height of the animation; may be replaced by the server */
    height: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageAnimation$Input = {
    /** An animation message (GIF-style). */
    readonly _: 'inputMessageAnimation',
    /** Animation file to be sent */
    readonly animation?: InputFile$Input,
    /** Animation thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the animation, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the animation, in seconds */
    readonly duration?: number,
    /** Width of the animation; may be replaced by the server */
    readonly width?: number,
    /** Height of the animation; may be replaced by the server */
    readonly height?: number,
    /**
     * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageAudio = {
    /** An audio message */
    _: 'inputMessageAudio',
    /** Audio file to be sent */
    audio: InputFile,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    album_cover_thumbnail: inputThumbnail,
    /** Duration of the audio, in seconds; may be replaced by the server */
    duration: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    title: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    performer: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageAudio$Input = {
    /** An audio message */
    readonly _: 'inputMessageAudio',
    /** Audio file to be sent */
    readonly audio?: InputFile$Input,
    /** Thumbnail of the cover for the album; pass null to skip thumbnail uploading */
    readonly album_cover_thumbnail?: inputThumbnail$Input,
    /** Duration of the audio, in seconds; may be replaced by the server */
    readonly duration?: number,
    /** Title of the audio; 0-64 characters; may be replaced by the server */
    readonly title?: string,
    /** Performer of the audio; 0-64 characters, may be replaced by the server */
    readonly performer?: string,
    /**
     * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageDocument = {
    /** A document message (general file) */
    _: 'inputMessageDocument',
    /** Document to be sent */
    document: InputFile,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /**
     * If true, automatic file type detection will be disabled and the document will
     * be always sent as file. Always true for files sent to secret chats
     */
    disable_content_type_detection: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageDocument$Input = {
    /** A document message (general file) */
    readonly _: 'inputMessageDocument',
    /** Document to be sent */
    readonly document?: InputFile$Input,
    /** Document thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /**
     * If true, automatic file type detection will be disabled and the document will
     * be always sent as file. Always true for files sent to secret chats
     */
    readonly disable_content_type_detection?: boolean,
    /**
     * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessagePhoto = {
    /** A photo message */
    _: 'inputMessagePhoto',
    /** Photo to send */
    photo: InputFile,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the photo, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Photo width */
    width: number,
    /** Photo height */
    height: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified
     * only in private chats
     */
    ttl: number,
  }

  export type inputMessagePhoto$Input = {
    /** A photo message */
    readonly _: 'inputMessagePhoto',
    /** Photo to send */
    readonly photo?: InputFile$Input,
    /**
     * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail
     * is sent to the other party only in secret chats
     */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the photo, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Photo width */
    readonly width?: number,
    /** Photo height */
    readonly height?: number,
    /**
     * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified
     * only in private chats
     */
    readonly ttl?: number,
  }

  export type inputMessageSticker = {
    /** A sticker message */
    _: 'inputMessageSticker',
    /** Sticker to be sent */
    sticker: InputFile,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Sticker width */
    width: number,
    /** Sticker height */
    height: number,
    /** Emoji used to choose the sticker */
    emoji: string,
  }

  export type inputMessageSticker$Input = {
    /** A sticker message */
    readonly _: 'inputMessageSticker',
    /** Sticker to be sent */
    readonly sticker?: InputFile$Input,
    /** Sticker thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Sticker width */
    readonly width?: number,
    /** Sticker height */
    readonly height?: number,
    /** Emoji used to choose the sticker */
    readonly emoji?: string,
  }

  export type inputMessageVideo = {
    /** A video message */
    _: 'inputMessageVideo',
    /** Video to be sent */
    video: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** File identifiers of the stickers added to the video, if applicable */
    added_sticker_file_ids: Array<number>,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width */
    width: number,
    /** Video height */
    height: number,
    /** True, if the video is supposed to be streamed */
    supports_streaming: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
    /**
     * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified
     * only in private chats
     */
    ttl: number,
  }

  export type inputMessageVideo$Input = {
    /** A video message */
    readonly _: 'inputMessageVideo',
    /** Video to be sent */
    readonly video?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** File identifiers of the stickers added to the video, if applicable */
    readonly added_sticker_file_ids?: ReadonlyArray<number>,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** Video width */
    readonly width?: number,
    /** Video height */
    readonly height?: number,
    /** True, if the video is supposed to be streamed */
    readonly supports_streaming?: boolean,
    /**
     * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
    /**
     * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified
     * only in private chats
     */
    readonly ttl?: number,
  }

  export type inputMessageVideoNote = {
    /** A video note message */
    _: 'inputMessageVideoNote',
    /** Video note to be sent */
    video_note: InputFile,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    thumbnail: inputThumbnail,
    /** Duration of the video, in seconds */
    duration: number,
    /** Video width and height; must be positive and not greater than 640 */
    length: number,
  }

  export type inputMessageVideoNote$Input = {
    /** A video note message */
    readonly _: 'inputMessageVideoNote',
    /** Video note to be sent */
    readonly video_note?: InputFile$Input,
    /** Video thumbnail; pass null to skip thumbnail uploading */
    readonly thumbnail?: inputThumbnail$Input,
    /** Duration of the video, in seconds */
    readonly duration?: number,
    /** Video width and height; must be positive and not greater than 640 */
    readonly length?: number,
  }

  export type inputMessageVoiceNote = {
    /** A voice note message */
    _: 'inputMessageVoiceNote',
    /** Voice note to be sent */
    voice_note: InputFile,
    /** Duration of the voice note, in seconds */
    duration: number,
    /** Waveform representation of the voice note, in 5-bit format */
    waveform: string,
    /**
     * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    caption: formattedText,
  }

  export type inputMessageVoiceNote$Input = {
    /** A voice note message */
    readonly _: 'inputMessageVoiceNote',
    /** Voice note to be sent */
    readonly voice_note?: InputFile$Input,
    /** Duration of the voice note, in seconds */
    readonly duration?: number,
    /** Waveform representation of the voice note, in 5-bit format */
    readonly waveform?: string,
    /**
     * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type inputMessageLocation = {
    /** A message with a location */
    _: 'inputMessageLocation',
    /** Location to be sent */
    location: location,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a live location and 0 otherwise
     */
    live_period: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    heading: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    proximity_alert_radius: number,
  }

  export type inputMessageLocation$Input = {
    /** A message with a location */
    readonly _: 'inputMessageLocation',
    /** Location to be sent */
    readonly location?: location$Input,
    /**
     * Period for which the location can be updated, in seconds; must be between 60
     * and 86400 for a live location and 0 otherwise
     */
    readonly live_period?: number,
    /**
     * For live locations, a direction in which the location moves, in degrees; 1-360.
     * Pass 0 if unknown
     */
    readonly heading?: number,
    /**
     * For live locations, a maximum distance to another chat member for proximity
     * alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't
     * be enabled in channels and Saved Messages
     */
    readonly proximity_alert_radius?: number,
  }

  export type inputMessageVenue = {
    /** A message with information about a venue */
    _: 'inputMessageVenue',
    /** Venue to send */
    venue: venue,
  }

  export type inputMessageVenue$Input = {
    /** A message with information about a venue */
    readonly _: 'inputMessageVenue',
    /** Venue to send */
    readonly venue?: venue$Input,
  }

  export type inputMessageContact = {
    /** A message containing a user contact */
    _: 'inputMessageContact',
    /** Contact to send */
    contact: contact,
  }

  export type inputMessageContact$Input = {
    /** A message containing a user contact */
    readonly _: 'inputMessageContact',
    /** Contact to send */
    readonly contact?: contact$Input,
  }

  export type inputMessageDice = {
    /** A dice message */
    _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    emoji: string,
    /** True, if the chat message draft must be deleted */
    clear_draft: boolean,
  }

  export type inputMessageDice$Input = {
    /** A dice message */
    readonly _: 'inputMessageDice',
    /** Emoji on which the dice throw animation is based */
    readonly emoji?: string,
    /** True, if the chat message draft must be deleted */
    readonly clear_draft?: boolean,
  }

  export type inputMessageGame = {
    /** A message with a game; not supported for channels or secret chats */
    _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    bot_user_id: number,
    /** Short name of the game */
    game_short_name: string,
  }

  export type inputMessageGame$Input = {
    /** A message with a game; not supported for channels or secret chats */
    readonly _: 'inputMessageGame',
    /** User identifier of the bot that owns the game */
    readonly bot_user_id?: number,
    /** Short name of the game */
    readonly game_short_name?: string,
  }

  export type inputMessageInvoice = {
    /** A message with an invoice; can be used only by bots */
    _: 'inputMessageInvoice',
    /** Invoice */
    invoice: invoice,
    /** Product title; 1-32 characters */
    title: string,
    /** Product description; 0-255 characters */
    description: string,
    /** Product photo URL; optional */
    photo_url: string,
    /** Product photo size */
    photo_size: number,
    /** Product photo width */
    photo_width: number,
    /** Product photo height */
    photo_height: number,
    /** The invoice payload */
    payload: string,
    /** Payment provider token */
    provider_token: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    provider_data: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    start_parameter: string,
  }

  export type inputMessageInvoice$Input = {
    /** A message with an invoice; can be used only by bots */
    readonly _: 'inputMessageInvoice',
    /** Invoice */
    readonly invoice?: invoice$Input,
    /** Product title; 1-32 characters */
    readonly title?: string,
    /** Product description; 0-255 characters */
    readonly description?: string,
    /** Product photo URL; optional */
    readonly photo_url?: string,
    /** Product photo size */
    readonly photo_size?: number,
    /** Product photo width */
    readonly photo_width?: number,
    /** Product photo height */
    readonly photo_height?: number,
    /** The invoice payload */
    readonly payload?: string,
    /** Payment provider token */
    readonly provider_token?: string,
    /** JSON-encoded data about the invoice, which will be shared with the payment provider */
    readonly provider_data?: string,
    /**
     * Unique invoice bot deep link parameter for the generation of this invoice. If
     * empty, it would be possible to pay directly from forwards of the invoice message
     */
    readonly start_parameter?: string,
  }

  export type inputMessagePoll = {
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    _: 'inputMessagePoll',
    /** Poll question; 1-255 characters (up to 300 characters for bots) */
    question: string,
    /** List of poll answer options, 2-10 strings 1-100 characters each */
    options: Array<string>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    is_anonymous: boolean,
    /** Type of the poll */
    type: PollType,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    open_period: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    close_date: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    is_closed: boolean,
  }

  export type inputMessagePoll$Input = {
    /**
     * A message with a poll. Polls can't be sent to secret chats. Polls can be sent
     * only to a private chat with a bot
     */
    readonly _: 'inputMessagePoll',
    /** Poll question; 1-255 characters (up to 300 characters for bots) */
    readonly question?: string,
    /** List of poll answer options, 2-10 strings 1-100 characters each */
    readonly options?: ReadonlyArray<string>,
    /**
     * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or
     * forwarded to channels
     */
    readonly is_anonymous?: boolean,
    /** Type of the poll */
    readonly type?: PollType$Input,
    /**
     * Amount of time the poll will be active after creation, in seconds; for bots
     * only
     */
    readonly open_period?: number,
    /**
     * Point in time (Unix timestamp) when the poll will automatically be closed; for
     * bots only
     */
    readonly close_date?: number,
    /** True, if the poll needs to be sent already closed; for bots only */
    readonly is_closed?: boolean,
  }

  export type inputMessageForwarded = {
    /** A forwarded message */
    _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    from_chat_id: number,
    /** Identifier of the message to forward */
    message_id: number,
    /**
     * True, if a game message is being shared from a launched game; applies only to
     * game messages
     */
    in_game_share: boolean,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    copy_options: messageCopyOptions,
  }

  export type inputMessageForwarded$Input = {
    /** A forwarded message */
    readonly _: 'inputMessageForwarded',
    /** Identifier for the chat this forwarded message came from */
    readonly from_chat_id?: number,
    /** Identifier of the message to forward */
    readonly message_id?: number,
    /**
     * True, if a game message is being shared from a launched game; applies only to
     * game messages
     */
    readonly in_game_share?: boolean,
    /**
     * Options to be used to copy content of the message without reference to the original
     * sender; pass null to forward the message as usual
     */
    readonly copy_options?: messageCopyOptions$Input,
  }

  export type searchMessagesFilterEmpty$Input = {
    /** Returns all found messages, no filter is applied */
    readonly _: 'searchMessagesFilterEmpty',
  }

  export type searchMessagesFilterAnimation$Input = {
    /** Returns only animation messages */
    readonly _: 'searchMessagesFilterAnimation',
  }

  export type searchMessagesFilterAudio$Input = {
    /** Returns only audio messages */
    readonly _: 'searchMessagesFilterAudio',
  }

  export type searchMessagesFilterDocument$Input = {
    /** Returns only document messages */
    readonly _: 'searchMessagesFilterDocument',
  }

  export type searchMessagesFilterPhoto$Input = {
    /** Returns only photo messages */
    readonly _: 'searchMessagesFilterPhoto',
  }

  export type searchMessagesFilterVideo$Input = {
    /** Returns only video messages */
    readonly _: 'searchMessagesFilterVideo',
  }

  export type searchMessagesFilterVoiceNote$Input = {
    /** Returns only voice note messages */
    readonly _: 'searchMessagesFilterVoiceNote',
  }

  export type searchMessagesFilterPhotoAndVideo$Input = {
    /** Returns only photo and video messages */
    readonly _: 'searchMessagesFilterPhotoAndVideo',
  }

  export type searchMessagesFilterUrl$Input = {
    /** Returns only messages containing URLs */
    readonly _: 'searchMessagesFilterUrl',
  }

  export type searchMessagesFilterChatPhoto$Input = {
    /** Returns only messages containing chat photos */
    readonly _: 'searchMessagesFilterChatPhoto',
  }

  export type searchMessagesFilterVideoNote$Input = {
    /** Returns only video note messages */
    readonly _: 'searchMessagesFilterVideoNote',
  }

  export type searchMessagesFilterVoiceAndVideoNote$Input = {
    /** Returns only voice and video note messages */
    readonly _: 'searchMessagesFilterVoiceAndVideoNote',
  }

  export type searchMessagesFilterMention$Input = {
    /**
     * Returns only messages with mentions of the current user, or messages that are
     * replies to their messages
     */
    readonly _: 'searchMessagesFilterMention',
  }

  export type searchMessagesFilterUnreadMention$Input = {
    /**
     * Returns only messages with unread mentions of the current user, or messages
     * that are replies to their messages. When using this filter the results can't
     * be additionally filtered by a query, a message thread or by the sending user
     */
    readonly _: 'searchMessagesFilterUnreadMention',
  }

  export type searchMessagesFilterFailedToSend$Input = {
    /**
     * Returns only failed to send messages. This filter can be used only if the message
     * database is used
     */
    readonly _: 'searchMessagesFilterFailedToSend',
  }

  export type searchMessagesFilterPinned$Input = {
    /** Returns only pinned messages */
    readonly _: 'searchMessagesFilterPinned',
  }

  export type chatActionTyping = {
    /** The user is typing a message */
    _: 'chatActionTyping',
  }

  export type chatActionTyping$Input = {
    /** The user is typing a message */
    readonly _: 'chatActionTyping',
  }

  export type chatActionRecordingVideo = {
    /** The user is recording a video */
    _: 'chatActionRecordingVideo',
  }

  export type chatActionRecordingVideo$Input = {
    /** The user is recording a video */
    readonly _: 'chatActionRecordingVideo',
  }

  export type chatActionUploadingVideo = {
    /** The user is uploading a video */
    _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideo$Input = {
    /** The user is uploading a video */
    readonly _: 'chatActionUploadingVideo',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionRecordingVoiceNote = {
    /** The user is recording a voice note */
    _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionRecordingVoiceNote$Input = {
    /** The user is recording a voice note */
    readonly _: 'chatActionRecordingVoiceNote',
  }

  export type chatActionUploadingVoiceNote = {
    /** The user is uploading a voice note */
    _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVoiceNote$Input = {
    /** The user is uploading a voice note */
    readonly _: 'chatActionUploadingVoiceNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingPhoto = {
    /** The user is uploading a photo */
    _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingPhoto$Input = {
    /** The user is uploading a photo */
    readonly _: 'chatActionUploadingPhoto',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionUploadingDocument = {
    /** The user is uploading a document */
    _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingDocument$Input = {
    /** The user is uploading a document */
    readonly _: 'chatActionUploadingDocument',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionChoosingSticker = {
    /** The user is picking a sticker to send */
    _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingSticker$Input = {
    /** The user is picking a sticker to send */
    readonly _: 'chatActionChoosingSticker',
  }

  export type chatActionChoosingLocation = {
    /** The user is picking a location or venue to send */
    _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingLocation$Input = {
    /** The user is picking a location or venue to send */
    readonly _: 'chatActionChoosingLocation',
  }

  export type chatActionChoosingContact = {
    /** The user is picking a contact to send */
    _: 'chatActionChoosingContact',
  }

  export type chatActionChoosingContact$Input = {
    /** The user is picking a contact to send */
    readonly _: 'chatActionChoosingContact',
  }

  export type chatActionStartPlayingGame = {
    /** The user has started to play a game */
    _: 'chatActionStartPlayingGame',
  }

  export type chatActionStartPlayingGame$Input = {
    /** The user has started to play a game */
    readonly _: 'chatActionStartPlayingGame',
  }

  export type chatActionRecordingVideoNote = {
    /** The user is recording a video note */
    _: 'chatActionRecordingVideoNote',
  }

  export type chatActionRecordingVideoNote$Input = {
    /** The user is recording a video note */
    readonly _: 'chatActionRecordingVideoNote',
  }

  export type chatActionUploadingVideoNote = {
    /** The user is uploading a video note */
    _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    progress: number,
  }

  export type chatActionUploadingVideoNote$Input = {
    /** The user is uploading a video note */
    readonly _: 'chatActionUploadingVideoNote',
    /** Upload progress, as a percentage */
    readonly progress?: number,
  }

  export type chatActionWatchingAnimations = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    emoji: string,
  }

  export type chatActionWatchingAnimations$Input = {
    /**
     * The user is watching animations sent by the other party by clicking on an animated
     * emoji
     */
    readonly _: 'chatActionWatchingAnimations',
    /** The animated emoji */
    readonly emoji?: string,
  }

  export type chatActionCancel = {
    /** The user has canceled the previous action */
    _: 'chatActionCancel',
  }

  export type chatActionCancel$Input = {
    /** The user has canceled the previous action */
    readonly _: 'chatActionCancel',
  }

  export type userStatusEmpty = {
    /** The user status was never changed */
    _: 'userStatusEmpty',
  }

  export type userStatusOnline = {
    /** The user is online */
    _: 'userStatusOnline',
    /** Point in time (Unix timestamp) when the user's online status will expire */
    expires: number,
  }

  export type userStatusOffline = {
    /** The user is offline */
    _: 'userStatusOffline',
    /** Point in time (Unix timestamp) when the user was last online */
    was_online: number,
  }

  export type userStatusRecently = {
    /** The user was online recently */
    _: 'userStatusRecently',
  }

  export type userStatusLastWeek = {
    /** The user is offline, but was online last week */
    _: 'userStatusLastWeek',
  }

  export type userStatusLastMonth = {
    /** The user is offline, but was online last month */
    _: 'userStatusLastMonth',
  }

  export type stickers = {
    /** Represents a list of stickers */
    _: 'stickers',
    /** List of stickers */
    stickers: Array<sticker>,
  }

  export type emojis = {
    /** Represents a list of emoji */
    _: 'emojis',
    /** List of emojis */
    emojis: Array<string>,
  }

  export type stickerSet = {
    /** Represents a sticker set */
    _: 'stickerSet',
    /** Identifier of the sticker set */
    id: number | string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP or TGS format with width and height 100; may be
     * null. The file can be downloaded only before the thumbnail is changed
     */
    thumbnail?: thumbnail,
    /**
     * Sticker set thumbnail's outline represented as a list of closed vector paths;
     * may be empty. The coordinate system origin is in the upper-left corner
     */
    thumbnail_outline: Array<closedVectorPath>,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** True, is the stickers in the set are animated */
    is_animated: boolean,
    /** True, if the stickers in the set are masks */
    is_masks: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** List of stickers in this set */
    stickers: Array<sticker>,
    /**
     * A list of emoji corresponding to the stickers in the same order. The list is
     * only for informational purposes, because a sticker is always sent with a fixed
     * emoji from the corresponding Sticker object
     */
    emojis: Array<emojis>,
  }

  export type stickerSetInfo = {
    /** Represents short information about a sticker set */
    _: 'stickerSetInfo',
    /** Identifier of the sticker set */
    id: number | string,
    /** Title of the sticker set */
    title: string,
    /** Name of the sticker set */
    name: string,
    /**
     * Sticker set thumbnail in WEBP or TGS format with width and height 100; may be
     * null
     */
    thumbnail?: thumbnail,
    /**
     * Sticker set thumbnail's outline represented as a list of closed vector paths;
     * may be empty. The coordinate system origin is in the upper-left corner
     */
    thumbnail_outline: Array<closedVectorPath>,
    /** True, if the sticker set has been installed by the current user */
    is_installed: boolean,
    /**
     * True, if the sticker set has been archived. A sticker set can't be installed
     * and archived simultaneously
     */
    is_archived: boolean,
    /** True, if the sticker set is official */
    is_official: boolean,
    /** True, is the stickers in the set are animated */
    is_animated: boolean,
    /** True, if the stickers in the set are masks */
    is_masks: boolean,
    /** True for already viewed trending sticker sets */
    is_viewed: boolean,
    /** Total number of stickers in the set */
    size: number,
    /**
     * Up to the first 5 stickers from the set, depending on the context. If the application
     * needs more stickers the full sticker set needs to be requested
     */
    covers: Array<sticker>,
  }

  export type stickerSets = {
    /** Represents a list of sticker sets */
    _: 'stickerSets',
    /** Approximate total number of sticker sets found */
    total_count: number,
    /** List of sticker sets */
    sets: Array<stickerSetInfo>,
  }

  export type callDiscardReasonEmpty = {
    /** The call wasn't discarded, or the reason is unknown */
    _: 'callDiscardReasonEmpty',
  }

  export type callDiscardReasonMissed = {
    /**
     * The call was ended before the conversation started. It was canceled by the caller
     * or missed by the other party
     */
    _: 'callDiscardReasonMissed',
  }

  export type callDiscardReasonDeclined = {
    /**
     * The call was ended before the conversation started. It was declined by the other
     * party
     */
    _: 'callDiscardReasonDeclined',
  }

  export type callDiscardReasonDisconnected = {
    /** The call was ended during the conversation because the users were disconnected */
    _: 'callDiscardReasonDisconnected',
  }

  export type callDiscardReasonHungUp = {
    /** The call was ended because one of the parties hung up */
    _: 'callDiscardReasonHungUp',
  }

  export type callProtocol = {
    /** Specifies the supported call protocols */
    _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    udp_p2p: boolean,
    /** True, if connection through UDP reflectors is supported */
    udp_reflector: boolean,
    /** The minimum supported API layer; use 65 */
    min_layer: number,
    /** The maximum supported API layer; use 65 */
    max_layer: number,
    /** List of supported tgcalls versions */
    library_versions: Array<string>,
  }

  export type callProtocol$Input = {
    /** Specifies the supported call protocols */
    readonly _: 'callProtocol',
    /** True, if UDP peer-to-peer connections are supported */
    readonly udp_p2p?: boolean,
    /** True, if connection through UDP reflectors is supported */
    readonly udp_reflector?: boolean,
    /** The minimum supported API layer; use 65 */
    readonly min_layer?: number,
    /** The maximum supported API layer; use 65 */
    readonly max_layer?: number,
    /** List of supported tgcalls versions */
    readonly library_versions?: ReadonlyArray<string>,
  }

  export type callServerTypeTelegramReflector = {
    /** A Telegram call reflector */
    _: 'callServerTypeTelegramReflector',
    /** A peer tag to be used with the reflector */
    peer_tag: string,
  }

  export type callServerTypeWebrtc = {
    /** A WebRTC server */
    _: 'callServerTypeWebrtc',
    /** Username to be used for authentication */
    username: string,
    /** Authentication password */
    password: string,
    /** True, if the server supports TURN */
    supports_turn: boolean,
    /** True, if the server supports STUN */
    supports_stun: boolean,
  }

  export type callServer = {
    /** Describes a server for relaying call data */
    _: 'callServer',
    /** Server identifier */
    id: number | string,
    /** Server IPv4 address */
    ip_address: string,
    /** Server IPv6 address */
    ipv6_address: string,
    /** Server port number */
    port: number,
    /** Server type */
    type: CallServerType,
  }

  export type callId = {
    /** Contains the call identifier */
    _: 'callId',
    /** Call identifier */
    id: number,
  }

  export type groupCallId = {
    /** Contains the group call identifier */
    _: 'groupCallId',
    /** Group call identifier */
    id: number,
  }

  export type callStatePending = {
    /** The call is pending, waiting to be accepted by a user */
    _: 'callStatePending',
    /** True, if the call has already been created by the server */
    is_created: boolean,
    /** True, if the call has already been received by the other party */
    is_received: boolean,
  }

  export type callStateExchangingKeys = {
    /** The call has been answered and encryption keys are being exchanged */
    _: 'callStateExchangingKeys',
  }

  export type callStateReady = {
    /** The call is ready to use */
    _: 'callStateReady',
    /** Call protocols supported by the peer */
    protocol: callProtocol,
    /** List of available call servers */
    servers: Array<callServer>,
    /** A JSON-encoded call config */
    config: string,
    /** Call encryption key */
    encryption_key: string,
    /** Encryption key emojis fingerprint */
    emojis: Array<string>,
    /** True, if peer-to-peer connection is allowed by users privacy settings */
    allow_p2p: boolean,
  }

  export type callStateHangingUp = {
    /** The call is hanging up after discardCall has been called */
    _: 'callStateHangingUp',
  }

  export type callStateDiscarded = {
    /** The call has ended successfully */
    _: 'callStateDiscarded',
    /** The reason, why the call has ended */
    reason: CallDiscardReason,
    /** True, if the call rating must be sent to the server */
    need_rating: boolean,
    /** True, if the call debug information must be sent to the server */
    need_debug_information: boolean,
  }

  export type callStateError = {
    /** The call has ended with an error */
    _: 'callStateError',
    /**
     * Error. An error with the code 4005000 will be returned if an outgoing call is
     * missed because of an expired timeout
     */
    error: error,
  }

  export type groupCallVideoQualityThumbnail$Input = {
    /** The worst available video quality */
    readonly _: 'groupCallVideoQualityThumbnail',
  }

  export type groupCallVideoQualityMedium$Input = {
    /** The medium video quality */
    readonly _: 'groupCallVideoQualityMedium',
  }

  export type groupCallVideoQualityFull$Input = {
    /** The best available video quality */
    readonly _: 'groupCallVideoQualityFull',
  }

  export type groupCallRecentSpeaker = {
    /** Describes a recently speaking participant in a group call */
    _: 'groupCallRecentSpeaker',
    /** Group call participant identifier */
    participant_id: MessageSender,
    /** True, is the user has spoken recently */
    is_speaking: boolean,
  }

  export type groupCall = {
    /** Describes a group call */
    _: 'groupCall',
    /** Group call identifier */
    id: number,
    /** Group call title */
    title: string,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator; 0 if it is already active or was ended
     */
    scheduled_start_date: number,
    /**
     * True, if the group call is scheduled and the current user will receive a notification
     * when the group call will start
     */
    enabled_start_notification: boolean,
    /** True, if the call is active */
    is_active: boolean,
    /** True, if the call is joined */
    is_joined: boolean,
    /**
     * True, if user was kicked from the call because of network loss and the call
     * needs to be rejoined
     */
    need_rejoin: boolean,
    /** True, if the current user can manage the group call */
    can_be_managed: boolean,
    /** Number of participants in the group call */
    participant_count: number,
    /** True, if all group call participants are loaded */
    loaded_all_participants: boolean,
    /** At most 3 recently speaking users in the group call */
    recent_speakers: Array<groupCallRecentSpeaker>,
    /** True, if the current user's video is enabled */
    is_my_video_enabled: boolean,
    /** True, if the current user's video is paused */
    is_my_video_paused: boolean,
    /** True, if the current user can broadcast video or share screen */
    can_enable_video: boolean,
    /** True, if only group call administrators can unmute new participants */
    mute_new_participants: boolean,
    /** True, if the current user can enable or disable mute_new_participants setting */
    can_toggle_mute_new_participants: boolean,
    /**
     * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall
     * update is not triggered when value of this field changes, but the same recording
     * goes on
     */
    record_duration: number,
    /** True, if a video file is being recorded for the call */
    is_video_recorded: boolean,
    /** Call duration, in seconds; for ended calls only */
    duration: number,
  }

  export type groupCallVideoSourceGroup = {
    /** Describes a group of video synchronization source identifiers */
    _: 'groupCallVideoSourceGroup',
    /** The semantics of sources, one of "SIM" or "FID" */
    semantics: string,
    /** The list of synchronization source identifiers */
    source_ids: Array<number>,
  }

  export type groupCallParticipantVideoInfo = {
    /** Contains information about a group call participant's video channel */
    _: 'groupCallParticipantVideoInfo',
    /** List of synchronization source groups of the video */
    source_groups: Array<groupCallVideoSourceGroup>,
    /** Video channel endpoint identifier */
    endpoint_id: string,
    /**
     * True if the video is paused. This flag needs to be ignored, if new video frames
     * are received
     */
    is_paused: boolean,
  }

  export type groupCallParticipant = {
    /** Represents a group call participant */
    _: 'groupCallParticipant',
    /** Identifier of the group call participant */
    participant_id: MessageSender,
    /** User's audio channel synchronization source identifier */
    audio_source_id: number,
    /** User's screen sharing audio channel synchronization source identifier */
    screen_sharing_audio_source_id: number,
    /** Information about user's video channel; may be null if there is no active video */
    video_info?: groupCallParticipantVideoInfo,
    /**
     * Information about user's screen sharing video channel; may be null if there
     * is no active screen sharing video
     */
    screen_sharing_video_info?: groupCallParticipantVideoInfo,
    /** The participant user's bio or the participant chat's description */
    bio: string,
    /** True, if the participant is the current user */
    is_current_user: boolean,
    /** True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking */
    is_speaking: boolean,
    /** True, if the participant hand is raised */
    is_hand_raised: boolean,
    /**
     * True, if the current user can mute the participant for all other group call
     * participants
     */
    can_be_muted_for_all_users: boolean,
    /**
     * True, if the current user can allow the participant to unmute themselves or
     * unmute the participant (if the participant is the current user)
     */
    can_be_unmuted_for_all_users: boolean,
    /** True, if the current user can mute the participant only for self */
    can_be_muted_for_current_user: boolean,
    /** True, if the current user can unmute the participant for self */
    can_be_unmuted_for_current_user: boolean,
    /** True, if the participant is muted for all users */
    is_muted_for_all_users: boolean,
    /** True, if the participant is muted for the current user */
    is_muted_for_current_user: boolean,
    /** True, if the participant is muted for all users, but can unmute themselves */
    can_unmute_self: boolean,
    /** Participant's volume level; 1-20000 in hundreds of percents */
    volume_level: number,
    /**
     * User's order in the group call participant list. Orders must be compared lexicographically.
     * The bigger is order, the higher is user in the list. If order is empty, the
     * user must be removed from the participant list
     */
    order: string,
  }

  export type callProblemEcho$Input = {
    /** The user heard their own voice */
    readonly _: 'callProblemEcho',
  }

  export type callProblemNoise$Input = {
    /** The user heard background noise */
    readonly _: 'callProblemNoise',
  }

  export type callProblemInterruptions$Input = {
    /** The other side kept disappearing */
    readonly _: 'callProblemInterruptions',
  }

  export type callProblemDistortedSpeech$Input = {
    /** The speech was distorted */
    readonly _: 'callProblemDistortedSpeech',
  }

  export type callProblemSilentLocal$Input = {
    /** The user couldn't hear the other side */
    readonly _: 'callProblemSilentLocal',
  }

  export type callProblemSilentRemote$Input = {
    /** The other side couldn't hear the user */
    readonly _: 'callProblemSilentRemote',
  }

  export type callProblemDropped$Input = {
    /** The call ended unexpectedly */
    readonly _: 'callProblemDropped',
  }

  export type callProblemDistortedVideo$Input = {
    /** The video was distorted */
    readonly _: 'callProblemDistortedVideo',
  }

  export type callProblemPixelatedVideo$Input = {
    /** The video was pixelated */
    readonly _: 'callProblemPixelatedVideo',
  }

  export type call = {
    /** Describes a call */
    _: 'call',
    /** Call identifier, not persistent */
    id: number,
    /** Peer user identifier */
    user_id: number,
    /** True, if the call is outgoing */
    is_outgoing: boolean,
    /** True, if the call is a video call */
    is_video: boolean,
    /** Call state */
    state: CallState,
  }

  export type phoneNumberAuthenticationSettings$Input = {
    /** Contains settings for the authentication of the user's phone number */
    readonly _: 'phoneNumberAuthenticationSettings',
    /**
     * Pass true if the authentication code may be sent via a flash call to the specified
     * phone number
     */
    readonly allow_flash_call?: boolean,
    /**
     * Pass true if the authentication code may be sent via a missed call to the specified
     * phone number
     */
    readonly allow_missed_call?: boolean,
    /** Pass true if the authenticated phone number is used on the current device */
    readonly is_current_phone_number?: boolean,
    /**
     * For official applications only. True, if the application can use Android SMS
     * Retriever API (requires Google Play Services >= 10.2) to automatically receive
     * the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/
     * for more details
     */
    readonly allow_sms_retriever_api?: boolean,
    /**
     * List of up to 20 authentication tokens, recently received in updateOption("authentication_token")
     * in previously logged out sessions
     */
    readonly authentication_tokens?: ReadonlyArray<string>,
  }

  export type animations = {
    /** Represents a list of animations */
    _: 'animations',
    /** List of animations */
    animations: Array<animation>,
  }

  export type diceStickersRegular = {
    /** A regular animated sticker */
    _: 'diceStickersRegular',
    /** The animated sticker with the dice animation */
    sticker: sticker,
  }

  export type diceStickersSlotMachine = {
    /** Animated stickers to be combined into a slot machine */
    _: 'diceStickersSlotMachine',
    /**
     * The animated sticker with the slot machine background. The background animation
     * must start playing after all reel animations finish
     */
    background: sticker,
    /**
     * The animated sticker with the lever animation. The lever animation must play
     * once in the initial dice state
     */
    lever: sticker,
    /** The animated sticker with the left reel */
    left_reel: sticker,
    /** The animated sticker with the center reel */
    center_reel: sticker,
    /** The animated sticker with the right reel */
    right_reel: sticker,
  }

  export type importedContacts = {
    /** Represents the result of an ImportContacts request */
    _: 'importedContacts',
    /**
     * User identifiers of the imported contacts in the same order as they were specified
     * in the request; 0 if the contact is not yet a registered user
     */
    user_ids: Array<number>,
    /**
     * The number of users that imported the corresponding contact; 0 for already registered
     * users or if unavailable
     */
    importer_count: Array<number>,
  }

  export type httpUrl = {
    /** Contains an HTTP URL */
    _: 'httpUrl',
    /** The URL */
    url: string,
  }

  export type inputInlineQueryResultAnimation$Input = {
    /**
     * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4
     * AVC video
     */
    readonly _: 'inputInlineQueryResultAnimation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the query result */
    readonly title?: string,
    /** URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists */
    readonly thumbnail_url?: string,
    /**
     * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg",
     * "image/gif" and "video/mp4"
     */
    readonly thumbnail_mime_type?: string,
    /** The URL of the video file (file size must not exceed 1MB) */
    readonly video_url?: string,
    /** MIME type of the video file. Must be one of "image/gif" and "video/mp4" */
    readonly video_mime_type?: string,
    /** Duration of the video, in seconds */
    readonly video_duration?: number,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultArticle$Input = {
    /** Represents a link to an article or web page */
    readonly _: 'inputInlineQueryResultArticle',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the result, if it exists */
    readonly url?: string,
    /** True, if the URL must be not shown */
    readonly hide_url?: boolean,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result */
    readonly description?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultAudio$Input = {
    /** Represents a link to an MP3 audio file */
    readonly _: 'inputInlineQueryResultAudio',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the audio file */
    readonly title?: string,
    /** Performer of the audio file */
    readonly performer?: string,
    /** The URL of the audio file */
    readonly audio_url?: string,
    /** Audio file duration, in seconds */
    readonly audio_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultContact$Input = {
    /** Represents a user contact */
    readonly _: 'inputInlineQueryResultContact',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** User contact */
    readonly contact?: contact$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultDocument$Input = {
    /** Represents a link to a file */
    readonly _: 'inputInlineQueryResultDocument',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the resulting file */
    readonly title?: string,
    /** Short description of the result, if known */
    readonly description?: string,
    /** URL of the file */
    readonly document_url?: string,
    /**
     * MIME type of the file content; only "application/pdf" and "application/zip"
     * are currently allowed
     */
    readonly mime_type?: string,
    /** The URL of the file thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Width of the thumbnail */
    readonly thumbnail_width?: number,
    /** Height of the thumbnail */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultGame$Input = {
    /** Represents a game */
    readonly _: 'inputInlineQueryResultGame',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Short name of the game */
    readonly game_short_name?: string,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type inputInlineQueryResultLocation$Input = {
    /** Represents a point on the map */
    readonly _: 'inputInlineQueryResultLocation',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Location result */
    readonly location?: location$Input,
    /**
     * Amount of time relative to the message sent time until the location can be updated,
     * in seconds
     */
    readonly live_period?: number,
    /** Title of the result */
    readonly title?: string,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultPhoto$Input = {
    /** Represents link to a JPEG image */
    readonly _: 'inputInlineQueryResultPhoto',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result, if known */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** URL of the photo thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** The URL of the JPEG photo (photo size must not exceed 5MB) */
    readonly photo_url?: string,
    /** Width of the photo */
    readonly photo_width?: number,
    /** Height of the photo */
    readonly photo_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultSticker$Input = {
    /** Represents a link to a WEBP or TGS sticker */
    readonly _: 'inputInlineQueryResultSticker',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** URL of the sticker thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB) */
    readonly sticker_url?: string,
    /** Width of the sticker */
    readonly sticker_width?: number,
    /** Height of the sticker */
    readonly sticker_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVenue$Input = {
    /** Represents information about a venue */
    readonly _: 'inputInlineQueryResultVenue',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Venue result */
    readonly venue?: venue$Input,
    /** URL of the result thumbnail, if it exists */
    readonly thumbnail_url?: string,
    /** Thumbnail width, if known */
    readonly thumbnail_width?: number,
    /** Thumbnail height, if known */
    readonly thumbnail_height?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVideo$Input = {
    /** Represents a link to a page containing an embedded video player or a video file */
    readonly _: 'inputInlineQueryResultVideo',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the result */
    readonly title?: string,
    /** A short description of the result, if known */
    readonly description?: string,
    /** The URL of the video thumbnail (JPEG), if it exists */
    readonly thumbnail_url?: string,
    /** URL of the embedded video player or video file */
    readonly video_url?: string,
    /**
     * MIME type of the content of the video URL, only "text/html" or "video/mp4" are
     * currently supported
     */
    readonly mime_type?: string,
    /** Width of the video */
    readonly video_width?: number,
    /** Height of the video */
    readonly video_height?: number,
    /** Video duration, in seconds */
    readonly video_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inputInlineQueryResultVoiceNote$Input = {
    /**
     * Represents a link to an opus-encoded audio file within an OGG container, single
     * channel audio
     */
    readonly _: 'inputInlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    readonly id?: string,
    /** Title of the voice note */
    readonly title?: string,
    /** The URL of the voice note file */
    readonly voice_note_url?: string,
    /** Duration of the voice note, in seconds */
    readonly voice_note_duration?: number,
    /**
     * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard
     * or null
     */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * The content of the message to be sent. Must be one of the following types: inputMessageText,
     * inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue
     * or inputMessageContact
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type inlineQueryResultArticle = {
    /** Represents a link to an article or web page */
    _: 'inlineQueryResultArticle',
    /** Unique identifier of the query result */
    id: string,
    /** URL of the result, if it exists */
    url: string,
    /** True, if the URL must be not shown */
    hide_url: boolean,
    /** Title of the result */
    title: string,
    /** A short description of the result */
    description: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultContact = {
    /** Represents a user contact */
    _: 'inlineQueryResultContact',
    /** Unique identifier of the query result */
    id: string,
    /** A user contact */
    contact: contact,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultLocation = {
    /** Represents a point on the map */
    _: 'inlineQueryResultLocation',
    /** Unique identifier of the query result */
    id: string,
    /** Location result */
    location: location,
    /** Title of the result */
    title: string,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultVenue = {
    /** Represents information about a venue */
    _: 'inlineQueryResultVenue',
    /** Unique identifier of the query result */
    id: string,
    /** Venue result */
    venue: venue,
    /** Result thumbnail in JPEG format; may be null */
    thumbnail?: thumbnail,
  }

  export type inlineQueryResultGame = {
    /** Represents information about a game */
    _: 'inlineQueryResultGame',
    /** Unique identifier of the query result */
    id: string,
    /** Game result */
    game: game,
  }

  export type inlineQueryResultAnimation = {
    /** Represents an animation file */
    _: 'inlineQueryResultAnimation',
    /** Unique identifier of the query result */
    id: string,
    /** Animation file */
    animation: animation,
    /** Animation title */
    title: string,
  }

  export type inlineQueryResultAudio = {
    /** Represents an audio file */
    _: 'inlineQueryResultAudio',
    /** Unique identifier of the query result */
    id: string,
    /** Audio file */
    audio: audio,
  }

  export type inlineQueryResultDocument = {
    /** Represents a document */
    _: 'inlineQueryResultDocument',
    /** Unique identifier of the query result */
    id: string,
    /** Document */
    document: document,
    /** Document title */
    title: string,
    /** Document description */
    description: string,
  }

  export type inlineQueryResultPhoto = {
    /** Represents a photo */
    _: 'inlineQueryResultPhoto',
    /** Unique identifier of the query result */
    id: string,
    /** Photo */
    photo: photo,
    /** Title of the result, if known */
    title: string,
    /** A short description of the result, if known */
    description: string,
  }

  export type inlineQueryResultSticker = {
    /** Represents a sticker */
    _: 'inlineQueryResultSticker',
    /** Unique identifier of the query result */
    id: string,
    /** Sticker */
    sticker: sticker,
  }

  export type inlineQueryResultVideo = {
    /** Represents a video */
    _: 'inlineQueryResultVideo',
    /** Unique identifier of the query result */
    id: string,
    /** Video */
    video: video,
    /** Title of the video */
    title: string,
    /** Description of the video */
    description: string,
  }

  export type inlineQueryResultVoiceNote = {
    /** Represents a voice note */
    _: 'inlineQueryResultVoiceNote',
    /** Unique identifier of the query result */
    id: string,
    /** Voice note */
    voice_note: voiceNote,
    /** Title of the voice note */
    title: string,
  }

  export type inlineQueryResults = {
    /**
     * Represents the results of the inline query. Use sendInlineQueryResultMessage
     * to send the result of the query
     */
    _: 'inlineQueryResults',
    /** Unique identifier of the inline query */
    inline_query_id: number | string,
    /** The offset for the next request. If empty, there are no more results */
    next_offset: string,
    /** Results of the query */
    results: Array<InlineQueryResult>,
    /**
     * If non-empty, this text must be shown on the button, which opens a private chat
     * with the bot and sends the bot a start message with the switch_pm_parameter
     */
    switch_pm_text: string,
    /** Parameter for the bot start message */
    switch_pm_parameter: string,
  }

  export type callbackQueryPayloadData = {
    /** The payload for a general callback button */
    _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    data: string,
  }

  export type callbackQueryPayloadData$Input = {
    /** The payload for a general callback button */
    readonly _: 'callbackQueryPayloadData',
    /** Data that was attached to the callback button */
    readonly data?: string,
  }

  export type callbackQueryPayloadDataWithPassword = {
    /** The payload for a callback button requiring password */
    _: 'callbackQueryPayloadDataWithPassword',
    /** The password for the current user */
    password: string,
    /** Data that was attached to the callback button */
    data: string,
  }

  export type callbackQueryPayloadDataWithPassword$Input = {
    /** The payload for a callback button requiring password */
    readonly _: 'callbackQueryPayloadDataWithPassword',
    /** The password for the current user */
    readonly password?: string,
    /** Data that was attached to the callback button */
    readonly data?: string,
  }

  export type callbackQueryPayloadGame = {
    /** The payload for a game callback button */
    _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    game_short_name: string,
  }

  export type callbackQueryPayloadGame$Input = {
    /** The payload for a game callback button */
    readonly _: 'callbackQueryPayloadGame',
    /** A short name of the game that was attached to the callback button */
    readonly game_short_name?: string,
  }

  export type callbackQueryAnswer = {
    /** Contains a bot's answer to a callback query */
    _: 'callbackQueryAnswer',
    /** Text of the answer */
    text: string,
    /** True, if an alert must be shown to the user instead of a toast notification */
    show_alert: boolean,
    /** URL to be opened */
    url: string,
  }

  export type customRequestResult = {
    /** Contains the result of a custom request */
    _: 'customRequestResult',
    /** A JSON-serialized result */
    result: string,
  }

  export type gameHighScore = {
    /** Contains one row of the game high score table */
    _: 'gameHighScore',
    /** Position in the high score table */
    position: number,
    /** User identifier */
    user_id: number,
    /** User score */
    score: number,
  }

  export type gameHighScores = {
    /** Contains a list of game high scores */
    _: 'gameHighScores',
    /** A list of game high scores */
    scores: Array<gameHighScore>,
  }

  export type chatEventMessageEdited = {
    /** A message was edited */
    _: 'chatEventMessageEdited',
    /** The original message before the edit */
    old_message: message,
    /** The message after it was edited */
    new_message: message,
  }

  export type chatEventMessageDeleted = {
    /** A message was deleted */
    _: 'chatEventMessageDeleted',
    /** Deleted message */
    message: message,
  }

  export type chatEventPollStopped = {
    /** A poll in a message was stopped */
    _: 'chatEventPollStopped',
    /** The message with the poll */
    message: message,
  }

  export type chatEventMessagePinned = {
    /** A message was pinned */
    _: 'chatEventMessagePinned',
    /** Pinned message */
    message: message,
  }

  export type chatEventMessageUnpinned = {
    /** A message was unpinned */
    _: 'chatEventMessageUnpinned',
    /** Unpinned message */
    message: message,
  }

  export type chatEventMemberJoined = {
    /** A new member joined the chat */
    _: 'chatEventMemberJoined',
  }

  export type chatEventMemberJoinedByInviteLink = {
    /** A new member joined the chat via an invite link */
    _: 'chatEventMemberJoinedByInviteLink',
    /** Invite link used to join the chat */
    invite_link: chatInviteLink,
  }

  export type chatEventMemberJoinedByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'chatEventMemberJoinedByRequest',
    /** User identifier of the chat administrator, approved user join request */
    approver_user_id: number,
    /** Invite link used to join the chat; may be null */
    invite_link?: chatInviteLink,
  }

  export type chatEventMemberLeft = {
    /** A member left the chat */
    _: 'chatEventMemberLeft',
  }

  export type chatEventMemberInvited = {
    /** A new chat member was invited */
    _: 'chatEventMemberInvited',
    /** New member user identifier */
    user_id: number,
    /** New member status */
    status: ChatMemberStatus,
  }

  export type chatEventMemberPromoted = {
    /**
     * A chat member has gained/lost administrator status, or the list of their administrator
     * privileges has changed
     */
    _: 'chatEventMemberPromoted',
    /** Affected chat member user identifier */
    user_id: number,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventMemberRestricted = {
    /**
     * A chat member was restricted/unrestricted or banned/unbanned, or the list of
     * their restrictions has changed
     */
    _: 'chatEventMemberRestricted',
    /** Affected chat member identifier */
    member_id: MessageSender,
    /** Previous status of the chat member */
    old_status: ChatMemberStatus,
    /** New status of the chat member */
    new_status: ChatMemberStatus,
  }

  export type chatEventTitleChanged = {
    /** The chat title was changed */
    _: 'chatEventTitleChanged',
    /** Previous chat title */
    old_title: string,
    /** New chat title */
    new_title: string,
  }

  export type chatEventPermissionsChanged = {
    /** The chat permissions was changed */
    _: 'chatEventPermissionsChanged',
    /** Previous chat permissions */
    old_permissions: chatPermissions,
    /** New chat permissions */
    new_permissions: chatPermissions,
  }

  export type chatEventDescriptionChanged = {
    /** The chat description was changed */
    _: 'chatEventDescriptionChanged',
    /** Previous chat description */
    old_description: string,
    /** New chat description */
    new_description: string,
  }

  export type chatEventUsernameChanged = {
    /** The chat username was changed */
    _: 'chatEventUsernameChanged',
    /** Previous chat username */
    old_username: string,
    /** New chat username */
    new_username: string,
  }

  export type chatEventPhotoChanged = {
    /** The chat photo was changed */
    _: 'chatEventPhotoChanged',
    /** Previous chat photo value; may be null */
    old_photo?: chatPhoto,
    /** New chat photo value; may be null */
    new_photo?: chatPhoto,
  }

  export type chatEventInvitesToggled = {
    /** The can_invite_users permission of a supergroup chat was toggled */
    _: 'chatEventInvitesToggled',
    /** New value of can_invite_users permission */
    can_invite_users: boolean,
  }

  export type chatEventLinkedChatChanged = {
    /** The linked chat of a supergroup was changed */
    _: 'chatEventLinkedChatChanged',
    /** Previous supergroup linked chat identifier */
    old_linked_chat_id: number,
    /** New supergroup linked chat identifier */
    new_linked_chat_id: number,
  }

  export type chatEventSlowModeDelayChanged = {
    /** The slow_mode_delay setting of a supergroup was changed */
    _: 'chatEventSlowModeDelayChanged',
    /** Previous value of slow_mode_delay, in seconds */
    old_slow_mode_delay: number,
    /** New value of slow_mode_delay, in seconds */
    new_slow_mode_delay: number,
  }

  export type chatEventMessageTtlChanged = {
    /** The message TTL was changed */
    _: 'chatEventMessageTtlChanged',
    /** Previous value of message_ttl */
    old_message_ttl: number,
    /** New value of message_ttl */
    new_message_ttl: number,
  }

  export type chatEventSignMessagesToggled = {
    /** The sign_messages setting of a channel was toggled */
    _: 'chatEventSignMessagesToggled',
    /** New value of sign_messages */
    sign_messages: boolean,
  }

  export type chatEventHasProtectedContentToggled = {
    /** The has_protected_content setting of a channel was toggled */
    _: 'chatEventHasProtectedContentToggled',
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type chatEventStickerSetChanged = {
    /** The supergroup sticker set was changed */
    _: 'chatEventStickerSetChanged',
    /** Previous identifier of the chat sticker set; 0 if none */
    old_sticker_set_id: number | string,
    /** New identifier of the chat sticker set; 0 if none */
    new_sticker_set_id: number | string,
  }

  export type chatEventLocationChanged = {
    /** The supergroup location was changed */
    _: 'chatEventLocationChanged',
    /** Previous location; may be null */
    old_location?: chatLocation,
    /** New location; may be null */
    new_location?: chatLocation,
  }

  export type chatEventIsAllHistoryAvailableToggled = {
    /** The is_all_history_available setting of a supergroup was toggled */
    _: 'chatEventIsAllHistoryAvailableToggled',
    /** New value of is_all_history_available */
    is_all_history_available: boolean,
  }

  export type chatEventInviteLinkEdited = {
    /** A chat invite link was edited */
    _: 'chatEventInviteLinkEdited',
    /** Previous information about the invite link */
    old_invite_link: chatInviteLink,
    /** New information about the invite link */
    new_invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkRevoked = {
    /** A chat invite link was revoked */
    _: 'chatEventInviteLinkRevoked',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventInviteLinkDeleted = {
    /** A revoked chat invite link was deleted */
    _: 'chatEventInviteLinkDeleted',
    /** The invite link */
    invite_link: chatInviteLink,
  }

  export type chatEventVideoChatCreated = {
    /** A video chat was created */
    _: 'chatEventVideoChatCreated',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatEnded = {
    /** A video chat was ended */
    _: 'chatEventVideoChatEnded',
    /**
     * Identifier of the video chat. The video chat can be received through the method
     * getGroupCall
     */
    group_call_id: number,
  }

  export type chatEventVideoChatParticipantIsMutedToggled = {
    /** A video chat participant was muted or unmuted */
    _: 'chatEventVideoChatParticipantIsMutedToggled',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of is_muted */
    is_muted: boolean,
  }

  export type chatEventVideoChatParticipantVolumeLevelChanged = {
    /** A video chat participant volume level was changed */
    _: 'chatEventVideoChatParticipantVolumeLevelChanged',
    /** Identifier of the affected group call participant */
    participant_id: MessageSender,
    /** New value of volume_level; 1-20000 in hundreds of percents */
    volume_level: number,
  }

  export type chatEventVideoChatMuteNewParticipantsToggled = {
    /** The mute_new_participants setting of a video chat was toggled */
    _: 'chatEventVideoChatMuteNewParticipantsToggled',
    /** New value of the mute_new_participants setting */
    mute_new_participants: boolean,
  }

  export type chatEvent = {
    /** Represents a chat event */
    _: 'chatEvent',
    /** Chat event identifier */
    id: number | string,
    /** Point in time (Unix timestamp) when the event happened */
    date: number,
    /** Identifier of the user or chat who performed the action */
    member_id: MessageSender,
    /** The action */
    action: ChatEventAction,
  }

  export type chatEvents = {
    /** Contains a list of chat events */
    _: 'chatEvents',
    /** List of events */
    events: Array<chatEvent>,
  }

  export type chatEventLogFilters$Input = {
    /** Represents a set of filters used to obtain a chat event log */
    readonly _: 'chatEventLogFilters',
    /** True, if message edits need to be returned */
    readonly message_edits?: boolean,
    /** True, if message deletions need to be returned */
    readonly message_deletions?: boolean,
    /** True, if pin/unpin events need to be returned */
    readonly message_pins?: boolean,
    /** True, if members joining events need to be returned */
    readonly member_joins?: boolean,
    /** True, if members leaving events need to be returned */
    readonly member_leaves?: boolean,
    /** True, if invited member events need to be returned */
    readonly member_invites?: boolean,
    /** True, if member promotion/demotion events need to be returned */
    readonly member_promotions?: boolean,
    /** True, if member restricted/unrestricted/banned/unbanned events need to be returned */
    readonly member_restrictions?: boolean,
    /** True, if changes in chat information need to be returned */
    readonly info_changes?: boolean,
    /** True, if changes in chat settings need to be returned */
    readonly setting_changes?: boolean,
    /** True, if changes to invite links need to be returned */
    readonly invite_link_changes?: boolean,
    /** True, if video chat actions need to be returned */
    readonly video_chat_changes?: boolean,
  }

  export type languagePackStringValueOrdinary = {
    /** An ordinary language pack string */
    _: 'languagePackStringValueOrdinary',
    /** String value */
    value: string,
  }

  export type languagePackStringValueOrdinary$Input = {
    /** An ordinary language pack string */
    readonly _: 'languagePackStringValueOrdinary',
    /** String value */
    readonly value?: string,
  }

  export type languagePackStringValuePluralized = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more info
     */
    _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    zero_value: string,
    /** Value for one object */
    one_value: string,
    /** Value for two objects */
    two_value: string,
    /** Value for few objects */
    few_value: string,
    /** Value for many objects */
    many_value: string,
    /** Default value */
    other_value: string,
  }

  export type languagePackStringValuePluralized$Input = {
    /**
     * A language pack string which has different forms based on the number of some
     * object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more info
     */
    readonly _: 'languagePackStringValuePluralized',
    /** Value for zero objects */
    readonly zero_value?: string,
    /** Value for one object */
    readonly one_value?: string,
    /** Value for two objects */
    readonly two_value?: string,
    /** Value for few objects */
    readonly few_value?: string,
    /** Value for many objects */
    readonly many_value?: string,
    /** Default value */
    readonly other_value?: string,
  }

  export type languagePackStringValueDeleted = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    _: 'languagePackStringValueDeleted',
  }

  export type languagePackStringValueDeleted$Input = {
    /**
     * A deleted language pack string, the value must be taken from the built-in English
     * language pack
     */
    readonly _: 'languagePackStringValueDeleted',
  }

  export type languagePackString = {
    /** Represents one language pack string */
    _: 'languagePackString',
    /** String key */
    key: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    value: LanguagePackStringValue,
  }

  export type languagePackString$Input = {
    /** Represents one language pack string */
    readonly _: 'languagePackString',
    /** String key */
    readonly key?: string,
    /**
     * String value; pass null if the string needs to be taken from the built-in English
     * language pack
     */
    readonly value?: LanguagePackStringValue$Input,
  }

  export type languagePackStrings = {
    /** Contains a list of language pack strings */
    _: 'languagePackStrings',
    /** A list of language pack strings */
    strings: Array<languagePackString>,
  }

  export type languagePackInfo = {
    /** Contains information about a language pack */
    _: 'languagePackInfo',
    /** Unique language pack identifier */
    id: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    base_language_pack_id: string,
    /** Language name */
    name: string,
    /** Name of the language in that language */
    native_name: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more info
     */
    plural_code: string,
    /** True, if the language pack is official */
    is_official: boolean,
    /** True, if the language pack strings are RTL */
    is_rtl: boolean,
    /** True, if the language pack is a beta language pack */
    is_beta: boolean,
    /** True, if the language pack is installed by the current user */
    is_installed: boolean,
    /** Total number of non-deleted strings from the language pack */
    total_string_count: number,
    /** Total number of translated strings from the language pack */
    translated_string_count: number,
    /** Total number of non-deleted strings from the language pack available locally */
    local_string_count: number,
    /** Link to language translation interface; empty for custom local language packs */
    translation_url: string,
  }

  export type languagePackInfo$Input = {
    /** Contains information about a language pack */
    readonly _: 'languagePackInfo',
    /** Unique language pack identifier */
    readonly id?: string,
    /**
     * Identifier of a base language pack; may be empty. If a string is missed in the
     * language pack, then it must be fetched from base language pack. Unsupported
     * in custom language packs
     */
    readonly base_language_pack_id?: string,
    /** Language name */
    readonly name?: string,
    /** Name of the language in that language */
    readonly native_name?: string,
    /**
     * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
     * for more info
     */
    readonly plural_code?: string,
    /** True, if the language pack is official */
    readonly is_official?: boolean,
    /** True, if the language pack strings are RTL */
    readonly is_rtl?: boolean,
    /** True, if the language pack is a beta language pack */
    readonly is_beta?: boolean,
    /** True, if the language pack is installed by the current user */
    readonly is_installed?: boolean,
    /** Total number of non-deleted strings from the language pack */
    readonly total_string_count?: number,
    /** Total number of translated strings from the language pack */
    readonly translated_string_count?: number,
    /** Total number of non-deleted strings from the language pack available locally */
    readonly local_string_count?: number,
    /** Link to language translation interface; empty for custom local language packs */
    readonly translation_url?: string,
  }

  export type localizationTargetInfo = {
    /** Contains information about the current localization target */
    _: 'localizationTargetInfo',
    /** List of available language packs for this application */
    language_packs: Array<languagePackInfo>,
  }

  export type deviceTokenFirebaseCloudMessaging$Input = {
    /** A token for Firebase Cloud Messaging */
    readonly _: 'deviceTokenFirebaseCloudMessaging',
    /** Device registration token; may be empty to deregister a device */
    readonly token?: string,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenApplePush$Input = {
    /** A token for Apple Push Notification service */
    readonly _: 'deviceTokenApplePush',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
  }

  export type deviceTokenApplePushVoIP$Input = {
    /** A token for Apple Push Notification service VoIP notifications */
    readonly _: 'deviceTokenApplePushVoIP',
    /** Device token; may be empty to deregister a device */
    readonly device_token?: string,
    /** True, if App Sandbox is enabled */
    readonly is_app_sandbox?: boolean,
    /** True, if push notifications must be additionally encrypted */
    readonly encrypt?: boolean,
  }

  export type deviceTokenWindowsPush$Input = {
    /** A token for Windows Push Notification Services */
    readonly _: 'deviceTokenWindowsPush',
    /**
     * The access token that will be used to send notifications; may be empty to deregister
     * a device
     */
    readonly access_token?: string,
  }

  export type deviceTokenMicrosoftPush$Input = {
    /** A token for Microsoft Push Notification Service */
    readonly _: 'deviceTokenMicrosoftPush',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenMicrosoftPushVoIP$Input = {
    /** A token for Microsoft Push Notification Service VoIP channel */
    readonly _: 'deviceTokenMicrosoftPushVoIP',
    /** Push notification channel URI; may be empty to deregister a device */
    readonly channel_uri?: string,
  }

  export type deviceTokenWebPush$Input = {
    /** A token for web Push API */
    readonly _: 'deviceTokenWebPush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
    /** Base64url-encoded P-256 elliptic curve Diffie-Hellman public key */
    readonly p256dh_base64url?: string,
    /** Base64url-encoded authentication secret */
    readonly auth_base64url?: string,
  }

  export type deviceTokenSimplePush$Input = {
    /** A token for Simple Push API for Firefox OS */
    readonly _: 'deviceTokenSimplePush',
    /**
     * Absolute URL exposed by the push service where the application server can send
     * push messages; may be empty to deregister a device
     */
    readonly endpoint?: string,
  }

  export type deviceTokenUbuntuPush$Input = {
    /** A token for Ubuntu Push Client service */
    readonly _: 'deviceTokenUbuntuPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenBlackBerryPush$Input = {
    /** A token for BlackBerry Push Service */
    readonly _: 'deviceTokenBlackBerryPush',
    /** Token; may be empty to deregister a device */
    readonly token?: string,
  }

  export type deviceTokenTizenPush$Input = {
    /** A token for Tizen Push Service */
    readonly _: 'deviceTokenTizenPush',
    /** Push service registration identifier; may be empty to deregister a device */
    readonly reg_id?: string,
  }

  export type pushReceiverId = {
    /**
     * Contains a globally unique push receiver identifier, which can be used to identify
     * which account has received a push notification
     */
    _: 'pushReceiverId',
    /** The globally unique identifier of push notification subscription */
    id: number | string,
  }

  export type backgroundFillSolid = {
    /** Describes a solid fill of a background */
    _: 'backgroundFillSolid',
    /** A color of the background in the RGB24 format */
    color: number,
  }

  export type backgroundFillSolid$Input = {
    /** Describes a solid fill of a background */
    readonly _: 'backgroundFillSolid',
    /** A color of the background in the RGB24 format */
    readonly color?: number,
  }

  export type backgroundFillGradient = {
    /** Describes a gradient fill of a background */
    _: 'backgroundFillGradient',
    /** A top color of the background in the RGB24 format */
    top_color: number,
    /** A bottom color of the background in the RGB24 format */
    bottom_color: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must be always
     * divisible by 45
     */
    rotation_angle: number,
  }

  export type backgroundFillGradient$Input = {
    /** Describes a gradient fill of a background */
    readonly _: 'backgroundFillGradient',
    /** A top color of the background in the RGB24 format */
    readonly top_color?: number,
    /** A bottom color of the background in the RGB24 format */
    readonly bottom_color?: number,
    /**
     * Clockwise rotation angle of the gradient, in degrees; 0-359. Must be always
     * divisible by 45
     */
    readonly rotation_angle?: number,
  }

  export type backgroundFillFreeformGradient = {
    /** Describes a freeform gradient fill of a background */
    _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
    colors: Array<number>,
  }

  export type backgroundFillFreeformGradient$Input = {
    /** Describes a freeform gradient fill of a background */
    readonly _: 'backgroundFillFreeformGradient',
    /** A list of 3 or 4 colors of the freeform gradients in the RGB24 format */
    readonly colors?: ReadonlyArray<number>,
  }

  export type backgroundTypeWallpaper = {
    /** A wallpaper in JPEG format */
    _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    is_blurred: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypeWallpaper$Input = {
    /** A wallpaper in JPEG format */
    readonly _: 'backgroundTypeWallpaper',
    /**
     * True, if the wallpaper must be downscaled to fit in 450x450 square and then
     * box-blurred with radius 12
     */
    readonly is_blurred?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypePattern = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    _: 'backgroundTypePattern',
    /** Fill of the background */
    fill: BackgroundFill,
    /** Intensity of the pattern when it is shown above the filled background; 0-100. */
    intensity: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    is_inverted: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    is_moving: boolean,
  }

  export type backgroundTypePattern$Input = {
    /**
     * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern")
     * pattern to be combined with the background fill chosen by the user
     */
    readonly _: 'backgroundTypePattern',
    /** Fill of the background */
    readonly fill?: BackgroundFill$Input,
    /** Intensity of the pattern when it is shown above the filled background; 0-100. */
    readonly intensity?: number,
    /**
     * True, if the background fill must be applied only to the pattern itself. All
     * other pixels are black in this case. For dark themes only
     */
    readonly is_inverted?: boolean,
    /** True, if the background needs to be slightly moved when device is tilted */
    readonly is_moving?: boolean,
  }

  export type backgroundTypeFill = {
    /** A filled background */
    _: 'backgroundTypeFill',
    /** The background fill */
    fill: BackgroundFill,
  }

  export type backgroundTypeFill$Input = {
    /** A filled background */
    readonly _: 'backgroundTypeFill',
    /** The background fill */
    readonly fill?: BackgroundFill$Input,
  }

  export type background = {
    /** Describes a chat background */
    _: 'background',
    /** Unique background identifier */
    id: number | string,
    /** True, if this is one of default backgrounds */
    is_default: boolean,
    /** True, if the background is dark and is recommended to be used with dark theme */
    is_dark: boolean,
    /** Unique background name */
    name: string,
    /** Document with the background; may be null. Null only for filled backgrounds */
    document?: document,
    /** Type of the background */
    type: BackgroundType,
  }

  export type backgrounds = {
    /** Contains a list of backgrounds */
    _: 'backgrounds',
    /** A list of backgrounds */
    backgrounds: Array<background>,
  }

  export type inputBackgroundLocal$Input = {
    /** A background from a local file */
    readonly _: 'inputBackgroundLocal',
    /**
     * Background file to use. Only inputFileLocal and inputFileGenerated are supported.
     * The file must be in JPEG format for wallpapers and in PNG format for patterns
     */
    readonly background?: InputFile$Input,
  }

  export type inputBackgroundRemote$Input = {
    /** A background from the server */
    readonly _: 'inputBackgroundRemote',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type themeSettings = {
    /** Describes theme settings */
    _: 'themeSettings',
    /** Theme accent color in ARGB format */
    accent_color: number,
    /** The background to be used in chats; may be null */
    background?: background,
    /** The fill to be used as a background for outgoing messages */
    outgoing_message_fill: BackgroundFill,
    /** If true, the freeform gradient fill needs to be animated on every sent message */
    animate_outgoing_message_fill: boolean,
    /** Accent color of outgoing messages in ARGB format */
    outgoing_message_accent_color: number,
  }

  export type chatTheme = {
    /** Describes a chat theme */
    _: 'chatTheme',
    /** Theme name */
    name: string,
    /** Theme settings for a light chat theme */
    light_settings: themeSettings,
    /** Theme settings for a dark chat theme */
    dark_settings: themeSettings,
  }

  export type hashtags = {
    /** Contains a list of hashtags */
    _: 'hashtags',
    /** A list of hashtags */
    hashtags: Array<string>,
  }

  export type canTransferOwnershipResultOk = {
    /** The session can be used */
    _: 'canTransferOwnershipResultOk',
  }

  export type canTransferOwnershipResultPasswordNeeded = {
    /** The 2-step verification needs to be enabled first */
    _: 'canTransferOwnershipResultPasswordNeeded',
  }

  export type canTransferOwnershipResultPasswordTooFresh = {
    /** The 2-step verification was enabled recently, user needs to wait */
    _: 'canTransferOwnershipResultPasswordTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type canTransferOwnershipResultSessionTooFresh = {
    /** The session was created recently, user needs to wait */
    _: 'canTransferOwnershipResultSessionTooFresh',
    /**
     * Time left before the session can be used to transfer ownership of a chat, in
     * seconds
     */
    retry_after: number,
  }

  export type checkChatUsernameResultOk = {
    /** The username can be set */
    _: 'checkChatUsernameResultOk',
  }

  export type checkChatUsernameResultUsernameInvalid = {
    /** The username is invalid */
    _: 'checkChatUsernameResultUsernameInvalid',
  }

  export type checkChatUsernameResultUsernameOccupied = {
    /** The username is occupied */
    _: 'checkChatUsernameResultUsernameOccupied',
  }

  export type checkChatUsernameResultPublicChatsTooMuch = {
    /**
     * The user has too much chats with username, one of them must be made private
     * first
     */
    _: 'checkChatUsernameResultPublicChatsTooMuch',
  }

  export type checkChatUsernameResultPublicGroupsUnavailable = {
    /** The user can't be a member of a public supergroup */
    _: 'checkChatUsernameResultPublicGroupsUnavailable',
  }

  export type checkStickerSetNameResultOk = {
    /** The name can be set */
    _: 'checkStickerSetNameResultOk',
  }

  export type checkStickerSetNameResultNameInvalid = {
    /** The name is invalid */
    _: 'checkStickerSetNameResultNameInvalid',
  }

  export type checkStickerSetNameResultNameOccupied = {
    /** The name is occupied */
    _: 'checkStickerSetNameResultNameOccupied',
  }

  export type resetPasswordResultOk = {
    /** The password was reset */
    _: 'resetPasswordResultOk',
  }

  export type resetPasswordResultPending = {
    /** The password reset request is pending */
    _: 'resetPasswordResultPending',
    /**
     * Point in time (Unix timestamp) after which the password can be reset immediately
     * using resetPassword
     */
    pending_reset_date: number,
  }

  export type resetPasswordResultDeclined = {
    /** The password reset request was declined */
    _: 'resetPasswordResultDeclined',
    /** Point in time (Unix timestamp) when the password reset can be retried */
    retry_date: number,
  }

  export type messageFileTypePrivate = {
    /** The messages was exported from a private chat */
    _: 'messageFileTypePrivate',
    /** Name of the other party; may be empty if unrecognized */
    name: string,
  }

  export type messageFileTypeGroup = {
    /** The messages was exported from a group chat */
    _: 'messageFileTypeGroup',
    /** Title of the group chat; may be empty if unrecognized */
    title: string,
  }

  export type messageFileTypeUnknown = {
    /** The messages was exported from a chat of unknown type */
    _: 'messageFileTypeUnknown',
  }

  export type pushMessageContentHidden = {
    /** A general message with hidden content */
    _: 'pushMessageContentHidden',
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAnimation = {
    /** An animation message (GIF-style). */
    _: 'pushMessageContentAnimation',
    /** Message content; may be null */
    animation?: animation,
    /** Animation caption */
    caption: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentAudio = {
    /** An audio message */
    _: 'pushMessageContentAudio',
    /** Message content; may be null */
    audio?: audio,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContact = {
    /** A message with a user contact */
    _: 'pushMessageContentContact',
    /** Contact's name */
    name: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentContactRegistered = {
    /** A contact has registered with Telegram */
    _: 'pushMessageContentContactRegistered',
  }

  export type pushMessageContentDocument = {
    /** A document message (a general file) */
    _: 'pushMessageContentDocument',
    /** Message content; may be null */
    document?: document,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGame = {
    /** A message with a game */
    _: 'pushMessageContentGame',
    /** Game title, empty for pinned game message */
    title: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentGameScore = {
    /** A new high score was achieved in a game */
    _: 'pushMessageContentGameScore',
    /** Game title, empty for pinned message */
    title: string,
    /** New score, 0 for pinned message */
    score: number,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentInvoice = {
    /** A message with an invoice from a bot */
    _: 'pushMessageContentInvoice',
    /** Product price */
    price: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentLocation = {
    /** A message with a location */
    _: 'pushMessageContentLocation',
    /** True, if the location is live */
    is_live: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPhoto = {
    /** A photo message */
    _: 'pushMessageContentPhoto',
    /** Message content; may be null */
    photo?: photo,
    /** Photo caption */
    caption: string,
    /** True, if the photo is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentPoll = {
    /** A message with a poll */
    _: 'pushMessageContentPoll',
    /** Poll question */
    question: string,
    /** True, if the poll is regular and not in quiz mode */
    is_regular: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentScreenshotTaken = {
    /** A screenshot of a message in the chat has been taken */
    _: 'pushMessageContentScreenshotTaken',
  }

  export type pushMessageContentSticker = {
    /** A message with a sticker */
    _: 'pushMessageContentSticker',
    /** Message content; may be null */
    sticker?: sticker,
    /** Emoji corresponding to the sticker; may be empty */
    emoji: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentText = {
    /** A text message */
    _: 'pushMessageContentText',
    /** Message text */
    text: string,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideo = {
    /** A video message */
    _: 'pushMessageContentVideo',
    /** Message content; may be null */
    video?: video,
    /** Video caption */
    caption: string,
    /** True, if the video is secret */
    is_secret: boolean,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVideoNote = {
    /** A video note message */
    _: 'pushMessageContentVideoNote',
    /** Message content; may be null */
    video_note?: videoNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentVoiceNote = {
    /** A voice note message */
    _: 'pushMessageContentVoiceNote',
    /** Message content; may be null */
    voice_note?: voiceNote,
    /** True, if the message is a pinned message with the specified content */
    is_pinned: boolean,
  }

  export type pushMessageContentBasicGroupChatCreate = {
    /** A newly created basic group */
    _: 'pushMessageContentBasicGroupChatCreate',
  }

  export type pushMessageContentChatAddMembers = {
    /** New chat members were invited to a group */
    _: 'pushMessageContentChatAddMembers',
    /** Name of the added member */
    member_name: string,
    /** True, if the current user was added to the group */
    is_current_user: boolean,
    /** True, if the user has returned to the group themselves */
    is_returned: boolean,
  }

  export type pushMessageContentChatChangePhoto = {
    /** A chat photo was edited */
    _: 'pushMessageContentChatChangePhoto',
  }

  export type pushMessageContentChatChangeTitle = {
    /** A chat title was edited */
    _: 'pushMessageContentChatChangeTitle',
    /** New chat title */
    title: string,
  }

  export type pushMessageContentChatSetTheme = {
    /** A chat theme was edited */
    _: 'pushMessageContentChatSetTheme',
    /**
     * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was
     * reset to the default one
     */
    theme_name: string,
  }

  export type pushMessageContentChatDeleteMember = {
    /** A chat member was deleted */
    _: 'pushMessageContentChatDeleteMember',
    /** Name of the deleted member */
    member_name: string,
    /** True, if the current user was deleted from the group */
    is_current_user: boolean,
    /** True, if the user has left the group themselves */
    is_left: boolean,
  }

  export type pushMessageContentChatJoinByLink = {
    /** A new member joined the chat via an invite link */
    _: 'pushMessageContentChatJoinByLink',
  }

  export type pushMessageContentChatJoinByRequest = {
    /** A new member was accepted to the chat by an administrator */
    _: 'pushMessageContentChatJoinByRequest',
  }

  export type pushMessageContentMessageForwards = {
    /** A forwarded messages */
    _: 'pushMessageContentMessageForwards',
    /** Number of forwarded messages */
    total_count: number,
  }

  export type pushMessageContentMediaAlbum = {
    /** A media album */
    _: 'pushMessageContentMediaAlbum',
    /** Number of messages in the album */
    total_count: number,
    /** True, if the album has at least one photo */
    has_photos: boolean,
    /** True, if the album has at least one video */
    has_videos: boolean,
    /** True, if the album has at least one audio file */
    has_audios: boolean,
    /** True, if the album has at least one document */
    has_documents: boolean,
  }

  export type notificationTypeNewMessage = {
    /** New message was received */
    _: 'notificationTypeNewMessage',
    /** The message */
    message: message,
  }

  export type notificationTypeNewSecretChat = {
    /** New secret chat was created */
    _: 'notificationTypeNewSecretChat',
  }

  export type notificationTypeNewCall = {
    /** New call was received */
    _: 'notificationTypeNewCall',
    /** Call identifier */
    call_id: number,
  }

  export type notificationTypeNewPushMessage = {
    /** New message was received through a push notification */
    _: 'notificationTypeNewPushMessage',
    /**
     * The message identifier. The message will not be available in the chat history,
     * but the ID can be used in viewMessages, or as reply_to_message_id
     */
    message_id: number,
    /** Identifier of the sender of the message. Corresponding user or chat may be inaccessible */
    sender_id: MessageSender,
    /** Name of the sender */
    sender_name: string,
    /** True, if the message is outgoing */
    is_outgoing: boolean,
    /** Push message content */
    content: PushMessageContent,
  }

  export type notificationGroupTypeMessages = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with ordinary unread messages
     */
    _: 'notificationGroupTypeMessages',
  }

  export type notificationGroupTypeMentions = {
    /**
     * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage
     * with unread mentions of the current user, replies to their messages, or a pinned
     * message
     */
    _: 'notificationGroupTypeMentions',
  }

  export type notificationGroupTypeSecretChat = {
    /** A group containing a notification of type notificationTypeNewSecretChat */
    _: 'notificationGroupTypeSecretChat',
  }

  export type notificationGroupTypeCalls = {
    /** A group containing notifications of type notificationTypeNewCall */
    _: 'notificationGroupTypeCalls',
  }

  export type notification = {
    /** Contains information about a notification */
    _: 'notification',
    /** Unique persistent identifier of this notification */
    id: number,
    /** Notification date */
    date: number,
    /** True, if the notification was initially silent */
    is_silent: boolean,
    /** Notification type */
    type: NotificationType,
  }

  export type notificationGroup = {
    /** Describes a group of notifications */
    _: 'notificationGroup',
    /** Unique persistent auto-incremented from 1 identifier of the notification group */
    id: number,
    /** Type of the group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Total number of active notifications in the group */
    total_count: number,
    /** The list of active notifications */
    notifications: Array<notification>,
  }

  export type optionValueBoolean = {
    /** Represents a boolean option */
    _: 'optionValueBoolean',
    /** The value of the option */
    value: boolean,
  }

  export type optionValueBoolean$Input = {
    /** Represents a boolean option */
    readonly _: 'optionValueBoolean',
    /** The value of the option */
    readonly value?: boolean,
  }

  export type optionValueEmpty = {
    /** Represents an unknown option or an option which has a default value */
    _: 'optionValueEmpty',
  }

  export type optionValueEmpty$Input = {
    /** Represents an unknown option or an option which has a default value */
    readonly _: 'optionValueEmpty',
  }

  export type optionValueInteger = {
    /** Represents an integer option */
    _: 'optionValueInteger',
    /** The value of the option */
    value: number | string,
  }

  export type optionValueInteger$Input = {
    /** Represents an integer option */
    readonly _: 'optionValueInteger',
    /** The value of the option */
    readonly value?: number | string,
  }

  export type optionValueString = {
    /** Represents a string option */
    _: 'optionValueString',
    /** The value of the option */
    value: string,
  }

  export type optionValueString$Input = {
    /** Represents a string option */
    readonly _: 'optionValueString',
    /** The value of the option */
    readonly value?: string,
  }

  export type jsonObjectMember = {
    /** Represents one member of a JSON object */
    _: 'jsonObjectMember',
    /** Member's key */
    key: string,
    /** Member's value */
    value: JsonValue,
  }

  export type jsonObjectMember$Input = {
    /** Represents one member of a JSON object */
    readonly _: 'jsonObjectMember',
    /** Member's key */
    readonly key?: string,
    /** Member's value */
    readonly value?: JsonValue$Input,
  }

  export type jsonValueNull = {
    /** Represents a null JSON value */
    _: 'jsonValueNull',
  }

  export type jsonValueNull$Input = {
    /** Represents a null JSON value */
    readonly _: 'jsonValueNull',
  }

  export type jsonValueBoolean = {
    /** Represents a boolean JSON value */
    _: 'jsonValueBoolean',
    /** The value */
    value: boolean,
  }

  export type jsonValueBoolean$Input = {
    /** Represents a boolean JSON value */
    readonly _: 'jsonValueBoolean',
    /** The value */
    readonly value?: boolean,
  }

  export type jsonValueNumber = {
    /** Represents a numeric JSON value */
    _: 'jsonValueNumber',
    /** The value */
    value: number,
  }

  export type jsonValueNumber$Input = {
    /** Represents a numeric JSON value */
    readonly _: 'jsonValueNumber',
    /** The value */
    readonly value?: number,
  }

  export type jsonValueString = {
    /** Represents a string JSON value */
    _: 'jsonValueString',
    /** The value */
    value: string,
  }

  export type jsonValueString$Input = {
    /** Represents a string JSON value */
    readonly _: 'jsonValueString',
    /** The value */
    readonly value?: string,
  }

  export type jsonValueArray = {
    /** Represents a JSON array */
    _: 'jsonValueArray',
    /** The list of array elements */
    values: Array<JsonValue>,
  }

  export type jsonValueArray$Input = {
    /** Represents a JSON array */
    readonly _: 'jsonValueArray',
    /** The list of array elements */
    readonly values?: ReadonlyArray<JsonValue$Input>,
  }

  export type jsonValueObject = {
    /** Represents a JSON object */
    _: 'jsonValueObject',
    /** The list of object members */
    members: Array<jsonObjectMember>,
  }

  export type jsonValueObject$Input = {
    /** Represents a JSON object */
    readonly _: 'jsonValueObject',
    /** The list of object members */
    readonly members?: ReadonlyArray<jsonObjectMember$Input>,
  }

  export type userPrivacySettingRuleAllowAll = {
    /** A rule to allow all users to do something */
    _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowAll$Input = {
    /** A rule to allow all users to do something */
    readonly _: 'userPrivacySettingRuleAllowAll',
  }

  export type userPrivacySettingRuleAllowContacts = {
    /** A rule to allow all of a user's contacts to do something */
    _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowContacts$Input = {
    /** A rule to allow all of a user's contacts to do something */
    readonly _: 'userPrivacySettingRuleAllowContacts',
  }

  export type userPrivacySettingRuleAllowUsers = {
    /** A rule to allow certain specified users to do something */
    _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowUsers$Input = {
    /** A rule to allow certain specified users to do something */
    readonly _: 'userPrivacySettingRuleAllowUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleAllowChatMembers$Input = {
    /**
     * A rule to allow all members of certain specified basic groups and supergroups
     * to doing something
     */
    readonly _: 'userPrivacySettingRuleAllowChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictAll = {
    /** A rule to restrict all users from doing something */
    _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictAll$Input = {
    /** A rule to restrict all users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictAll',
  }

  export type userPrivacySettingRuleRestrictContacts = {
    /** A rule to restrict all contacts of a user from doing something */
    _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictContacts$Input = {
    /** A rule to restrict all contacts of a user from doing something */
    readonly _: 'userPrivacySettingRuleRestrictContacts',
  }

  export type userPrivacySettingRuleRestrictUsers = {
    /** A rule to restrict all specified users from doing something */
    _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    user_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictUsers$Input = {
    /** A rule to restrict all specified users from doing something */
    readonly _: 'userPrivacySettingRuleRestrictUsers',
    /** The user identifiers, total number of users in all rules must not exceed 1000 */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    chat_ids: Array<number>,
  }

  export type userPrivacySettingRuleRestrictChatMembers$Input = {
    /**
     * A rule to restrict all members of specified basic groups and supergroups from
     * doing something
     */
    readonly _: 'userPrivacySettingRuleRestrictChatMembers',
    /** The chat identifiers, total number of chats in all rules must not exceed 20 */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type userPrivacySettingRules = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    _: 'userPrivacySettingRules',
    /** A list of rules */
    rules: Array<UserPrivacySettingRule>,
  }

  export type userPrivacySettingRules$Input = {
    /**
     * A list of privacy rules. Rules are matched in the specified order. The first
     * matched rule defines the privacy setting for a given user. If no rule matches,
     * the action is not allowed
     */
    readonly _: 'userPrivacySettingRules',
    /** A list of rules */
    readonly rules?: ReadonlyArray<UserPrivacySettingRule$Input>,
  }

  export type userPrivacySettingShowStatus = {
    /** A privacy setting for managing whether the user's online status is visible */
    _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowStatus$Input = {
    /** A privacy setting for managing whether the user's online status is visible */
    readonly _: 'userPrivacySettingShowStatus',
  }

  export type userPrivacySettingShowProfilePhoto = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowProfilePhoto$Input = {
    /** A privacy setting for managing whether the user's profile photo is visible */
    readonly _: 'userPrivacySettingShowProfilePhoto',
  }

  export type userPrivacySettingShowLinkInForwardedMessages = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowLinkInForwardedMessages$Input = {
    /**
     * A privacy setting for managing whether a link to the user's account is included
     * in forwarded messages
     */
    readonly _: 'userPrivacySettingShowLinkInForwardedMessages',
  }

  export type userPrivacySettingShowPhoneNumber = {
    /** A privacy setting for managing whether the user's phone number is visible */
    _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingShowPhoneNumber$Input = {
    /** A privacy setting for managing whether the user's phone number is visible */
    readonly _: 'userPrivacySettingShowPhoneNumber',
  }

  export type userPrivacySettingAllowChatInvites = {
    /** A privacy setting for managing whether the user can be invited to chats */
    _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowChatInvites$Input = {
    /** A privacy setting for managing whether the user can be invited to chats */
    readonly _: 'userPrivacySettingAllowChatInvites',
  }

  export type userPrivacySettingAllowCalls = {
    /** A privacy setting for managing whether the user can be called */
    _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowCalls$Input = {
    /** A privacy setting for managing whether the user can be called */
    readonly _: 'userPrivacySettingAllowCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowPeerToPeerCalls$Input = {
    /**
     * A privacy setting for managing whether peer-to-peer connections can be used
     * for calls
     */
    readonly _: 'userPrivacySettingAllowPeerToPeerCalls',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
    /**
     * A privacy setting for managing whether the user can be found by their phone
     * number. Checked only if the phone number is not known to the other user. Can
     * be set only to "Allow contacts" or "Allow all"
     */
    readonly _: 'userPrivacySettingAllowFindingByPhoneNumber',
  }

  export type accountTtl = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-366 days
     */
    days: number,
  }

  export type accountTtl$Input = {
    /**
     * Contains information about the period of inactivity after which the current
     * user's account will automatically be deleted
     */
    readonly _: 'accountTtl',
    /**
     * Number of days of inactivity before the account will be flagged for deletion;
     * 30-366 days
     */
    readonly days?: number,
  }

  export type session = {
    /**
     * Contains information about one session in a Telegram application used by the
     * current user. Sessions must be shown to the user in the returned order
     */
    _: 'session',
    /** Session identifier */
    id: number | string,
    /** True, if this session is the current session */
    is_current: boolean,
    /** True, if a password is needed to complete authorization of the session */
    is_password_pending: boolean,
    /** True, if incoming secret chats can be accepted by the session */
    can_accept_secret_chats: boolean,
    /** True, if incoming calls can be accepted by the session */
    can_accept_calls: boolean,
    /** Telegram API identifier, as provided by the application */
    api_id: number,
    /** Name of the application, as provided by the application */
    application_name: string,
    /** The version of the application, as provided by the application */
    application_version: string,
    /**
     * True, if the application is an official application or uses the api_id of an
     * official application
     */
    is_official_application: boolean,
    /**
     * Model of the device the application has been run or is running on, as provided
     * by the application
     */
    device_model: string,
    /**
     * Operating system the application has been run or is running on, as provided
     * by the application
     */
    platform: string,
    /**
     * Version of the operating system the application has been run or is running on,
     * as provided by the application
     */
    system_version: string,
    /** Point in time (Unix timestamp) when the user has logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when the session was last used */
    last_active_date: number,
    /** IP address from which the session was created, in human-readable format */
    ip: string,
    /**
     * A two-letter country code for the country from which the session was created,
     * based on the IP address
     */
    country: string,
    /** Region code from which the session was created, based on the IP address */
    region: string,
  }

  export type sessions = {
    /** Contains a list of sessions */
    _: 'sessions',
    /** List of sessions */
    sessions: Array<session>,
    /**
     * Number of days of inactivity before sessions will automatically be terminated;
     * 1-366 days
     */
    inactive_session_ttl_days: number,
  }

  export type connectedWebsite = {
    /** Contains information about one website the current user is logged in with Telegram */
    _: 'connectedWebsite',
    /** Website identifier */
    id: number | string,
    /** The domain name of the website */
    domain_name: string,
    /** User identifier of a bot linked with the website */
    bot_user_id: number,
    /** The version of a browser used to log in */
    browser: string,
    /** Operating system the browser is running on */
    platform: string,
    /** Point in time (Unix timestamp) when the user was logged in */
    log_in_date: number,
    /** Point in time (Unix timestamp) when obtained authorization was last used */
    last_active_date: number,
    /** IP address from which the user was logged in, in human-readable format */
    ip: string,
    /**
     * Human-readable description of a country and a region, from which the user was
     * logged in, based on the IP address
     */
    location: string,
  }

  export type connectedWebsites = {
    /** Contains a list of websites the current user is logged in with Telegram */
    _: 'connectedWebsites',
    /** List of connected websites */
    websites: Array<connectedWebsite>,
  }

  export type chatReportReasonSpam$Input = {
    /** The chat contains spam messages */
    readonly _: 'chatReportReasonSpam',
  }

  export type chatReportReasonViolence$Input = {
    /** The chat promotes violence */
    readonly _: 'chatReportReasonViolence',
  }

  export type chatReportReasonPornography$Input = {
    /** The chat contains pornographic messages */
    readonly _: 'chatReportReasonPornography',
  }

  export type chatReportReasonChildAbuse$Input = {
    /** The chat has child abuse related content */
    readonly _: 'chatReportReasonChildAbuse',
  }

  export type chatReportReasonCopyright$Input = {
    /** The chat contains copyrighted content */
    readonly _: 'chatReportReasonCopyright',
  }

  export type chatReportReasonUnrelatedLocation$Input = {
    /** The location-based chat is unrelated to its stated location */
    readonly _: 'chatReportReasonUnrelatedLocation',
  }

  export type chatReportReasonFake$Input = {
    /** The chat represents a fake account */
    readonly _: 'chatReportReasonFake',
  }

  export type chatReportReasonCustom$Input = {
    /** A custom reason provided by the user */
    readonly _: 'chatReportReasonCustom',
  }

  export type internalLinkTypeActiveSessions = {
    /**
     * The link is a link to the active sessions section of the app. Use getActiveSessions
     * to handle the link
     */
    _: 'internalLinkTypeActiveSessions',
  }

  export type internalLinkTypeAuthenticationCode = {
    /**
     * The link contains an authentication code. Call checkAuthenticationCode with
     * the code if the current authorization state is authorizationStateWaitCode
     */
    _: 'internalLinkTypeAuthenticationCode',
    /** The authentication code */
    code: string,
  }

  export type internalLinkTypeBackground = {
    /**
     * The link is a link to a background. Call searchBackground with the given background
     * name to process the link
     */
    _: 'internalLinkTypeBackground',
    /** Name of the background */
    background_name: string,
  }

  export type internalLinkTypeBotStart = {
    /**
     * The link is a link to a chat with a Telegram bot. Call searchPublicChat with
     * the given bot username, check that the user is a bot, show START button in the
     * chat with the bot, and then call sendBotStartMessage with the given start parameter
     * after the button is pressed
     */
    _: 'internalLinkTypeBotStart',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
  }

  export type internalLinkTypeBotStartInGroup = {
    /**
     * The link is a link to a Telegram bot, which is supposed to be added to a group
     * chat. Call searchPublicChat with the given bot username, check that the user
     * is a bot and can be added to groups, ask the current user to select a group
     * to add the bot to, and then call sendBotStartMessage with the given start parameter
     * and the chosen group chat. Bots can be added to a public group only by administrators
     * of the group
     */
    _: 'internalLinkTypeBotStartInGroup',
    /** Username of the bot */
    bot_username: string,
    /** The parameter to be passed to sendBotStartMessage */
    start_parameter: string,
  }

  export type internalLinkTypeChangePhoneNumber = {
    /** The link is a link to the change phone number section of the app */
    _: 'internalLinkTypeChangePhoneNumber',
  }

  export type internalLinkTypeChatInvite = {
    /**
     * The link is a chat invite link. Call checkChatInviteLink with the given invite
     * link to process the link
     */
    _: 'internalLinkTypeChatInvite',
    /** Internal representation of the invite link */
    invite_link: string,
  }

  export type internalLinkTypeFilterSettings = {
    /** The link is a link to the filter settings section of the app */
    _: 'internalLinkTypeFilterSettings',
  }

  export type internalLinkTypeGame = {
    /**
     * The link is a link to a game. Call searchPublicChat with the given bot username,
     * check that the user is a bot, ask the current user to select a chat to send
     * the game, and then call sendMessage with inputMessageGame
     */
    _: 'internalLinkTypeGame',
    /** Username of the bot that owns the game */
    bot_username: string,
    /** Short name of the game */
    game_short_name: string,
  }

  export type internalLinkTypeLanguagePack = {
    /**
     * The link is a link to a language pack. Call getLanguagePackInfo with the given
     * language pack identifier to process the link
     */
    _: 'internalLinkTypeLanguagePack',
    /** Language pack identifier */
    language_pack_id: string,
  }

  export type internalLinkTypeMessage = {
    /**
     * The link is a link to a Telegram message. Call getMessageLinkInfo with the given
     * URL to process the link
     */
    _: 'internalLinkTypeMessage',
    /** URL to be passed to getMessageLinkInfo */
    url: string,
  }

  export type internalLinkTypeMessageDraft = {
    /**
     * The link contains a message draft text. A share screen needs to be shown to
     * the user, then the chosen chat must be opened and the text is added to the input
     * field
     */
    _: 'internalLinkTypeMessageDraft',
    /** Message draft text */
    text: formattedText,
    /**
     * True, if the first line of the text contains a link. If true, the input field
     * needs to be focused and the text after the link must be selected
     */
    contains_link: boolean,
  }

  export type internalLinkTypePassportDataRequest = {
    /**
     * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm
     * with the given parameters to process the link if the link was received from
     * outside of the app, otherwise ignore it
     */
    _: 'internalLinkTypePassportDataRequest',
    /** User identifier of the service's bot */
    bot_user_id: number,
    /** Telegram Passport element types requested by the service */
    scope: string,
    /** Service's public key */
    public_key: string,
    /** Unique request identifier provided by the service */
    nonce: string,
    /**
     * An HTTP URL to open once the request is finished or canceled with the parameter
     * tg_passport=success or tg_passport=cancel respectively. If empty, then the link
     * tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel
     * needs to be opened instead
     */
    callback_url: string,
  }

  export type internalLinkTypePhoneNumberConfirmation = {
    /**
     * The link can be used to confirm ownership of a phone number to prevent account
     * deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone
     * number to process the link
     */
    _: 'internalLinkTypePhoneNumberConfirmation',
    /** Hash value from the link */
    hash: string,
    /** Phone number value from the link */
    phone_number: string,
  }

  export type internalLinkTypeProxy = {
    /**
     * The link is a link to a proxy. Call addProxy with the given parameters to process
     * the link and add the proxy
     */
    _: 'internalLinkTypeProxy',
    /** Proxy server IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type internalLinkTypePublicChat = {
    /**
     * The link is a link to a chat by its username. Call searchPublicChat with the
     * given chat username to process the link
     */
    _: 'internalLinkTypePublicChat',
    /** Username of the chat */
    chat_username: string,
  }

  export type internalLinkTypeQrCodeAuthentication = {
    /**
     * The link can be used to login the current user on another device, but it must
     * be scanned from QR-code using in-app camera. An alert similar to "This code
     * can be used to allow someone to log in to your Telegram account. To confirm
     * Telegram login, please go to Settings > Devices > Scan QR and scan the code"
     * needs to be shown
     */
    _: 'internalLinkTypeQrCodeAuthentication',
  }

  export type internalLinkTypeSettings = {
    /** The link is a link to app settings */
    _: 'internalLinkTypeSettings',
  }

  export type internalLinkTypeStickerSet = {
    /**
     * The link is a link to a sticker set. Call searchStickerSet with the given sticker
     * set name to process the link and show the sticker set
     */
    _: 'internalLinkTypeStickerSet',
    /** Name of the sticker set */
    sticker_set_name: string,
  }

  export type internalLinkTypeTheme = {
    /** The link is a link to a theme. TDLib has no theme support yet */
    _: 'internalLinkTypeTheme',
    /** Name of the theme */
    theme_name: string,
  }

  export type internalLinkTypeThemeSettings = {
    /** The link is a link to the theme settings section of the app */
    _: 'internalLinkTypeThemeSettings',
  }

  export type internalLinkTypeUnknownDeepLink = {
    /** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
    _: 'internalLinkTypeUnknownDeepLink',
    /** Link to be passed to getDeepLinkInfo */
    link: string,
  }

  export type internalLinkTypeUnsupportedProxy = {
    /** The link is a link to an unsupported proxy. An alert can be shown to the user */
    _: 'internalLinkTypeUnsupportedProxy',
  }

  export type internalLinkTypeVideoChat = {
    /**
     * The link is a link to a video chat. Call searchPublicChat with the given chat
     * username, and then joinGoupCall with the given invite hash to process the link
     */
    _: 'internalLinkTypeVideoChat',
    /** Username of the chat with the video chat */
    chat_username: string,
    /**
     * If non-empty, invite hash to be used to join the video chat without being muted
     * by administrators
     */
    invite_hash: string,
    /**
     * True, if the video chat is expected to be a live stream in a channel or a broadcast
     * group
     */
    is_live_stream: boolean,
  }

  export type messageLink = {
    /** Contains an HTTPS link to a message in a supergroup or channel */
    _: 'messageLink',
    /** Message link */
    link: string,
    /** True, if the link will work for non-members of the chat */
    is_public: boolean,
  }

  export type messageLinkInfo = {
    /** Contains information about a link to a message in a chat */
    _: 'messageLinkInfo',
    /** True, if the link is a public link for a message in a chat */
    is_public: boolean,
    /** If found, identifier of the chat to which the message belongs, 0 otherwise */
    chat_id: number,
    /** If found, the linked message; may be null */
    message?: message,
    /**
     * Timestamp from which the video/audio/video note/voice note playing must start,
     * in seconds; 0 if not specified. The media can be in the message content or in
     * its web page preview
     */
    media_timestamp: number,
    /** True, if the whole media album to which the message belongs is linked */
    for_album: boolean,
    /** True, if the message is linked as a channel post comment or from a message thread */
    for_comment: boolean,
  }

  export type filePart = {
    /** Contains a part of a file */
    _: 'filePart',
    /** File bytes */
    data: string,
  }

  export type fileTypeNone = {
    /** The data is not a file */
    _: 'fileTypeNone',
  }

  export type fileTypeNone$Input = {
    /** The data is not a file */
    readonly _: 'fileTypeNone',
  }

  export type fileTypeAnimation = {
    /** The file is an animation */
    _: 'fileTypeAnimation',
  }

  export type fileTypeAnimation$Input = {
    /** The file is an animation */
    readonly _: 'fileTypeAnimation',
  }

  export type fileTypeAudio = {
    /** The file is an audio file */
    _: 'fileTypeAudio',
  }

  export type fileTypeAudio$Input = {
    /** The file is an audio file */
    readonly _: 'fileTypeAudio',
  }

  export type fileTypeDocument = {
    /** The file is a document */
    _: 'fileTypeDocument',
  }

  export type fileTypeDocument$Input = {
    /** The file is a document */
    readonly _: 'fileTypeDocument',
  }

  export type fileTypePhoto = {
    /** The file is a photo */
    _: 'fileTypePhoto',
  }

  export type fileTypePhoto$Input = {
    /** The file is a photo */
    readonly _: 'fileTypePhoto',
  }

  export type fileTypeProfilePhoto = {
    /** The file is a profile photo */
    _: 'fileTypeProfilePhoto',
  }

  export type fileTypeProfilePhoto$Input = {
    /** The file is a profile photo */
    readonly _: 'fileTypeProfilePhoto',
  }

  export type fileTypeSecret = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    _: 'fileTypeSecret',
  }

  export type fileTypeSecret$Input = {
    /** The file was sent to a secret chat (the file type is not known to the server) */
    readonly _: 'fileTypeSecret',
  }

  export type fileTypeSecretThumbnail = {
    /** The file is a thumbnail of a file from a secret chat */
    _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecretThumbnail$Input = {
    /** The file is a thumbnail of a file from a secret chat */
    readonly _: 'fileTypeSecretThumbnail',
  }

  export type fileTypeSecure = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    _: 'fileTypeSecure',
  }

  export type fileTypeSecure$Input = {
    /** The file is a file from Secure storage used for storing Telegram Passport files */
    readonly _: 'fileTypeSecure',
  }

  export type fileTypeSticker = {
    /** The file is a sticker */
    _: 'fileTypeSticker',
  }

  export type fileTypeSticker$Input = {
    /** The file is a sticker */
    readonly _: 'fileTypeSticker',
  }

  export type fileTypeThumbnail = {
    /** The file is a thumbnail of another file */
    _: 'fileTypeThumbnail',
  }

  export type fileTypeThumbnail$Input = {
    /** The file is a thumbnail of another file */
    readonly _: 'fileTypeThumbnail',
  }

  export type fileTypeUnknown = {
    /** The file type is not yet known */
    _: 'fileTypeUnknown',
  }

  export type fileTypeUnknown$Input = {
    /** The file type is not yet known */
    readonly _: 'fileTypeUnknown',
  }

  export type fileTypeVideo = {
    /** The file is a video */
    _: 'fileTypeVideo',
  }

  export type fileTypeVideo$Input = {
    /** The file is a video */
    readonly _: 'fileTypeVideo',
  }

  export type fileTypeVideoNote = {
    /** The file is a video note */
    _: 'fileTypeVideoNote',
  }

  export type fileTypeVideoNote$Input = {
    /** The file is a video note */
    readonly _: 'fileTypeVideoNote',
  }

  export type fileTypeVoiceNote = {
    /** The file is a voice note */
    _: 'fileTypeVoiceNote',
  }

  export type fileTypeVoiceNote$Input = {
    /** The file is a voice note */
    readonly _: 'fileTypeVoiceNote',
  }

  export type fileTypeWallpaper = {
    /** The file is a wallpaper or a background pattern */
    _: 'fileTypeWallpaper',
  }

  export type fileTypeWallpaper$Input = {
    /** The file is a wallpaper or a background pattern */
    readonly _: 'fileTypeWallpaper',
  }

  export type storageStatisticsByFileType = {
    /** Contains the storage usage statistics for a specific file type */
    _: 'storageStatisticsByFileType',
    /** File type */
    file_type: FileType,
    /** Total size of the files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
  }

  export type storageStatisticsByChat = {
    /** Contains the storage usage statistics for a specific chat */
    _: 'storageStatisticsByChat',
    /** Chat identifier; 0 if none */
    chat_id: number,
    /** Total size of the files in the chat, in bytes */
    size: number,
    /** Total number of files in the chat */
    count: number,
    /** Statistics split by file types */
    by_file_type: Array<storageStatisticsByFileType>,
  }

  export type storageStatistics = {
    /** Contains the exact storage usage statistics split by chats and file type */
    _: 'storageStatistics',
    /** Total size of files, in bytes */
    size: number,
    /** Total number of files */
    count: number,
    /** Statistics split by chats */
    by_chat: Array<storageStatisticsByChat>,
  }

  export type storageStatisticsFast = {
    /**
     * Contains approximate storage usage statistics, excluding files of unknown file
     * type
     */
    _: 'storageStatisticsFast',
    /** Approximate total size of files, in bytes */
    files_size: number,
    /** Approximate number of files */
    file_count: number,
    /** Size of the database */
    database_size: number,
    /** Size of the language pack database */
    language_pack_database_size: number,
    /** Size of the TDLib internal log */
    log_size: number,
  }

  export type databaseStatistics = {
    /** Contains database statistics */
    _: 'databaseStatistics',
    /** Database statistics in an unspecified human-readable format */
    statistics: string,
  }

  export type networkTypeNone = {
    /** The network is not available */
    _: 'networkTypeNone',
  }

  export type networkTypeNone$Input = {
    /** The network is not available */
    readonly _: 'networkTypeNone',
  }

  export type networkTypeMobile = {
    /** A mobile network */
    _: 'networkTypeMobile',
  }

  export type networkTypeMobile$Input = {
    /** A mobile network */
    readonly _: 'networkTypeMobile',
  }

  export type networkTypeMobileRoaming = {
    /** A mobile roaming network */
    _: 'networkTypeMobileRoaming',
  }

  export type networkTypeMobileRoaming$Input = {
    /** A mobile roaming network */
    readonly _: 'networkTypeMobileRoaming',
  }

  export type networkTypeWiFi = {
    /** A Wi-Fi network */
    _: 'networkTypeWiFi',
  }

  export type networkTypeWiFi$Input = {
    /** A Wi-Fi network */
    readonly _: 'networkTypeWiFi',
  }

  export type networkTypeOther = {
    /** A different network type (e.g., Ethernet network) */
    _: 'networkTypeOther',
  }

  export type networkTypeOther$Input = {
    /** A different network type (e.g., Ethernet network) */
    readonly _: 'networkTypeOther',
  }

  export type networkStatisticsEntryFile = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    file_type: FileType,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
  }

  export type networkStatisticsEntryFile$Input = {
    /**
     * Contains information about the total amount of data that was used to send and
     * receive files
     */
    readonly _: 'networkStatisticsEntryFile',
    /**
     * Type of the file the data is part of; pass null if the data isn't related to
     * files
     */
    readonly file_type?: FileType$Input,
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
  }

  export type networkStatisticsEntryCall = {
    /** Contains information about the total amount of data that was used for calls */
    _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    network_type: NetworkType,
    /** Total number of bytes sent */
    sent_bytes: number,
    /** Total number of bytes received */
    received_bytes: number,
    /** Total call duration, in seconds */
    duration: number,
  }

  export type networkStatisticsEntryCall$Input = {
    /** Contains information about the total amount of data that was used for calls */
    readonly _: 'networkStatisticsEntryCall',
    /**
     * Type of the network the data was sent through. Call setNetworkType to maintain
     * the actual network type
     */
    readonly network_type?: NetworkType$Input,
    /** Total number of bytes sent */
    readonly sent_bytes?: number,
    /** Total number of bytes received */
    readonly received_bytes?: number,
    /** Total call duration, in seconds */
    readonly duration?: number,
  }

  export type networkStatistics = {
    /** A full list of available network statistic entries */
    _: 'networkStatistics',
    /** Point in time (Unix timestamp) from which the statistics are collected */
    since_date: number,
    /** Network statistics entries */
    entries: Array<NetworkStatisticsEntry>,
  }

  export type autoDownloadSettings = {
    /** Contains auto-download settings */
    _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    is_auto_download_enabled: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    max_photo_file_size: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    max_video_file_size: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    max_other_file_size: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    video_upload_bitrate: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    preload_large_videos: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    preload_next_audio: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    use_less_data_for_calls: boolean,
  }

  export type autoDownloadSettings$Input = {
    /** Contains auto-download settings */
    readonly _: 'autoDownloadSettings',
    /** True, if the auto-download is enabled */
    readonly is_auto_download_enabled?: boolean,
    /** The maximum size of a photo file to be auto-downloaded, in bytes */
    readonly max_photo_file_size?: number,
    /** The maximum size of a video file to be auto-downloaded, in bytes */
    readonly max_video_file_size?: number,
    /** The maximum size of other file types to be auto-downloaded, in bytes */
    readonly max_other_file_size?: number,
    /** The maximum suggested bitrate for uploaded videos, in kbit/s */
    readonly video_upload_bitrate?: number,
    /** True, if the beginning of video files needs to be preloaded for instant playback */
    readonly preload_large_videos?: boolean,
    /**
     * True, if the next audio track needs to be preloaded while the user is listening
     * to an audio file
     */
    readonly preload_next_audio?: boolean,
    /** True, if "use less data for calls" option needs to be enabled */
    readonly use_less_data_for_calls?: boolean,
  }

  export type autoDownloadSettingsPresets = {
    /** Contains auto-download settings presets for the current user */
    _: 'autoDownloadSettingsPresets',
    /** Preset with lowest settings; supposed to be used by default when roaming */
    low: autoDownloadSettings,
    /**
     * Preset with medium settings; supposed to be used by default when using mobile
     * data
     */
    medium: autoDownloadSettings,
    /**
     * Preset with highest settings; supposed to be used by default when connected
     * on Wi-Fi
     */
    high: autoDownloadSettings,
  }

  export type connectionStateWaitingForNetwork = {
    /**
     * Currently waiting for the network to become available. Use setNetworkType to
     * change the available network type
     */
    _: 'connectionStateWaitingForNetwork',
  }

  export type connectionStateConnectingToProxy = {
    /** Currently establishing a connection with a proxy server */
    _: 'connectionStateConnectingToProxy',
  }

  export type connectionStateConnecting = {
    /** Currently establishing a connection to the Telegram servers */
    _: 'connectionStateConnecting',
  }

  export type connectionStateUpdating = {
    /** Downloading data received while the application was offline */
    _: 'connectionStateUpdating',
  }

  export type connectionStateReady = {
    /** There is a working connection to the Telegram servers */
    _: 'connectionStateReady',
  }

  export type topChatCategoryUsers$Input = {
    /** A category containing frequently used private chats with non-bot users */
    readonly _: 'topChatCategoryUsers',
  }

  export type topChatCategoryBots$Input = {
    /** A category containing frequently used private chats with bot users */
    readonly _: 'topChatCategoryBots',
  }

  export type topChatCategoryGroups$Input = {
    /** A category containing frequently used basic groups and supergroups */
    readonly _: 'topChatCategoryGroups',
  }

  export type topChatCategoryChannels$Input = {
    /** A category containing frequently used channels */
    readonly _: 'topChatCategoryChannels',
  }

  export type topChatCategoryInlineBots$Input = {
    /**
     * A category containing frequently used chats with inline bots sorted by their
     * usage in inline mode
     */
    readonly _: 'topChatCategoryInlineBots',
  }

  export type topChatCategoryCalls$Input = {
    /** A category containing frequently used chats used for calls */
    readonly _: 'topChatCategoryCalls',
  }

  export type topChatCategoryForwardChats$Input = {
    /** A category containing frequently used chats used to forward messages */
    readonly _: 'topChatCategoryForwardChats',
  }

  export type tMeUrlTypeUser = {
    /** A URL linking to a user */
    _: 'tMeUrlTypeUser',
    /** Identifier of the user */
    user_id: number,
  }

  export type tMeUrlTypeSupergroup = {
    /** A URL linking to a public supergroup or channel */
    _: 'tMeUrlTypeSupergroup',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
  }

  export type tMeUrlTypeChatInvite = {
    /** A chat invite link */
    _: 'tMeUrlTypeChatInvite',
    /** Chat invite link info */
    info: chatInviteLinkInfo,
  }

  export type tMeUrlTypeStickerSet = {
    /** A URL linking to a sticker set */
    _: 'tMeUrlTypeStickerSet',
    /** Identifier of the sticker set */
    sticker_set_id: number | string,
  }

  export type tMeUrl = {
    /** Represents a URL linking to an internal Telegram entity */
    _: 'tMeUrl',
    /** URL */
    url: string,
    /** Type of the URL */
    type: TMeUrlType,
  }

  export type tMeUrls = {
    /** Contains a list of t.me URLs */
    _: 'tMeUrls',
    /** List of URLs */
    urls: Array<tMeUrl>,
  }

  export type suggestedActionEnableArchiveAndMuteNewChats = {
    /**
     * Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users"
     * option
     */
    _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
    /**
     * Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users"
     * option
     */
    readonly _: 'suggestedActionEnableArchiveAndMuteNewChats',
  }

  export type suggestedActionCheckPassword = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPassword$Input = {
    /**
     * Suggests the user to check whether they still remember their 2-step verification
     * password
     */
    readonly _: 'suggestedActionCheckPassword',
  }

  export type suggestedActionCheckPhoneNumber = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionCheckPhoneNumber$Input = {
    /**
     * Suggests the user to check whether authorization phone number is correct and
     * change the phone number if it is inaccessible
     */
    readonly _: 'suggestedActionCheckPhoneNumber',
  }

  export type suggestedActionViewChecksHint = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionViewChecksHint$Input = {
    /**
     * Suggests the user to view a hint about the meaning of one and two check marks
     * on sent messages
     */
    readonly _: 'suggestedActionViewChecksHint',
  }

  export type suggestedActionConvertToBroadcastGroup = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    supergroup_id: number,
  }

  export type suggestedActionConvertToBroadcastGroup$Input = {
    /** Suggests the user to convert specified supergroup to a broadcast group */
    readonly _: 'suggestedActionConvertToBroadcastGroup',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
  }

  export type suggestedActionSetPassword = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password
     */
    authorization_delay: number,
  }

  export type suggestedActionSetPassword$Input = {
    /**
     * Suggests the user to set a 2-step verification password to be able to log in
     * again
     */
    readonly _: 'suggestedActionSetPassword',
    /**
     * The number of days to pass between consecutive authorizations if the user declines
     * to set password
     */
    readonly authorization_delay?: number,
  }

  export type count = {
    /** Contains a counter */
    _: 'count',
    /** Count */
    count: number,
  }

  export type text = {
    /** Contains some text */
    _: 'text',
    /** Text */
    text: string,
  }

  export type seconds = {
    /** Contains a value representing a number of seconds */
    _: 'seconds',
    /** Number of seconds */
    seconds: number,
  }

  export type deepLinkInfo = {
    /** Contains information about a tg: deep link */
    _: 'deepLinkInfo',
    /** Text to be shown to the user */
    text: formattedText,
    /** True, if the user must be asked to update the application */
    need_update_application: boolean,
  }

  export type textParseModeMarkdown$Input = {
    /** The text uses Markdown-style formatting */
    readonly _: 'textParseModeMarkdown',
    /**
     * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 -
     * Telegram Bot API "MarkdownV2" parse mode
     */
    readonly version?: number,
  }

  export type textParseModeHTML$Input = {
    /**
     * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse
     * mode
     */
    readonly _: 'textParseModeHTML',
  }

  export type proxyTypeSocks5 = {
    /** A SOCKS5 proxy server */
    _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
  }

  export type proxyTypeSocks5$Input = {
    /** A SOCKS5 proxy server */
    readonly _: 'proxyTypeSocks5',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
  }

  export type proxyTypeHttp = {
    /** A HTTP transparent proxy server */
    _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    username: string,
    /** Password for logging in; may be empty */
    password: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    http_only: boolean,
  }

  export type proxyTypeHttp$Input = {
    /** A HTTP transparent proxy server */
    readonly _: 'proxyTypeHttp',
    /** Username for logging in; may be empty */
    readonly username?: string,
    /** Password for logging in; may be empty */
    readonly password?: string,
    /**
     * Pass true if the proxy supports only HTTP requests and doesn't support transparent
     * TCP connections via HTTP CONNECT method
     */
    readonly http_only?: boolean,
  }

  export type proxyTypeMtproto = {
    /** An MTProto proxy server */
    _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    secret: string,
  }

  export type proxyTypeMtproto$Input = {
    /** An MTProto proxy server */
    readonly _: 'proxyTypeMtproto',
    /** The proxy's secret in hexadecimal encoding */
    readonly secret?: string,
  }

  export type proxy = {
    /** Contains information about a proxy server */
    _: 'proxy',
    /** Unique identifier of the proxy */
    id: number,
    /** Proxy server IP address */
    server: string,
    /** Proxy server port */
    port: number,
    /** Point in time (Unix timestamp) when the proxy was last used; 0 if never */
    last_used_date: number,
    /** True, if the proxy is enabled now */
    is_enabled: boolean,
    /** Type of the proxy */
    type: ProxyType,
  }

  export type proxies = {
    /** Represents a list of proxy servers */
    _: 'proxies',
    /** List of proxy servers */
    proxies: Array<proxy>,
  }

  export type inputStickerStatic$Input = {
    /** A static sticker in PNG format, which will be converted to WEBP server-side */
    readonly _: 'inputStickerStatic',
    /**
     * PNG image with the sticker; must be up to 512 KB in size and fit in a 512x512
     * square
     */
    readonly sticker?: InputFile$Input,
    /** Emojis corresponding to the sticker */
    readonly emojis?: string,
    /** For masks, position where the mask is placed; pass null if unspecified */
    readonly mask_position?: maskPosition$Input,
  }

  export type inputStickerAnimated$Input = {
    /** An animated sticker in TGS format */
    readonly _: 'inputStickerAnimated',
    /**
     * File with the animated sticker. Only local or uploaded within a week files are
     * supported. See https://core.telegram.org/animated_stickers#technical-requirements
     * for technical requirements
     */
    readonly sticker?: InputFile$Input,
    /** Emojis corresponding to the sticker */
    readonly emojis?: string,
  }

  export type dateRange = {
    /** Represents a date range */
    _: 'dateRange',
    /** Point in time (Unix timestamp) at which the date range begins */
    start_date: number,
    /** Point in time (Unix timestamp) at which the date range ends */
    end_date: number,
  }

  export type statisticalValue = {
    /** A value with information about its recent changes */
    _: 'statisticalValue',
    /** The current value */
    value: number,
    /** The value for the previous day */
    previous_value: number,
    /** The growth rate of the value, as a percentage */
    growth_rate_percentage: number,
  }

  export type statisticalGraphData = {
    /** A graph data */
    _: 'statisticalGraphData',
    /** Graph data in JSON format */
    json_data: string,
    /** If non-empty, a token which can be used to receive a zoomed in graph */
    zoom_token: string,
  }

  export type statisticalGraphAsync = {
    /** The graph data to be asynchronously loaded through getStatisticalGraph */
    _: 'statisticalGraphAsync',
    /** The token to use for data loading */
    token: string,
  }

  export type statisticalGraphError = {
    /** An error message to be shown to the user instead of the graph */
    _: 'statisticalGraphError',
    /** The error message */
    error_message: string,
  }

  export type chatStatisticsMessageInteractionInfo = {
    /** Contains statistics about interactions with a message */
    _: 'chatStatisticsMessageInteractionInfo',
    /** Message identifier */
    message_id: number,
    /** Number of times the message was viewed */
    view_count: number,
    /** Number of times the message was forwarded */
    forward_count: number,
  }

  export type chatStatisticsMessageSenderInfo = {
    /** Contains statistics about messages sent by a user */
    _: 'chatStatisticsMessageSenderInfo',
    /** User identifier */
    user_id: number,
    /** Number of sent messages */
    sent_message_count: number,
    /** Average number of characters in sent messages; 0 if unknown */
    average_character_count: number,
  }

  export type chatStatisticsAdministratorActionsInfo = {
    /** Contains statistics about administrator actions done by a user */
    _: 'chatStatisticsAdministratorActionsInfo',
    /** Administrator user identifier */
    user_id: number,
    /** Number of messages deleted by the administrator */
    deleted_message_count: number,
    /** Number of users banned by the administrator */
    banned_user_count: number,
    /** Number of users restricted by the administrator */
    restricted_user_count: number,
  }

  export type chatStatisticsInviterInfo = {
    /** Contains statistics about number of new members invited by a user */
    _: 'chatStatisticsInviterInfo',
    /** User identifier */
    user_id: number,
    /** Number of new members invited by the user */
    added_member_count: number,
  }

  export type chatStatisticsSupergroup = {
    /** A detailed statistics about a supergroup chat */
    _: 'chatStatisticsSupergroup',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Number of messages sent to the chat */
    message_count: statisticalValue,
    /** Number of users who viewed messages in the chat */
    viewer_count: statisticalValue,
    /** Number of users who sent messages to the chat */
    sender_count: statisticalValue,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing distribution of active users per language */
    language_graph: StatisticalGraph,
    /** A graph containing distribution of sent messages by content type */
    message_content_graph: StatisticalGraph,
    /** A graph containing number of different actions in the chat */
    action_graph: StatisticalGraph,
    /** A graph containing distribution of message views per hour */
    day_graph: StatisticalGraph,
    /** A graph containing distribution of message views per day of week */
    week_graph: StatisticalGraph,
    /** List of users sent most messages in the last week */
    top_senders: Array<chatStatisticsMessageSenderInfo>,
    /** List of most active administrators in the last week */
    top_administrators: Array<chatStatisticsAdministratorActionsInfo>,
    /** List of most active inviters of new members in the last week */
    top_inviters: Array<chatStatisticsInviterInfo>,
  }

  export type chatStatisticsChannel = {
    /** A detailed statistics about a channel chat */
    _: 'chatStatisticsChannel',
    /** A period to which the statistics applies */
    period: dateRange,
    /** Number of members in the chat */
    member_count: statisticalValue,
    /** Mean number of times the recently sent messages was viewed */
    mean_view_count: statisticalValue,
    /** Mean number of times the recently sent messages was shared */
    mean_share_count: statisticalValue,
    /** A percentage of users with enabled notifications for the chat */
    enabled_notifications_percentage: number,
    /** A graph containing number of members in the chat */
    member_count_graph: StatisticalGraph,
    /** A graph containing number of members joined and left the chat */
    join_graph: StatisticalGraph,
    /** A graph containing number of members muted and unmuted the chat */
    mute_graph: StatisticalGraph,
    /** A graph containing number of message views in a given hour in the last two weeks */
    view_count_by_hour_graph: StatisticalGraph,
    /** A graph containing number of message views per source */
    view_count_by_source_graph: StatisticalGraph,
    /** A graph containing number of new member joins per source */
    join_by_source_graph: StatisticalGraph,
    /** A graph containing number of users viewed chat messages per language */
    language_graph: StatisticalGraph,
    /** A graph containing number of chat message views and shares */
    message_interaction_graph: StatisticalGraph,
    /** A graph containing number of views of associated with the chat instant views */
    instant_view_interaction_graph: StatisticalGraph,
    /** Detailed statistics about number of views and shares of recently sent messages */
    recent_message_interactions: Array<chatStatisticsMessageInteractionInfo>,
  }

  export type messageStatistics = {
    /** A detailed statistics about a message */
    _: 'messageStatistics',
    /** A graph containing number of message views and shares */
    message_interaction_graph: StatisticalGraph,
  }

  export type point = {
    /** A point on a Cartesian plane */
    _: 'point',
    /** The point's first coordinate */
    x: number,
    /** The point's second coordinate */
    y: number,
  }

  export type vectorPathCommandLine = {
    /** A straight line to a given point */
    _: 'vectorPathCommandLine',
    /** The end point of the straight line */
    end_point: point,
  }

  export type vectorPathCommandCubicBezierCurve = {
    /** A cubic Bézier curve to a given point */
    _: 'vectorPathCommandCubicBezierCurve',
    /** The start control point of the curve */
    start_control_point: point,
    /** The end control point of the curve */
    end_control_point: point,
    /** The end point of the curve */
    end_point: point,
  }

  export type botCommandScopeDefault$Input = {
    /** A scope covering all users */
    readonly _: 'botCommandScopeDefault',
  }

  export type botCommandScopeAllPrivateChats$Input = {
    /** A scope covering all private chats */
    readonly _: 'botCommandScopeAllPrivateChats',
  }

  export type botCommandScopeAllGroupChats$Input = {
    /** A scope covering all group and supergroup chats */
    readonly _: 'botCommandScopeAllGroupChats',
  }

  export type botCommandScopeAllChatAdministrators$Input = {
    /** A scope covering all group and supergroup chat administrators */
    readonly _: 'botCommandScopeAllChatAdministrators',
  }

  export type botCommandScopeChat$Input = {
    /** A scope covering all members of a chat */
    readonly _: 'botCommandScopeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatAdministrators$Input = {
    /** A scope covering all administrators of a chat */
    readonly _: 'botCommandScopeChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type botCommandScopeChatMember$Input = {
    /** A scope covering a member of a chat */
    readonly _: 'botCommandScopeChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type updateAuthorizationState = {
    /** The user authorization state has changed */
    _: 'updateAuthorizationState',
    /** New authorization state */
    authorization_state: AuthorizationState,
  }

  export type updateNewMessage = {
    /** A new message was received; can also be an outgoing message */
    _: 'updateNewMessage',
    /** The new message */
    message: message,
  }

  export type updateMessageSendAcknowledged = {
    /**
     * A request to send a message has reached the Telegram server. This doesn't mean
     * that the message will be sent successfully or even that the send message request
     * will be processed. This update will be sent only if the option "use_quick_ack"
     * is set to true. This update may be sent multiple times for the same message
     */
    _: 'updateMessageSendAcknowledged',
    /** The chat identifier of the sent message */
    chat_id: number,
    /** A temporary message identifier */
    message_id: number,
  }

  export type updateMessageSendSucceeded = {
    /** A message has been successfully sent */
    _: 'updateMessageSendSucceeded',
    /**
     * The sent message. Usually only the message identifier, date, and content are
     * changed, but almost all other fields can also change
     */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
  }

  export type updateMessageSendFailed = {
    /**
     * A message failed to send. Be aware that some messages being sent can be irrecoverably
     * deleted, in which case updateDeleteMessages will be received instead of this
     * update
     */
    _: 'updateMessageSendFailed',
    /** The failed to send message */
    message: message,
    /** The previous temporary message identifier */
    old_message_id: number,
    /** An error code */
    error_code: number,
    /** Error message */
    error_message: string,
  }

  export type updateMessageContent = {
    /** The message content has changed */
    _: 'updateMessageContent',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New message content */
    new_content: MessageContent,
  }

  export type updateMessageEdited = {
    /**
     * A message was edited. Changes in the message content will come in a separate
     * updateMessageContent
     */
    _: 'updateMessageEdited',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** Point in time (Unix timestamp) when the message was edited */
    edit_date: number,
    /** New message reply markup; may be null */
    reply_markup?: ReplyMarkup,
  }

  export type updateMessageIsPinned = {
    /** The message pinned state was changed */
    _: 'updateMessageIsPinned',
    /** Chat identifier */
    chat_id: number,
    /** The message identifier */
    message_id: number,
    /** True, if the message is pinned */
    is_pinned: boolean,
  }

  export type updateMessageInteractionInfo = {
    /** The information about interactions with a message has changed */
    _: 'updateMessageInteractionInfo',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** New information about interactions with the message; may be null */
    interaction_info?: messageInteractionInfo,
  }

  export type updateMessageContentOpened = {
    /**
     * The message content was opened. Updates voice note messages to "listened", video
     * note messages to "viewed" and starts the TTL timer for self-destructing messages
     */
    _: 'updateMessageContentOpened',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
  }

  export type updateMessageMentionRead = {
    /** A message with an unread mention was read */
    _: 'updateMessageMentionRead',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The new number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateMessageLiveLocationViewed = {
    /**
     * A message with a live location was viewed. When the update is received, the
     * application is supposed to update the live location
     */
    _: 'updateMessageLiveLocationViewed',
    /** Identifier of the chat with the live location message */
    chat_id: number,
    /** Identifier of the message with live location */
    message_id: number,
  }

  export type updateNewChat = {
    /**
     * A new chat has been loaded/created. This update is guaranteed to come before
     * the chat identifier is returned to the application. The chat field changes will
     * be reported through separate updates
     */
    _: 'updateNewChat',
    /** The chat */
    chat: chat,
  }

  export type updateChatTitle = {
    /** The title of a chat was changed */
    _: 'updateChatTitle',
    /** Chat identifier */
    chat_id: number,
    /** The new chat title */
    title: string,
  }

  export type updateChatPhoto = {
    /** A chat photo was changed */
    _: 'updateChatPhoto',
    /** Chat identifier */
    chat_id: number,
    /** The new chat photo; may be null */
    photo?: chatPhotoInfo,
  }

  export type updateChatPermissions = {
    /** Chat permissions was changed */
    _: 'updateChatPermissions',
    /** Chat identifier */
    chat_id: number,
    /** The new chat permissions */
    permissions: chatPermissions,
  }

  export type updateChatLastMessage = {
    /**
     * The last message of a chat was changed. If last_message is null, then the last
     * message in the chat became unknown. Some new unknown messages might be added
     * to the chat in this case
     */
    _: 'updateChatLastMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new last message in the chat; may be null */
    last_message?: message,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatPosition = {
    /**
     * The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage
     * or updateChatDraftMessage might be sent
     */
    _: 'updateChatPosition',
    /** Chat identifier */
    chat_id: number,
    /**
     * New chat position. If new order is 0, then the chat needs to be removed from
     * the list
     */
    position: chatPosition,
  }

  export type updateChatReadInbox = {
    /** Incoming messages were read or the number of unread messages has been changed */
    _: 'updateChatReadInbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the last read incoming message */
    last_read_inbox_message_id: number,
    /** The number of unread messages left in the chat */
    unread_count: number,
  }

  export type updateChatReadOutbox = {
    /** Outgoing messages were read */
    _: 'updateChatReadOutbox',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of last read outgoing message */
    last_read_outbox_message_id: number,
  }

  export type updateChatActionBar = {
    /** The chat action bar was changed */
    _: 'updateChatActionBar',
    /** Chat identifier */
    chat_id: number,
    /** The new value of the action bar; may be null */
    action_bar?: ChatActionBar,
  }

  export type updateChatDraftMessage = {
    /**
     * A chat draft has changed. Be aware that the update may come in the currently
     * opened chat but with old content of the draft. If the user has changed the content
     * of the draft, this update mustn't be applied
     */
    _: 'updateChatDraftMessage',
    /** Chat identifier */
    chat_id: number,
    /** The new draft message; may be null */
    draft_message?: draftMessage,
    /** The new chat positions in the chat lists */
    positions: Array<chatPosition>,
  }

  export type updateChatMessageSender = {
    /** The message sender that is selected to send messages in a chat has changed */
    _: 'updateChatMessageSender',
    /** Chat identifier */
    chat_id: number,
    /**
     * New value of message_sender_id; may be null if the user can't change message
     * sender
     */
    message_sender_id?: MessageSender,
  }

  export type updateChatMessageTtl = {
    /** The message Time To Live setting for a chat was changed */
    _: 'updateChatMessageTtl',
    /** Chat identifier */
    chat_id: number,
    /** New value of message_ttl */
    message_ttl: number,
  }

  export type updateChatNotificationSettings = {
    /** Notification settings for a chat were changed */
    _: 'updateChatNotificationSettings',
    /** Chat identifier */
    chat_id: number,
    /** The new notification settings */
    notification_settings: chatNotificationSettings,
  }

  export type updateChatPendingJoinRequests = {
    /** The chat pending join requests were changed */
    _: 'updateChatPendingJoinRequests',
    /** Chat identifier */
    chat_id: number,
    /** The new data about pending join requests; may be null */
    pending_join_requests?: chatJoinRequestsInfo,
  }

  export type updateChatReplyMarkup = {
    /**
     * The default chat reply markup was changed. Can occur because new messages with
     * reply markup were received or because an old reply markup was hidden by the
     * user
     */
    _: 'updateChatReplyMarkup',
    /** Chat identifier */
    chat_id: number,
    /**
     * Identifier of the message from which reply markup needs to be used; 0 if there
     * is no default custom reply markup in the chat
     */
    reply_markup_message_id: number,
  }

  export type updateChatTheme = {
    /** The chat theme was changed */
    _: 'updateChatTheme',
    /** Chat identifier */
    chat_id: number,
    /** The new name of the chat theme; may be empty if theme was reset to default */
    theme_name: string,
  }

  export type updateChatUnreadMentionCount = {
    /** The chat unread_mention_count has changed */
    _: 'updateChatUnreadMentionCount',
    /** Chat identifier */
    chat_id: number,
    /** The number of unread mention messages left in the chat */
    unread_mention_count: number,
  }

  export type updateChatVideoChat = {
    /** A chat video chat state has changed */
    _: 'updateChatVideoChat',
    /** Chat identifier */
    chat_id: number,
    /** New value of video_chat */
    video_chat: videoChat,
  }

  export type updateChatDefaultDisableNotification = {
    /**
     * The value of the default disable_notification parameter, used when a message
     * is sent to the chat, was changed
     */
    _: 'updateChatDefaultDisableNotification',
    /** Chat identifier */
    chat_id: number,
    /** The new default_disable_notification value */
    default_disable_notification: boolean,
  }

  export type updateChatHasProtectedContent = {
    /** A chat content was allowed or restricted for saving */
    _: 'updateChatHasProtectedContent',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_protected_content */
    has_protected_content: boolean,
  }

  export type updateChatHasScheduledMessages = {
    /** A chat's has_scheduled_messages field has changed */
    _: 'updateChatHasScheduledMessages',
    /** Chat identifier */
    chat_id: number,
    /** New value of has_scheduled_messages */
    has_scheduled_messages: boolean,
  }

  export type updateChatIsBlocked = {
    /** A chat was blocked or unblocked */
    _: 'updateChatIsBlocked',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_blocked */
    is_blocked: boolean,
  }

  export type updateChatIsMarkedAsUnread = {
    /** A chat was marked as unread or was read */
    _: 'updateChatIsMarkedAsUnread',
    /** Chat identifier */
    chat_id: number,
    /** New value of is_marked_as_unread */
    is_marked_as_unread: boolean,
  }

  export type updateChatFilters = {
    /** The list of chat filters or a chat filter has changed */
    _: 'updateChatFilters',
    /** The new list of chat filters */
    chat_filters: Array<chatFilterInfo>,
  }

  export type updateChatOnlineMemberCount = {
    /**
     * The number of online group members has changed. This update with non-zero count
     * is sent only for currently opened chats. There is no guarantee that it will
     * be sent just after the count has changed
     */
    _: 'updateChatOnlineMemberCount',
    /** Identifier of the chat */
    chat_id: number,
    /** New number of online members in the chat, or 0 if unknown */
    online_member_count: number,
  }

  export type updateScopeNotificationSettings = {
    /** Notification settings for some type of chats were updated */
    _: 'updateScopeNotificationSettings',
    /** Types of chats for which notification settings were updated */
    scope: NotificationSettingsScope,
    /** The new notification settings */
    notification_settings: scopeNotificationSettings,
  }

  export type updateNotification = {
    /** A notification was changed */
    _: 'updateNotification',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** Changed notification */
    notification: notification,
  }

  export type updateNotificationGroup = {
    /** A list of active notifications in a notification group has changed */
    _: 'updateNotificationGroup',
    /** Unique notification group identifier */
    notification_group_id: number,
    /** New type of the notification group */
    type: NotificationGroupType,
    /** Identifier of a chat to which all notifications in the group belong */
    chat_id: number,
    /** Chat identifier, which notification settings must be applied to the added notifications */
    notification_settings_chat_id: number,
    /** True, if the notifications must be shown without sound */
    is_silent: boolean,
    /**
     * Total number of unread notifications in the group, can be bigger than number
     * of active notifications
     */
    total_count: number,
    /** List of added group notifications, sorted by notification ID */
    added_notifications: Array<notification>,
    /** Identifiers of removed group notifications, sorted by notification ID */
    removed_notification_ids: Array<number>,
  }

  export type updateActiveNotifications = {
    /**
     * Contains active notifications that was shown on previous application launches.
     * This update is sent only if the message database is used. In that case it comes
     * once before any updateNotification and updateNotificationGroup update
     */
    _: 'updateActiveNotifications',
    /** Lists of active notification groups */
    groups: Array<notificationGroup>,
  }

  export type updateHavePendingNotifications = {
    /**
     * Describes whether there are some pending notification updates. Can be used to
     * prevent application from killing, while there are some pending notifications
     */
    _: 'updateHavePendingNotifications',
    /** True, if there are some delayed notification updates, which will be sent soon */
    have_delayed_notifications: boolean,
    /**
     * True, if there can be some yet unreceived notifications, which are being fetched
     * from the server
     */
    have_unreceived_notifications: boolean,
  }

  export type updateDeleteMessages = {
    /** Some messages were deleted */
    _: 'updateDeleteMessages',
    /** Chat identifier */
    chat_id: number,
    /** Identifiers of the deleted messages */
    message_ids: Array<number>,
    /**
     * True, if the messages are permanently deleted by a user (as opposed to just
     * becoming inaccessible)
     */
    is_permanent: boolean,
    /**
     * True, if the messages are deleted only from the cache and can possibly be retrieved
     * again in the future
     */
    from_cache: boolean,
  }

  export type updateChatAction = {
    /** A message sender activity in the chat has changed */
    _: 'updateChatAction',
    /** Chat identifier */
    chat_id: number,
    /** If not 0, a message thread identifier in which the action was performed */
    message_thread_id: number,
    /** Identifier of a message sender performing the action */
    sender_id: MessageSender,
    /** The action */
    action: ChatAction,
  }

  export type updateUserStatus = {
    /** The user went online or offline */
    _: 'updateUserStatus',
    /** User identifier */
    user_id: number,
    /** New status of the user */
    status: UserStatus,
  }

  export type updateUser = {
    /**
     * Some data of a user has changed. This update is guaranteed to come before the
     * user identifier is returned to the application
     */
    _: 'updateUser',
    /** New data about the user */
    user: user,
  }

  export type updateBasicGroup = {
    /**
     * Some data of a basic group has changed. This update is guaranteed to come before
     * the basic group identifier is returned to the application
     */
    _: 'updateBasicGroup',
    /** New data about the group */
    basic_group: basicGroup,
  }

  export type updateSupergroup = {
    /**
     * Some data of a supergroup or a channel has changed. This update is guaranteed
     * to come before the supergroup identifier is returned to the application
     */
    _: 'updateSupergroup',
    /** New data about the supergroup */
    supergroup: supergroup,
  }

  export type updateSecretChat = {
    /**
     * Some data of a secret chat has changed. This update is guaranteed to come before
     * the secret chat identifier is returned to the application
     */
    _: 'updateSecretChat',
    /** New data about the secret chat */
    secret_chat: secretChat,
  }

  export type updateUserFullInfo = {
    /** Some data in userFullInfo has been changed */
    _: 'updateUserFullInfo',
    /** User identifier */
    user_id: number,
    /** New full information about the user */
    user_full_info: userFullInfo,
  }

  export type updateBasicGroupFullInfo = {
    /** Some data in basicGroupFullInfo has been changed */
    _: 'updateBasicGroupFullInfo',
    /** Identifier of a basic group */
    basic_group_id: number,
    /** New full information about the group */
    basic_group_full_info: basicGroupFullInfo,
  }

  export type updateSupergroupFullInfo = {
    /** Some data in supergroupFullInfo has been changed */
    _: 'updateSupergroupFullInfo',
    /** Identifier of the supergroup or channel */
    supergroup_id: number,
    /** New full information about the supergroup */
    supergroup_full_info: supergroupFullInfo,
  }

  export type updateServiceNotification = {
    /**
     * A service notification from the server was received. Upon receiving this the
     * application must show a popup with the content of the notification
     */
    _: 'updateServiceNotification',
    /**
     * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel"
     * and "Log out" must be shown under notification; if user presses the second,
     * all local data must be destroyed using Destroy method
     */
    type: string,
    /** Notification content */
    content: MessageContent,
  }

  export type updateFile = {
    /** Information about a file was updated */
    _: 'updateFile',
    /** New data about the file */
    file: file,
  }

  export type updateFileGenerationStart = {
    /** The file generation process needs to be started by the application */
    _: 'updateFileGenerationStart',
    /** Unique identifier for the generation process */
    generation_id: number | string,
    /** The path to a file from which a new file is generated; may be empty */
    original_path: string,
    /** The path to a file that must be created and where the new file is generated */
    destination_path: string,
    /**
     * String specifying the conversion applied to the original file. If conversion
     * is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must
     * be downloaded by the application
     */
    conversion: string,
  }

  export type updateFileGenerationStop = {
    /** File generation is no longer needed */
    _: 'updateFileGenerationStop',
    /** Unique identifier for the generation process */
    generation_id: number | string,
  }

  export type updateCall = {
    /** New call was created or information about a call was updated */
    _: 'updateCall',
    /** New data about a call */
    call: call,
  }

  export type updateGroupCall = {
    /** Information about a group call was updated */
    _: 'updateGroupCall',
    /** New data about a group call */
    group_call: groupCall,
  }

  export type updateGroupCallParticipant = {
    /**
     * Information about a group call participant was changed. The updates are sent
     * only after the group call is received through getGroupCall and only if the call
     * is joined or being joined
     */
    _: 'updateGroupCallParticipant',
    /** Identifier of group call */
    group_call_id: number,
    /** New data about a participant */
    participant: groupCallParticipant,
  }

  export type updateNewCallSignalingData = {
    /** New call signaling data arrived */
    _: 'updateNewCallSignalingData',
    /** The call identifier */
    call_id: number,
    /** The data */
    data: string,
  }

  export type updateUserPrivacySettingRules = {
    /** Some privacy setting rules have been changed */
    _: 'updateUserPrivacySettingRules',
    /** The privacy setting */
    setting: UserPrivacySetting,
    /** New privacy rules */
    rules: userPrivacySettingRules,
  }

  export type updateUnreadMessageCount = {
    /**
     * Number of unread messages in a chat list has changed. This update is sent only
     * if the message database is used
     */
    _: 'updateUnreadMessageCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Total number of unread messages */
    unread_count: number,
    /** Total number of unread messages in unmuted chats */
    unread_unmuted_count: number,
  }

  export type updateUnreadChatCount = {
    /**
     * Number of unread chats, i.e. with unread messages or marked as unread, has changed.
     * This update is sent only if the message database is used
     */
    _: 'updateUnreadChatCount',
    /** The chat list with changed number of unread messages */
    chat_list: ChatList,
    /** Approximate total number of chats in the chat list */
    total_count: number,
    /** Total number of unread chats */
    unread_count: number,
    /** Total number of unread unmuted chats */
    unread_unmuted_count: number,
    /** Total number of chats marked as unread */
    marked_as_unread_count: number,
    /** Total number of unmuted chats marked as unread */
    marked_as_unread_unmuted_count: number,
  }

  export type updateOption = {
    /** An option changed its value */
    _: 'updateOption',
    /** The option name */
    name: string,
    /** The new option value */
    value: OptionValue,
  }

  export type updateStickerSet = {
    /** A sticker set has changed */
    _: 'updateStickerSet',
    /** The sticker set */
    sticker_set: stickerSet,
  }

  export type updateInstalledStickerSets = {
    /** The list of installed sticker sets was updated */
    _: 'updateInstalledStickerSets',
    /** True, if the list of installed mask sticker sets was updated */
    is_masks: boolean,
    /** The new list of installed ordinary sticker sets */
    sticker_set_ids: Array<number | string>,
  }

  export type updateTrendingStickerSets = {
    /** The list of trending sticker sets was updated or some of them were viewed */
    _: 'updateTrendingStickerSets',
    /**
     * The prefix of the list of trending sticker sets with the newest trending sticker
     * sets
     */
    sticker_sets: stickerSets,
  }

  export type updateRecentStickers = {
    /** The list of recently used stickers was updated */
    _: 'updateRecentStickers',
    /**
     * True, if the list of stickers attached to photo or video files was updated,
     * otherwise the list of sent stickers is updated
     */
    is_attached: boolean,
    /** The new list of file identifiers of recently used stickers */
    sticker_ids: Array<number>,
  }

  export type updateFavoriteStickers = {
    /** The list of favorite stickers was updated */
    _: 'updateFavoriteStickers',
    /** The new list of file identifiers of favorite stickers */
    sticker_ids: Array<number>,
  }

  export type updateSavedAnimations = {
    /** The list of saved animations was updated */
    _: 'updateSavedAnimations',
    /** The new list of file identifiers of saved animations */
    animation_ids: Array<number>,
  }

  export type updateSelectedBackground = {
    /** The selected background has changed */
    _: 'updateSelectedBackground',
    /** True, if background for dark theme has changed */
    for_dark_theme: boolean,
    /** The new selected background; may be null */
    background?: background,
  }

  export type updateChatThemes = {
    /** The list of available chat themes has changed */
    _: 'updateChatThemes',
    /** The new list of chat themes */
    chat_themes: Array<chatTheme>,
  }

  export type updateLanguagePackStrings = {
    /** Some language pack strings have been updated */
    _: 'updateLanguagePackStrings',
    /** Localization target to which the language pack belongs */
    localization_target: string,
    /** Identifier of the updated language pack */
    language_pack_id: string,
    /** List of changed language pack strings */
    strings: Array<languagePackString>,
  }

  export type updateConnectionState = {
    /**
     * The connection state has changed. This update must be used only to show a human-readable
     * description of the connection state
     */
    _: 'updateConnectionState',
    /** The new connection state */
    state: ConnectionState,
  }

  export type updateTermsOfService = {
    /**
     * New terms of service must be accepted by the user. If the terms of service are
     * declined, then the deleteAccount method must be called with the reason "Decline
     * ToS update"
     */
    _: 'updateTermsOfService',
    /** Identifier of the terms of service */
    terms_of_service_id: string,
    /** The new terms of service */
    terms_of_service: termsOfService,
  }

  export type updateUsersNearby = {
    /**
     * The list of users nearby has changed. The update is guaranteed to be sent only
     * 60 seconds after a successful searchChatsNearby request
     */
    _: 'updateUsersNearby',
    /** The new list of users nearby */
    users_nearby: Array<chatNearby>,
  }

  export type updateDiceEmojis = {
    /** The list of supported dice emojis has changed */
    _: 'updateDiceEmojis',
    /** The new list of supported dice emojis */
    emojis: Array<string>,
  }

  export type updateAnimatedEmojiMessageClicked = {
    /**
     * Some animated emoji message was clicked and a big animated sticker must be played
     * if the message is visible on the screen. chatActionWatchingAnimations with the
     * text of the message needs to be sent if the sticker is played
     */
    _: 'updateAnimatedEmojiMessageClicked',
    /** Chat identifier */
    chat_id: number,
    /** Message identifier */
    message_id: number,
    /** The animated sticker to be played */
    sticker: sticker,
  }

  export type updateAnimationSearchParameters = {
    /**
     * The parameters of animation search through GetOption("animation_search_bot_username")
     * bot has changed
     */
    _: 'updateAnimationSearchParameters',
    /** Name of the animation search provider */
    provider: string,
    /** The new list of emojis suggested for searching */
    emojis: Array<string>,
  }

  export type updateSuggestedActions = {
    /** The list of suggested to the user actions has changed */
    _: 'updateSuggestedActions',
    /** Added suggested actions */
    added_actions: Array<SuggestedAction>,
    /** Removed suggested actions */
    removed_actions: Array<SuggestedAction>,
  }

  export type updateNewInlineQuery = {
    /** A new incoming inline query; for bots only */
    _: 'updateNewInlineQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** The type of the chat, from which the query originated; may be null if unknown */
    chat_type?: ChatType,
    /** Text of the query */
    query: string,
    /** Offset of the first entry to return */
    offset: string,
  }

  export type updateNewChosenInlineResult = {
    /** The user has chosen a result of an inline query; for bots only */
    _: 'updateNewChosenInlineResult',
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** User location; may be null */
    user_location?: location,
    /** Text of the query */
    query: string,
    /** Identifier of the chosen result */
    result_id: string,
    /** Identifier of the sent inline message, if known */
    inline_message_id: string,
  }

  export type updateNewCallbackQuery = {
    /** A new incoming callback query; for bots only */
    _: 'updateNewCallbackQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the chat where the query was sent */
    chat_id: number,
    /** Identifier of the message, from which the query originated */
    message_id: number,
    /** Identifier that uniquely corresponds to the chat to which the message was sent */
    chat_instance: number | string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewInlineCallbackQuery = {
    /** A new incoming callback query from a message sent via a bot; for bots only */
    _: 'updateNewInlineCallbackQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Identifier of the inline message, from which the query originated */
    inline_message_id: string,
    /** An identifier uniquely corresponding to the chat a message was sent to */
    chat_instance: number | string,
    /** Query payload */
    payload: CallbackQueryPayload,
  }

  export type updateNewShippingQuery = {
    /**
     * A new incoming shipping query; for bots only. Only for invoices with flexible
     * price
     */
    _: 'updateNewShippingQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Invoice payload */
    invoice_payload: string,
    /** User shipping address */
    shipping_address: address,
  }

  export type updateNewPreCheckoutQuery = {
    /**
     * A new incoming pre-checkout query; for bots only. Contains full information
     * about a checkout
     */
    _: 'updateNewPreCheckoutQuery',
    /** Unique query identifier */
    id: number | string,
    /** Identifier of the user who sent the query */
    sender_user_id: number,
    /** Currency for the product price */
    currency: string,
    /** Total price for the product, in the smallest units of the currency */
    total_amount: number,
    /** Invoice payload */
    invoice_payload: string,
    /** Identifier of a shipping option chosen by the user; may be empty if not applicable */
    shipping_option_id: string,
    /** Information about the order; may be null */
    order_info?: orderInfo,
  }

  export type updateNewCustomEvent = {
    /** A new incoming event; for bots only */
    _: 'updateNewCustomEvent',
    /** A JSON-serialized event */
    event: string,
  }

  export type updateNewCustomQuery = {
    /** A new incoming query; for bots only */
    _: 'updateNewCustomQuery',
    /** The query identifier */
    id: number | string,
    /** JSON-serialized query data */
    data: string,
    /** Query timeout */
    timeout: number,
  }

  export type updatePoll = {
    /** A poll was updated; for bots only */
    _: 'updatePoll',
    /** New data about the poll */
    poll: poll,
  }

  export type updatePollAnswer = {
    /** A user changed the answer to a poll; for bots only */
    _: 'updatePollAnswer',
    /** Unique poll identifier */
    poll_id: number | string,
    /** The user, who changed the answer to the poll */
    user_id: number,
    /** 0-based identifiers of answer options, chosen by the user */
    option_ids: Array<number>,
  }

  export type updateChatMember = {
    /** User rights changed in a chat; for bots only */
    _: 'updateChatMember',
    /** Chat identifier */
    chat_id: number,
    /** Identifier of the user, changing the rights */
    actor_user_id: number,
    /** Point in time (Unix timestamp) when the user rights was changed */
    date: number,
    /** If user has joined the chat using an invite link, the invite link; may be null */
    invite_link?: chatInviteLink,
    /** Previous chat member */
    old_chat_member: chatMember,
    /** New chat member */
    new_chat_member: chatMember,
  }

  export type updateNewChatJoinRequest = {
    /** A user sent a join request to a chat; for bots only */
    _: 'updateNewChatJoinRequest',
    /** Chat identifier */
    chat_id: number,
    /** Join request */
    request: chatJoinRequest,
    /** The invite link, which was used to send join request; may be null */
    invite_link?: chatInviteLink,
  }

  export type updates = {
    /** Contains a list of updates */
    _: 'updates',
    /** List of updates */
    updates: Array<Update>,
  }

  export type logStreamDefault = {
    /** The log is written to stderr or an OS specific log */
    _: 'logStreamDefault',
  }

  export type logStreamDefault$Input = {
    /** The log is written to stderr or an OS specific log */
    readonly _: 'logStreamDefault',
  }

  export type logStreamFile = {
    /** The log is written to a file */
    _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    path: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    max_file_size: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    redirect_stderr: boolean,
  }

  export type logStreamFile$Input = {
    /** The log is written to a file */
    readonly _: 'logStreamFile',
    /** Path to the file to where the internal TDLib log will be written */
    readonly path?: string,
    /**
     * The maximum size of the file to where the internal TDLib log is written before
     * the file will automatically be rotated, in bytes
     */
    readonly max_file_size?: number,
    /** Pass true to additionally redirect stderr to the log file. Ignored on Windows */
    readonly redirect_stderr?: boolean,
  }

  export type logStreamEmpty = {
    /** The log is written nowhere */
    _: 'logStreamEmpty',
  }

  export type logStreamEmpty$Input = {
    /** The log is written nowhere */
    readonly _: 'logStreamEmpty',
  }

  export type logVerbosityLevel = {
    /** Contains a TDLib internal log verbosity level */
    _: 'logVerbosityLevel',
    /** Log verbosity level */
    verbosity_level: number,
  }

  export type logTags = {
    /** Contains a list of available TDLib internal log tags */
    _: 'logTags',
    /** List of log tags */
    tags: Array<string>,
  }

  export type testInt = {
    /** A simple object containing a number; for testing only */
    _: 'testInt',
    /** Number */
    value: number,
  }

  export type testInt$Input = {
    /** A simple object containing a number; for testing only */
    readonly _: 'testInt',
    /** Number */
    readonly value?: number,
  }

  export type testString = {
    /** A simple object containing a string; for testing only */
    _: 'testString',
    /** String */
    value: string,
  }

  export type testString$Input = {
    /** A simple object containing a string; for testing only */
    readonly _: 'testString',
    /** String */
    readonly value?: string,
  }

  export type testBytes = {
    /** A simple object containing a sequence of bytes; for testing only */
    _: 'testBytes',
    /** Bytes */
    value: string,
  }

  export type testVectorInt = {
    /** A simple object containing a vector of numbers; for testing only */
    _: 'testVectorInt',
    /** Vector of numbers */
    value: Array<number>,
  }

  export type testVectorIntObject = {
    /**
     * A simple object containing a vector of objects that hold a number; for testing
     * only
     */
    _: 'testVectorIntObject',
    /** Vector of objects */
    value: Array<testInt>,
  }

  export type testVectorString = {
    /** A simple object containing a vector of strings; for testing only */
    _: 'testVectorString',
    /** Vector of strings */
    value: Array<string>,
  }

  export type testVectorStringObject = {
    /**
     * A simple object containing a vector of objects that hold a string; for testing
     * only
     */
    _: 'testVectorStringObject',
    /** Vector of objects */
    value: Array<testString>,
  }

  export type getAuthorizationState = {
    /**
     * Returns the current authorization state; this is an offline request. For informational
     * purposes only. Use updateAuthorizationState instead to maintain the current
     * authorization state. Can be called before initialization
     */
    readonly _: 'getAuthorizationState',
  }

  export type setTdlibParameters = {
    /**
     * Sets the parameters for TDLib initialization. Works only when the current authorization
     * state is authorizationStateWaitTdlibParameters
     */
    readonly _: 'setTdlibParameters',
    /** Parameters for TDLib initialization */
    readonly parameters?: tdlibParameters$Input,
  }

  export type checkDatabaseEncryptionKey = {
    /**
     * Checks the database encryption key for correctness. Works only when the current
     * authorization state is authorizationStateWaitEncryptionKey
     */
    readonly _: 'checkDatabaseEncryptionKey',
    /** Encryption key to check or set up */
    readonly encryption_key?: string,
  }

  export type setAuthenticationPhoneNumber = {
    /**
     * Sets the phone number of the user and sends an authentication code to the user.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitCode, authorizationStateWaitRegistration, or
     * authorizationStateWaitPassword
     */
    readonly _: 'setAuthenticationPhoneNumber',
    /** The phone number of the user, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendAuthenticationCode = {
    /**
     * Re-sends an authentication code to the user. Works only when the current authorization
     * state is authorizationStateWaitCode, the next_code_type of the result is not
     * null and the server-specified timeout has passed
     */
    readonly _: 'resendAuthenticationCode',
  }

  export type checkAuthenticationCode = {
    /**
     * Checks the authentication code. Works only when the current authorization state
     * is authorizationStateWaitCode
     */
    readonly _: 'checkAuthenticationCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type requestQrCodeAuthentication = {
    /**
     * Requests QR code authentication by scanning a QR code on another logged in device.
     * Works only when the current authorization state is authorizationStateWaitPhoneNumber,
     * or if there is no pending authentication query and the current authorization
     * state is authorizationStateWaitCode, authorizationStateWaitRegistration, or
     * authorizationStateWaitPassword
     */
    readonly _: 'requestQrCodeAuthentication',
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type registerUser = {
    /**
     * Finishes user registration. Works only when the current authorization state
     * is authorizationStateWaitRegistration
     */
    readonly _: 'registerUser',
    /** The first name of the user; 1-64 characters */
    readonly first_name?: string,
    /** The last name of the user; 0-64 characters */
    readonly last_name?: string,
  }

  export type checkAuthenticationPassword = {
    /**
     * Checks the authentication password for correctness. Works only when the current
     * authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPassword',
    /** The password to check */
    readonly password?: string,
  }

  export type requestAuthenticationPasswordRecovery = {
    /**
     * Requests to send a password recovery code to an email address that was previously
     * set up. Works only when the current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'requestAuthenticationPasswordRecovery',
  }

  export type checkAuthenticationPasswordRecoveryCode = {
    /**
     * Checks whether a password recovery code sent to an email address is valid. Works
     * only when the current authorization state is authorizationStateWaitPassword
     */
    readonly _: 'checkAuthenticationPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverAuthenticationPassword = {
    /**
     * Recovers the password with a password recovery code sent to an email address
     * that was previously set up. Works only when the current authorization state
     * is authorizationStateWaitPassword
     */
    readonly _: 'recoverAuthenticationPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type checkAuthenticationBotToken = {
    /**
     * Checks the authentication token of a bot; to log in as a bot. Works only when
     * the current authorization state is authorizationStateWaitPhoneNumber. Can be
     * used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to
     * log in
     */
    readonly _: 'checkAuthenticationBotToken',
    /** The bot token */
    readonly token?: string,
  }

  export type logOut = {
    /**
     * Closes the TDLib instance after a proper logout. Requires an available network
     * connection. All local data will be destroyed. After the logout completes, updateAuthorizationState
     * with authorizationStateClosed will be sent
     */
    readonly _: 'logOut',
  }

  export type close = {
    /**
     * Closes the TDLib instance. All databases will be flushed to disk and properly
     * closed. After the close completes, updateAuthorizationState with authorizationStateClosed
     * will be sent. Can be called before initialization
     */
    readonly _: 'close',
  }

  export type destroy = {
    /**
     * Closes the TDLib instance, destroying all local data without a proper logout.
     * The current user session will remain in the list of all active sessions. All
     * local data will be destroyed. After the destruction completes updateAuthorizationState
     * with authorizationStateClosed will be sent. Can be called before authorization
     */
    readonly _: 'destroy',
  }

  export type confirmQrCodeAuthentication = {
    /**
     * Confirms QR code authentication on another device. Returns created session on
     * success
     */
    readonly _: 'confirmQrCodeAuthentication',
    /** A link from a QR code. The link must be scanned by the in-app camera */
    readonly link?: string,
  }

  export type getCurrentState = {
    /**
     * Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat
     * and others. This is especially useful if TDLib is run in a separate process.
     * Can be called before initialization
     */
    readonly _: 'getCurrentState',
  }

  export type setDatabaseEncryptionKey = {
    /**
     * Changes the database encryption key. Usually the encryption key is never changed
     * and is stored in some OS keychain
     */
    readonly _: 'setDatabaseEncryptionKey',
    /** New encryption key */
    readonly new_encryption_key?: string,
  }

  export type getPasswordState = {
    /** Returns the current state of 2-step verification */
    readonly _: 'getPasswordState',
  }

  export type setPassword = {
    /**
     * Changes the password for the current user. If a new recovery email address is
     * specified, then the change will not be applied until the new recovery email
     * address is confirmed
     */
    readonly _: 'setPassword',
    /** Previous password of the user */
    readonly old_password?: string,
    /** New password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
    /** Pass true if the recovery email address must be changed */
    readonly set_recovery_email_address?: boolean,
    /** New recovery email address; may be empty */
    readonly new_recovery_email_address?: string,
  }

  export type getRecoveryEmailAddress = {
    /**
     * Returns a 2-step verification recovery email address that was previously set
     * up. This method can be used to verify a password provided by the user
     */
    readonly _: 'getRecoveryEmailAddress',
    /** The password for the current user */
    readonly password?: string,
  }

  export type setRecoveryEmailAddress = {
    /**
     * Changes the 2-step verification recovery email address of the user. If a new
     * recovery email address is specified, then the change will not be applied until
     * the new recovery email address is confirmed. If new_recovery_email_address is
     * the same as the email address that is currently set up, this call succeeds immediately
     * and aborts all other requests waiting for an email confirmation
     */
    readonly _: 'setRecoveryEmailAddress',
    /** Password of the current user */
    readonly password?: string,
    /** New recovery email address */
    readonly new_recovery_email_address?: string,
  }

  export type checkRecoveryEmailAddressCode = {
    /** Checks the 2-step verification recovery email address verification code */
    readonly _: 'checkRecoveryEmailAddressCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type resendRecoveryEmailAddressCode = {
    /** Resends the 2-step verification recovery email address verification code */
    readonly _: 'resendRecoveryEmailAddressCode',
  }

  export type requestPasswordRecovery = {
    /**
     * Requests to send a 2-step verification password recovery code to an email address
     * that was previously set up
     */
    readonly _: 'requestPasswordRecovery',
  }

  export type checkPasswordRecoveryCode = {
    /**
     * Checks whether a 2-step verification password recovery code sent to an email
     * address is valid
     */
    readonly _: 'checkPasswordRecoveryCode',
    /** Recovery code to check */
    readonly recovery_code?: string,
  }

  export type recoverPassword = {
    /**
     * Recovers the 2-step verification password using a recovery code sent to an email
     * address that was previously set up
     */
    readonly _: 'recoverPassword',
    /** Recovery code to check */
    readonly recovery_code?: string,
    /** New password of the user; may be empty to remove the password */
    readonly new_password?: string,
    /** New password hint; may be empty */
    readonly new_hint?: string,
  }

  export type resetPassword = {
    /**
     * Removes 2-step verification password without previous password and access to
     * recovery email address. The password can't be reset immediately and the request
     * needs to be repeated after the specified time
     */
    readonly _: 'resetPassword',
  }

  export type cancelPasswordReset = {
    /**
     * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date
     * > 0
     */
    readonly _: 'cancelPasswordReset',
  }

  export type createTemporaryPassword = {
    /** Creates a new temporary password for processing payments */
    readonly _: 'createTemporaryPassword',
    /** Persistent user password */
    readonly password?: string,
    /**
     * Time during which the temporary password will be valid, in seconds; must be
     * between 60 and 86400
     */
    readonly valid_for?: number,
  }

  export type getTemporaryPasswordState = {
    /** Returns information about the current temporary password */
    readonly _: 'getTemporaryPasswordState',
  }

  export type getMe = {
    /** Returns the current user */
    readonly _: 'getMe',
  }

  export type getUser = {
    /**
     * Returns information about a user by their identifier. This is an offline request
     * if the current user is not a bot
     */
    readonly _: 'getUser',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getUserFullInfo = {
    /** Returns full information about a user by their identifier */
    readonly _: 'getUserFullInfo',
    /** User identifier */
    readonly user_id?: number,
  }

  export type getBasicGroup = {
    /**
     * Returns information about a basic group by its identifier. This is an offline
     * request if the current user is not a bot
     */
    readonly _: 'getBasicGroup',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getBasicGroupFullInfo = {
    /** Returns full information about a basic group by its identifier */
    readonly _: 'getBasicGroupFullInfo',
    /** Basic group identifier */
    readonly basic_group_id?: number,
  }

  export type getSupergroup = {
    /**
     * Returns information about a supergroup or a channel by its identifier. This
     * is an offline request if the current user is not a bot
     */
    readonly _: 'getSupergroup',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSupergroupFullInfo = {
    /**
     * Returns full information about a supergroup or a channel by its identifier,
     * cached for up to 1 minute
     */
    readonly _: 'getSupergroupFullInfo',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
  }

  export type getSecretChat = {
    /**
     * Returns information about a secret chat by its identifier. This is an offline
     * request
     */
    readonly _: 'getSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChat = {
    /**
     * Returns information about a chat by its identifier, this is an offline request
     * if the current user is not a bot
     */
    readonly _: 'getChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getMessage = {
    /** Returns information about a message */
    readonly _: 'getMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getMessageLocally = {
    /**
     * Returns information about a message, if it is available locally without sending
     * network request. This is an offline request
     */
    readonly _: 'getMessageLocally',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message to get */
    readonly message_id?: number,
  }

  export type getRepliedMessage = {
    /**
     * Returns information about a message that is replied by a given message. Also
     * returns the pinned message, the game message, and the invoice message for messages
     * of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful
     * respectively
     */
    readonly _: 'getRepliedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the reply message */
    readonly message_id?: number,
  }

  export type getChatPinnedMessage = {
    /** Returns information about a newest pinned message in the chat */
    readonly _: 'getChatPinnedMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
  }

  export type getCallbackQueryMessage = {
    /**
     * Returns information about a message with the callback button that originated
     * a callback query; for bots only
     */
    readonly _: 'getCallbackQueryMessage',
    /** Identifier of the chat the message belongs to */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
  }

  export type getMessages = {
    /**
     * Returns information about messages. If a message is not found, returns null
     * on the corresponding position of the result
     */
    readonly _: 'getMessages',
    /** Identifier of the chat the messages belong to */
    readonly chat_id?: number,
    /** Identifiers of the messages to get */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type getMessageThread = {
    /**
     * Returns information about a message thread. Can be used only if message.can_get_message_thread
     * == true
     */
    readonly _: 'getMessageThread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getMessageViewers = {
    /**
     * Returns viewers of a recent outgoing message in a basic group or a supergroup
     * chat. For video notes and voice notes only users, opened content of the message,
     * are returned. The method can be called if message.can_get_viewers == true
     */
    readonly _: 'getMessageViewers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
  }

  export type getFile = {
    /** Returns information about a file; this is an offline request */
    readonly _: 'getFile',
    /** Identifier of the file to get */
    readonly file_id?: number,
  }

  export type getRemoteFile = {
    /**
     * Returns information about a file by its remote ID; this is an offline request.
     * Can be used to register a URL as a file for further uploading, or sending as
     * a message. Even the request succeeds, the file can be used only if it is still
     * accessible to the user. For example, if the file is from a message, then the
     * message must be not deleted and accessible to the user. If the file database
     * is disabled, then the corresponding object with the file must be preloaded by
     * the application
     */
    readonly _: 'getRemoteFile',
    /** Remote identifier of the file to get */
    readonly remote_file_id?: string,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
  }

  export type loadChats = {
    /**
     * Loads more chats from a chat list. The loaded chats and their positions in the
     * chat list will be sent through updates. Chats are sorted by the pair (chat.position.order,
     * chat.id) in descending order. Returns a 404 error if all chats have been loaded
     */
    readonly _: 'loadChats',
    /**
     * The chat list in which to load chats; pass null to load chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /**
     * The maximum number of chats to be loaded. For optimal performance, the number
     * of loaded chats is chosen by TDLib and can be smaller than the specified limit,
     * even if the end of the list is not reached
     */
    readonly limit?: number,
  }

  export type getChats = {
    /**
     * Returns an ordered list of chats from the beginning of a chat list. For informational
     * purposes only. Use loadChats and updates processing instead to maintain chat
     * lists in a consistent state
     */
    readonly _: 'getChats',
    /**
     * The chat list in which to return chats; pass null to get chats from the main
     * chat list
     */
    readonly chat_list?: ChatList$Input,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchPublicChat = {
    /**
     * Searches a public chat by its username. Currently, only private chats, supergroups
     * and channels can be public. Returns the chat if found; otherwise an error is
     * returned
     */
    readonly _: 'searchPublicChat',
    /** Username to be resolved */
    readonly username?: string,
  }

  export type searchPublicChats = {
    /**
     * Searches public chats by looking for specified query in their username and title.
     * Currently, only private chats, supergroups and channels can be public. Returns
     * a meaningful number of results. Excludes private chats with contacts and chats
     * from the chat list from the results
     */
    readonly _: 'searchPublicChats',
    /** Query to search for */
    readonly query?: string,
  }

  export type searchChats = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats, this is an offline request. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChats',
    /**
     * Query to search for. If the query is empty, returns up to 50 recently found
     * chats
     */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchChatsOnServer = {
    /**
     * Searches for the specified query in the title and username of already known
     * chats via request to the server. Returns chats in the order seen in the main
     * chat list
     */
    readonly _: 'searchChatsOnServer',
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type searchChatsNearby = {
    /**
     * Returns a list of users and location-based supergroups nearby. The list of users
     * nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
     * The request must be sent again every 25 seconds with adjusted location to not
     * miss new chats
     */
    readonly _: 'searchChatsNearby',
    /** Current user location */
    readonly location?: location$Input,
  }

  export type getTopChats = {
    /**
     * Returns a list of frequently used chats. Supported only if the chat info database
     * is enabled
     */
    readonly _: 'getTopChats',
    /** Category of chats to be returned */
    readonly category?: TopChatCategory$Input,
    /** The maximum number of chats to be returned; up to 30 */
    readonly limit?: number,
  }

  export type removeTopChat = {
    /**
     * Removes a chat from the list of frequently used chats. Supported only if the
     * chat info database is enabled
     */
    readonly _: 'removeTopChat',
    /** Category of frequently used chats */
    readonly category?: TopChatCategory$Input,
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addRecentlyFoundChat = {
    /**
     * Adds a chat to the list of recently found chats. The chat is added to the beginning
     * of the list. If the chat is already in the list, it will be removed from the
     * list first
     */
    readonly _: 'addRecentlyFoundChat',
    /** Identifier of the chat to add */
    readonly chat_id?: number,
  }

  export type removeRecentlyFoundChat = {
    /** Removes a chat from the list of recently found chats */
    readonly _: 'removeRecentlyFoundChat',
    /** Identifier of the chat to be removed */
    readonly chat_id?: number,
  }

  export type clearRecentlyFoundChats = {
    /** Clears the list of recently found chats */
    readonly _: 'clearRecentlyFoundChats',
  }

  export type getRecentlyOpenedChats = {
    /**
     * Returns recently opened chats, this is an offline request. Returns chats in
     * the order of last opening
     */
    readonly _: 'getRecentlyOpenedChats',
    /** The maximum number of chats to be returned */
    readonly limit?: number,
  }

  export type checkChatUsername = {
    /** Checks whether a username can be set for a chat */
    readonly _: 'checkChatUsername',
    /**
     * Chat identifier; must be identifier of a supergroup chat, or a channel chat,
     * or a private chat with self, or zero if the chat is being created
     */
    readonly chat_id?: number,
    /** Username to be checked */
    readonly username?: string,
  }

  export type getCreatedPublicChats = {
    /** Returns a list of public chats of the specified type, owned by the user */
    readonly _: 'getCreatedPublicChats',
    /** Type of the public chats to return */
    readonly type?: PublicChatType$Input,
  }

  export type checkCreatedPublicChatsLimit = {
    /**
     * Checks whether the maximum number of owned public chats has been reached. Returns
     * corresponding error if the limit was reached
     */
    readonly _: 'checkCreatedPublicChatsLimit',
    /** Type of the public chats, for which to check the limit */
    readonly type?: PublicChatType$Input,
  }

  export type getSuitableDiscussionChats = {
    /**
     * Returns a list of basic group and supergroup chats, which can be used as a discussion
     * group for a channel. Returned basic group chats must be first upgraded to supergroups
     * before they can be set as a discussion group. To set a returned supergroup as
     * a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable
     * first
     */
    readonly _: 'getSuitableDiscussionChats',
  }

  export type getInactiveSupergroupChats = {
    /**
     * Returns a list of recently inactive supergroups and channels. Can be used when
     * user reaches limit on the number of joined supergroups and channels and receives
     * CHANNELS_TOO_MUCH error
     */
    readonly _: 'getInactiveSupergroupChats',
  }

  export type getGroupsInCommon = {
    /**
     * Returns a list of common group chats with a given user. Chats are sorted by
     * their type and creation date
     */
    readonly _: 'getGroupsInCommon',
    /** User identifier */
    readonly user_id?: number,
    /** Chat identifier starting from which to return chats; use 0 for the first request */
    readonly offset_chat_id?: number,
    /** The maximum number of chats to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getChatHistory = {
    /**
     * Returns messages in a chat. The messages are returned in a reverse chronological
     * order (i.e., in order of decreasing message_id). For optimal performance, the
     * number of returned messages is chosen by TDLib. This is an offline request if
     * only_local is true
     */
    readonly _: 'getChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /**
     * If true, returns only messages that are available locally without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getMessageThreadHistory = {
    /**
     * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread
     * == true. Message thread of a channel message is in the channel's linked supergroup.
     * The messages are returned in a reverse chronological order (i.e., in order of
     * decreasing message_id). For optimal performance, the number of returned messages
     * is chosen by TDLib
     */
    readonly _: 'getMessageThreadHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier, which thread history needs to be returned */
    readonly message_id?: number,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * up to 99 to get additionally some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * or equal to -offset. For optimal performance, the number of returned messages
     * is chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type deleteChatHistory = {
    /**
     * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and
     * chat.can_be_deleted_for_all_users fields to find whether and how the method
     * can be applied to the chat
     */
    readonly _: 'deleteChatHistory',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true if the chat needs to be removed from the chat list */
    readonly remove_from_chat_list?: boolean,
    /** Pass true to delete chat history for all users */
    readonly revoke?: boolean,
  }

  export type deleteChat = {
    /**
     * Deletes a chat along with all messages in the corresponding chat for all chat
     * members; requires owner privileges. For group chats this will release the username
     * and remove all members. Chats with more than 1000 members can't be deleted using
     * this method
     */
    readonly _: 'deleteChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type searchChatMessages = {
    /**
     * Searches for messages with given words in the chat. Returns the results in reverse
     * chronological order, i.e. in order of decreasing message_id. Cannot be used
     * in secret chats with a non-empty query (searchSecretMessages must be used instead),
     * or without an enabled message database. For optimal performance, the number
     * of returned messages is chosen by TDLib and can be smaller than the specified
     * limit
     */
    readonly _: 'searchChatMessages',
    /** Identifier of the chat in which to search messages */
    readonly chat_id?: number,
    /** Query to search for */
    readonly query?: string,
    /**
     * Identifier of the sender of messages to search for; pass null to search for
     * messages from any sender. Not supported in secret chats
     */
    readonly sender_id?: MessageSender$Input,
    /**
     * Identifier of the message starting from which history must be fetched; use 0
     * to get results from the last message
     */
    readonly from_message_id?: number,
    /**
     * Specify 0 to get results from exactly the from_message_id or a negative offset
     * to get the specified message and some newer messages
     */
    readonly offset?: number,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. If the offset is negative, the limit must be greater than
     * -offset. For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * If not 0, only messages in the specified thread will be returned; supergroups
     * only
     */
    readonly message_thread_id?: number,
  }

  export type searchMessages = {
    /**
     * Searches for messages in all chats except secret chats. Returns the results
     * in reverse chronological order (i.e., in order of decreasing (date, chat_id,
     * message_id)). For optimal performance, the number of returned messages is chosen
     * by TDLib and can be smaller than the specified limit
     */
    readonly _: 'searchMessages',
    /**
     * Chat list in which to search messages; pass null to search in all chats regardless
     * of their chat list. Only Main and Archive chat lists are supported
     */
    readonly chat_list?: ChatList$Input,
    /** Query to search for */
    readonly query?: string,
    /**
     * The date of the message starting from which the results need to be fetched.
     * Use 0 or any date in the future to get results from the last message
     */
    readonly offset_date?: number,
    /** The chat identifier of the last found message, or 0 for the first request */
    readonly offset_chat_id?: number,
    /** The message identifier of the last found message, or 0 for the first request */
    readonly offset_message_id?: number,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /**
     * Additional filter for messages to search; pass null to search for all messages.
     * Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterFailedToSend
     * and searchMessagesFilterPinned are unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** If not 0, the minimum date of the messages to return */
    readonly min_date?: number,
    /** If not 0, the maximum date of the messages to return */
    readonly max_date?: number,
  }

  export type searchSecretMessages = {
    /**
     * Searches for messages in secret chats. Returns the results in reverse chronological
     * order. For optimal performance, the number of returned messages is chosen by
     * TDLib
     */
    readonly _: 'searchSecretMessages',
    /**
     * Identifier of the chat in which to search. Specify 0 to search in all secret
     * chats
     */
    readonly chat_id?: number,
    /** Query to search for. If empty, searchChatMessages must be used instead */
    readonly query?: string,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** Additional filter for messages to search; pass null to search for all messages */
    readonly filter?: SearchMessagesFilter$Input,
  }

  export type searchCallMessages = {
    /**
     * Searches for call messages. Returns the results in reverse chronological order
     * (i. e., in order of decreasing message_id). For optimal performance, the number
     * of returned messages is chosen by TDLib
     */
    readonly _: 'searchCallMessages',
    /**
     * Identifier of the message from which to search; use 0 to get results from the
     * last message
     */
    readonly from_message_id?: number,
    /**
     * The maximum number of messages to be returned; up to 100. For optimal performance,
     * the number of returned messages is chosen by TDLib and can be smaller than the
     * specified limit
     */
    readonly limit?: number,
    /** If true, returns only messages with missed/declined calls */
    readonly only_missed?: boolean,
  }

  export type deleteAllCallMessages = {
    /** Deletes all call messages */
    readonly _: 'deleteAllCallMessages',
    /** Pass true to delete the messages for all users */
    readonly revoke?: boolean,
  }

  export type searchChatRecentLocationMessages = {
    /**
     * Returns information about the recent locations of chat members that were sent
     * to the chat. Returns up to 1 location message per user
     */
    readonly _: 'searchChatRecentLocationMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The maximum number of messages to be returned */
    readonly limit?: number,
  }

  export type getActiveLiveLocationMessages = {
    /**
     * Returns all active live locations that need to be updated by the application.
     * The list is persistent across application restarts only if the message database
     * is used
     */
    readonly _: 'getActiveLiveLocationMessages',
  }

  export type getChatMessageByDate = {
    /** Returns the last message sent in a chat no later than the specified date */
    readonly _: 'getChatMessageByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Point in time (Unix timestamp) relative to which to search for messages */
    readonly date?: number,
  }

  export type getChatSparseMessagePositions = {
    /**
     * Returns sparse positions of messages of the specified type in the chat to be
     * used for shared media scroll implementation. Returns the results in reverse
     * chronological order (i.e., in order of decreasing message_id). Cannot be used
     * in secret chats or with searchMessagesFilterFailedToSend filter without an enabled
     * message database
     */
    readonly _: 'getChatSparseMessagePositions',
    /** Identifier of the chat in which to return information about message positions */
    readonly chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention
     * and searchMessagesFilterUnreadMention are unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /** The message identifier from which to return information about message positions */
    readonly from_message_id?: number,
    /**
     * The expected number of message positions to be returned; 50-2000. A smaller
     * number of positions can be returned, if there are not enough appropriate messages
     */
    readonly limit?: number,
  }

  export type getChatMessageCalendar = {
    /**
     * Returns information about the next messages of the specified type in the chat
     * split by days. Returns the results in reverse chronological order. Can return
     * partial result for the last returned day. Behavior of this method depends on
     * the value of the option "utc_time_offset"
     */
    readonly _: 'getChatMessageCalendar',
    /** Identifier of the chat in which to return information about messages */
    readonly chat_id?: number,
    /**
     * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention
     * and searchMessagesFilterUnreadMention are unsupported in this function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * The message identifier from which to return information about messages; use
     * 0 to get results from the last message
     */
    readonly from_message_id?: number,
  }

  export type getChatMessageCount = {
    /** Returns approximate number of messages of the specified type in the chat */
    readonly _: 'getChatMessageCount',
    /** Identifier of the chat in which to count messages */
    readonly chat_id?: number,
    /**
     * Filter for message content; searchMessagesFilterEmpty is unsupported in this
     * function
     */
    readonly filter?: SearchMessagesFilter$Input,
    /**
     * If true, returns count that is available locally without sending network requests,
     * returning -1 if the number of messages is unknown
     */
    readonly return_local?: boolean,
  }

  export type getChatScheduledMessages = {
    /**
     * Returns all scheduled messages in a chat. The messages are returned in a reverse
     * chronological order (i.e., in order of decreasing message_id)
     */
    readonly _: 'getChatScheduledMessages',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getMessagePublicForwards = {
    /**
     * Returns forwarded copies of a channel message to different public channels.
     * For optimal performance, the number of returned messages is chosen by TDLib
     */
    readonly _: 'getMessagePublicForwards',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /**
     * Offset of the first entry to return as received from the previous request; use
     * empty string to get first chunk of results
     */
    readonly offset?: string,
    /**
     * The maximum number of messages to be returned; must be positive and can't be
     * greater than 100. For optimal performance, the number of returned messages is
     * chosen by TDLib and can be smaller than the specified limit
     */
    readonly limit?: number,
  }

  export type getChatSponsoredMessage = {
    /**
     * Returns sponsored message to be shown in a chat; for channel chats only. Returns
     * a 404 error if there is no sponsored message in the chat
     */
    readonly _: 'getChatSponsoredMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type removeNotification = {
    /**
     * Removes an active notification from notification list. Needs to be called only
     * if the notification is removed by the current user
     */
    readonly _: 'removeNotification',
    /** Identifier of notification group to which the notification belongs */
    readonly notification_group_id?: number,
    /** Identifier of removed notification */
    readonly notification_id?: number,
  }

  export type removeNotificationGroup = {
    /**
     * Removes a group of active notifications. Needs to be called only if the notification
     * group is removed by the current user
     */
    readonly _: 'removeNotificationGroup',
    /** Notification group identifier */
    readonly notification_group_id?: number,
    /** The maximum identifier of removed notifications */
    readonly max_notification_id?: number,
  }

  export type getMessageLink = {
    /**
     * Returns an HTTPS link to a message in a chat. Available only for already sent
     * messages in supergroups and channels, or if message.can_get_media_timestamp_links
     * and a media timestamp link is generated. This is an offline request
     */
    readonly _: 'getMessageLink',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /**
     * If not 0, timestamp from which the video/audio/video note/voice note playing
     * must start, in seconds. The media can be in the message content or in its web
     * page preview
     */
    readonly media_timestamp?: number,
    /** Pass true to create a link for the whole media album */
    readonly for_album?: boolean,
    /**
     * Pass true to create a link to the message as a channel post comment, or from
     * a message thread
     */
    readonly for_comment?: boolean,
  }

  export type getMessageEmbeddingCode = {
    /**
     * Returns an HTML code for embedding the message. Available only for messages
     * in supergroups and channels with a username
     */
    readonly _: 'getMessageEmbeddingCode',
    /** Identifier of the chat to which the message belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** Pass true to return an HTML code for embedding of the whole media album */
    readonly for_album?: boolean,
  }

  export type getMessageLinkInfo = {
    /**
     * Returns information about a public or private message link. Can be called for
     * any internal link of the type internalLinkTypeMessage
     */
    readonly _: 'getMessageLinkInfo',
    /** The message link */
    readonly url?: string,
  }

  export type getChatAvailableMessageSenders = {
    /**
     * Returns list of message sender identifiers, which can be used to send messages
     * in a chat
     */
    readonly _: 'getChatAvailableMessageSenders',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setChatMessageSender = {
    /** Selects a message sender to send messages in a chat */
    readonly _: 'setChatMessageSender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New message sender for the chat */
    readonly message_sender_id?: MessageSender$Input,
  }

  export type sendMessage = {
    /** Sends a message. Returns the sent message */
    readonly _: 'sendMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Identifier of the message to reply to or 0 */
    readonly reply_to_message_id?: number,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Markup for replying to the message; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** The content of the message to be sent */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type sendMessageAlbum = {
    /**
     * Sends 2-10 messages grouped together into an album. Currently, only audio, document,
     * photo and video messages can be grouped into an album. Documents and audio files
     * can be only grouped in an album with messages of the same type. Returns sent
     * messages
     */
    readonly _: 'sendMessageAlbum',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the messages will be sent */
    readonly message_thread_id?: number,
    /** Identifier of a message to reply to or 0 */
    readonly reply_to_message_id?: number,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Contents of messages to be sent. At most 10 messages can be added to an album */
    readonly input_message_contents?: ReadonlyArray<InputMessageContent$Input>,
  }

  export type sendBotStartMessage = {
    /**
     * Invites a bot to a chat (if it is not yet a member) and sends it the /start
     * command. Bots can't be invited to a private chat other than the chat with the
     * bot. Bots can't be invited to channels (although they can be added as admins)
     * and secret chats. Returns the sent message
     */
    readonly _: 'sendBotStartMessage',
    /** Identifier of the bot */
    readonly bot_user_id?: number,
    /** Identifier of the target chat */
    readonly chat_id?: number,
    /** A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking) */
    readonly parameter?: string,
  }

  export type sendInlineQueryResultMessage = {
    /**
     * Sends the result of an inline query as a message. Returns the sent message.
     * Always clears a chat draft message
     */
    readonly _: 'sendInlineQueryResultMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the message will be sent */
    readonly message_thread_id?: number,
    /** Identifier of a message to reply to or 0 */
    readonly reply_to_message_id?: number,
    /** Options to be used to send the message; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /** Identifier of the inline query */
    readonly query_id?: number | string,
    /** Identifier of the inline result */
    readonly result_id?: string,
    /**
     * If true, there will be no mention of a bot, via which the message is sent. Can
     * be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username")
     * and GetOption("venue_search_bot_username")
     */
    readonly hide_via_bot?: boolean,
  }

  export type forwardMessages = {
    /**
     * Forwards previously sent messages. Returns the forwarded messages in the same
     * order as the message identifiers passed in message_ids. If a message can't be
     * forwarded, null will be returned instead of the message
     */
    readonly _: 'forwardMessages',
    /** Identifier of the chat to which to forward messages */
    readonly chat_id?: number,
    /** Identifier of the chat from which to forward messages */
    readonly from_chat_id?: number,
    /**
     * Identifiers of the messages to forward. Message identifiers must be in a strictly
     * increasing order. At most 100 messages can be forwarded simultaneously
     */
    readonly message_ids?: ReadonlyArray<number>,
    /** Options to be used to send the messages; pass null to use default options */
    readonly options?: messageSendOptions$Input,
    /**
     * If true, content of the messages will be copied without reference to the original
     * sender. Always true if the messages are forwarded to a secret chat or are local
     */
    readonly send_copy?: boolean,
    /**
     * If true, media caption of message copies will be removed. Ignored if send_copy
     * is false
     */
    readonly remove_caption?: boolean,
    /** If true, messages will not be forwarded and instead fake messages will be returned */
    readonly only_preview?: boolean,
  }

  export type resendMessages = {
    /**
     * Resends messages which failed to send. Can be called only for messages for which
     * messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after
     * time passed. If a message is re-sent, the corresponding failed to send message
     * is deleted. Returns the sent messages in the same order as the message identifiers
     * passed in message_ids. If a message can't be re-sent, null will be returned
     * instead of the message
     */
    readonly _: 'resendMessages',
    /** Identifier of the chat to send messages */
    readonly chat_id?: number,
    /**
     * Identifiers of the messages to resend. Message identifiers must be in a strictly
     * increasing order
     */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type sendChatScreenshotTakenNotification = {
    /**
     * Sends a notification about a screenshot taken in a chat. Supported only in private
     * and secret chats
     */
    readonly _: 'sendChatScreenshotTakenNotification',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addLocalMessage = {
    /**
     * Adds a local message to a chat. The message is persistent across application
     * restarts only if the message database is used. Returns the added message
     */
    readonly _: 'addLocalMessage',
    /** Target chat */
    readonly chat_id?: number,
    /** Identifier of the sender of the message */
    readonly sender_id?: MessageSender$Input,
    /** Identifier of the message to reply to or 0 */
    readonly reply_to_message_id?: number,
    /** Pass true to disable notification for the message */
    readonly disable_notification?: boolean,
    /** The content of the message to be added */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type deleteMessages = {
    /** Deletes messages */
    readonly _: 'deleteMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifiers of the messages to be deleted */
    readonly message_ids?: ReadonlyArray<number>,
    /**
     * Pass true to delete messages for all chat members. Always true for supergroups,
     * channels and secret chats
     */
    readonly revoke?: boolean,
  }

  export type deleteChatMessagesBySender = {
    /**
     * Deletes all messages sent by the specified message sender in a chat. Supported
     * only for supergroups; requires can_delete_messages administrator privileges
     */
    readonly _: 'deleteChatMessagesBySender',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the sender of messages to delete */
    readonly sender_id?: MessageSender$Input,
  }

  export type deleteChatMessagesByDate = {
    /**
     * Deletes all messages between the specified dates in a chat. Supported only for
     * private chats and basic groups. Messages sent in the last 30 seconds will not
     * be deleted
     */
    readonly _: 'deleteChatMessagesByDate',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The minimum date of the messages to delete */
    readonly min_date?: number,
    /** The maximum date of the messages to delete */
    readonly max_date?: number,
    /** Pass true to delete chat messages for all users; private chats only */
    readonly revoke?: boolean,
  }

  export type editMessageText = {
    /**
     * Edits the text of a message (or a text of a game message). Returns the edited
     * message after the edit is completed on the server side
     */
    readonly _: 'editMessageText',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageLiveLocation = {
    /**
     * Edits the message content of a live location. Messages can be edited for a limited
     * period of time specified in the live location. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageLiveLocation',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editMessageMedia = {
    /**
     * Edits the content of a message with an animation, an audio, a document, a photo
     * or a video, including message caption. If only the caption needs to be edited,
     * use editMessageCaption instead. The media can't be edited if the message was
     * set to self-destruct or to a self-destructing media. The type of message content
     * in an album can't be changed with exception of replacing a photo with a video
     * or vice versa. Returns the edited message after the edit is completed on the
     * server side
     */
    readonly _: 'editMessageMedia',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editMessageCaption = {
    /**
     * Edits the message content caption. Returns the edited message after the edit
     * is completed on the server side
     */
    readonly _: 'editMessageCaption',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; 0-GetOption("message_caption_length_max") characters;
     * pass null to remove caption
     */
    readonly caption?: formattedText$Input,
  }

  export type editMessageReplyMarkup = {
    /**
     * Edits the message reply markup; for bots only. Returns the edited message after
     * the edit is completed on the server side
     */
    readonly _: 'editMessageReplyMarkup',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editInlineMessageText = {
    /** Edits the text of an inline text or game message sent via a bot; for bots only */
    readonly _: 'editInlineMessageText',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New text content of the message. Must be of type inputMessageText */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageLiveLocation = {
    /**
     * Edits the content of a live location in an inline message sent via a bot; for
     * bots only
     */
    readonly _: 'editInlineMessageLiveLocation',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /** New location content of the message; pass null to stop sharing the live location */
    readonly location?: location$Input,
    /**
     * The new direction in which the location moves, in degrees; 1-360. Pass 0 if
     * unknown
     */
    readonly heading?: number,
    /**
     * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0
     * if the notification is disabled
     */
    readonly proximity_alert_radius?: number,
  }

  export type editInlineMessageMedia = {
    /**
     * Edits the content of a message with an animation, an audio, a document, a photo
     * or a video in an inline message sent via a bot; for bots only
     */
    readonly _: 'editInlineMessageMedia',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New content of the message. Must be one of the following types: inputMessageAnimation,
     * inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
     */
    readonly input_message_content?: InputMessageContent$Input,
  }

  export type editInlineMessageCaption = {
    /** Edits the caption of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageCaption',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
    /**
     * New message content caption; pass null to remove caption; 0-GetOption("message_caption_length_max")
     * characters
     */
    readonly caption?: formattedText$Input,
  }

  export type editInlineMessageReplyMarkup = {
    /** Edits the reply markup of an inline message sent via a bot; for bots only */
    readonly _: 'editInlineMessageReplyMarkup',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** The new message reply markup; pass null if none */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type editMessageSchedulingState = {
    /**
     * Edits the time when a scheduled message will be sent. Scheduling state of all
     * messages in the same album or forwarded together with the message will be also
     * changed
     */
    readonly _: 'editMessageSchedulingState',
    /** The chat the message belongs to */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** The new message scheduling state; pass null to send the message immediately */
    readonly scheduling_state?: MessageSchedulingState$Input,
  }

  export type getTextEntities = {
    /**
     * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card
     * numbers, URLs, and email addresses) contained in the text. Can be called synchronously
     */
    readonly _: 'getTextEntities',
    /** The text in which to look for entites */
    readonly text?: string,
  }

  export type parseTextEntities = {
    /**
     * Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and
     * MentionName entities contained in the text. Can be called synchronously
     */
    readonly _: 'parseTextEntities',
    /** The text to parse */
    readonly text?: string,
    /** Text parse mode */
    readonly parse_mode?: TextParseMode$Input,
  }

  export type parseMarkdown = {
    /**
     * Parses Markdown entities in a human-friendly format, ignoring markup errors.
     * Can be called synchronously
     */
    readonly _: 'parseMarkdown',
    /**
     * The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code`
     * ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
     */
    readonly text?: formattedText$Input,
  }

  export type getMarkdownText = {
    /**
     * Replaces text entities with Markdown formatting in a human-friendly format.
     * Entities that can't be represented in Markdown unambiguously are kept as is.
     * Can be called synchronously
     */
    readonly _: 'getMarkdownText',
    /** The text */
    readonly text?: formattedText$Input,
  }

  export type getFileMimeType = {
    /**
     * Returns the MIME type of a file, guessed by its extension. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileMimeType',
    /** The name of the file or path to the file */
    readonly file_name?: string,
  }

  export type getFileExtension = {
    /**
     * Returns the extension of a file, guessed by its MIME type. Returns an empty
     * string on failure. Can be called synchronously
     */
    readonly _: 'getFileExtension',
    /** The MIME type of the file */
    readonly mime_type?: string,
  }

  export type cleanFileName = {
    /**
     * Removes potentially dangerous characters from the name of a file. The encoding
     * of the file name is supposed to be UTF-8. Returns an empty string on failure.
     * Can be called synchronously
     */
    readonly _: 'cleanFileName',
    /** File name or path to the file */
    readonly file_name?: string,
  }

  export type getLanguagePackString = {
    /**
     * Returns a string stored in the local database from the specified localization
     * target and language pack by its key. Returns a 404 error if the string is not
     * found. Can be called synchronously
     */
    readonly _: 'getLanguagePackString',
    /** Path to the language pack database in which strings are stored */
    readonly language_pack_database_path?: string,
    /** Localization target to which the language pack belongs */
    readonly localization_target?: string,
    /** Language pack identifier */
    readonly language_pack_id?: string,
    /** Language pack key of the string to be returned */
    readonly key?: string,
  }

  export type getJsonValue = {
    /**
     * Converts a JSON-serialized string to corresponding JsonValue object. Can be
     * called synchronously
     */
    readonly _: 'getJsonValue',
    /** The JSON-serialized string */
    readonly json?: string,
  }

  export type getJsonString = {
    /**
     * Converts a JsonValue object to corresponding JSON-serialized string. Can be
     * called synchronously
     */
    readonly _: 'getJsonString',
    /** The JsonValue object */
    readonly json_value?: JsonValue$Input,
  }

  export type setPollAnswer = {
    /**
     * Changes the user answer to a poll. A poll in quiz mode can be answered only
     * once
     */
    readonly _: 'setPollAnswer',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /**
     * 0-based identifiers of answer options, chosen by the user. User can choose more
     * than 1 answer option only is the poll allows multiple answers
     */
    readonly option_ids?: ReadonlyArray<number>,
  }

  export type getPollVoters = {
    /**
     * Returns users voted for the specified option in a non-anonymous polls. For optimal
     * performance, the number of returned users is chosen by TDLib
     */
    readonly _: 'getPollVoters',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** 0-based identifier of the answer option */
    readonly option_id?: number,
    /** Number of users to skip in the result; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of users to be returned; must be positive and can't be greater
     * than 50. For optimal performance, the number of returned users is chosen by
     * TDLib and can be smaller than the specified limit, even if the end of the voter
     * list has not been reached
     */
    readonly limit?: number,
  }

  export type stopPoll = {
    /**
     * Stops a poll. A poll in a message can be stopped when the message has can_be_edited
     * flag set
     */
    readonly _: 'stopPoll',
    /** Identifier of the chat to which the poll belongs */
    readonly chat_id?: number,
    /** Identifier of the message containing the poll */
    readonly message_id?: number,
    /** The new message reply markup; pass null if none; for bots only */
    readonly reply_markup?: ReplyMarkup$Input,
  }

  export type hideSuggestedAction = {
    /** Hides a suggested action */
    readonly _: 'hideSuggestedAction',
    /** Suggested action to hide */
    readonly action?: SuggestedAction$Input,
  }

  export type getLoginUrlInfo = {
    /**
     * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl.
     * The method needs to be called when the user presses the button
     */
    readonly _: 'getLoginUrlInfo',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
  }

  export type getLoginUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the user on
     * a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
     * Use the method getLoginUrlInfo to find whether a prior user confirmation is
     * needed. If an error is returned, then the button must be handled as an ordinary
     * URL button
     */
    readonly _: 'getLoginUrl',
    /** Chat identifier of the message with the button */
    readonly chat_id?: number,
    /** Message identifier of the message with the button */
    readonly message_id?: number,
    /** Button identifier */
    readonly button_id?: number,
    /** True, if the user allowed the bot to send them messages */
    readonly allow_write_access?: boolean,
  }

  export type getInlineQueryResults = {
    /**
     * Sends an inline query to a bot and returns its results. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getInlineQueryResults',
    /** The identifier of the target bot */
    readonly bot_user_id?: number,
    /** Identifier of the chat where the query was sent */
    readonly chat_id?: number,
    /** Location of the user; pass null if unknown or the bot doesn't need user's location */
    readonly user_location?: location$Input,
    /** Text of the query */
    readonly query?: string,
    /** Offset of the first entry to return */
    readonly offset?: string,
  }

  export type answerInlineQuery = {
    /** Sets the result of an inline query; for bots only */
    readonly _: 'answerInlineQuery',
    /** Identifier of the inline query */
    readonly inline_query_id?: number | string,
    /** True, if the result of the query can be cached for the specified user */
    readonly is_personal?: boolean,
    /** The results of the query */
    readonly results?: ReadonlyArray<InputInlineQueryResult$Input>,
    /** Allowed time to cache the results of the query, in seconds */
    readonly cache_time?: number,
    /**
     * Offset for the next inline query; pass an empty string if there are no more
     * results
     */
    readonly next_offset?: string,
    /**
     * If non-empty, this text must be shown on the button that opens a private chat
     * with the bot and sends a start message to the bot with the parameter switch_pm_parameter
     */
    readonly switch_pm_text?: string,
    /** The parameter for the bot start message */
    readonly switch_pm_parameter?: string,
  }

  export type getCallbackQueryAnswer = {
    /**
     * Sends a callback query to a bot and returns an answer. Returns an error with
     * code 502 if the bot fails to answer the query before the query timeout expires
     */
    readonly _: 'getCallbackQueryAnswer',
    /** Identifier of the chat with the message */
    readonly chat_id?: number,
    /** Identifier of the message from which the query originated */
    readonly message_id?: number,
    /** Query payload */
    readonly payload?: CallbackQueryPayload$Input,
  }

  export type answerCallbackQuery = {
    /** Sets the result of a callback query; for bots only */
    readonly _: 'answerCallbackQuery',
    /** Identifier of the callback query */
    readonly callback_query_id?: number | string,
    /** Text of the answer */
    readonly text?: string,
    /** If true, an alert must be shown to the user instead of a toast notification */
    readonly show_alert?: boolean,
    /** URL to be opened */
    readonly url?: string,
    /** Time during which the result of the query can be cached, in seconds */
    readonly cache_time?: number,
  }

  export type answerShippingQuery = {
    /** Sets the result of a shipping query; for bots only */
    readonly _: 'answerShippingQuery',
    /** Identifier of the shipping query */
    readonly shipping_query_id?: number | string,
    /** Available shipping options */
    readonly shipping_options?: ReadonlyArray<shippingOption$Input>,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type answerPreCheckoutQuery = {
    /** Sets the result of a pre-checkout query; for bots only */
    readonly _: 'answerPreCheckoutQuery',
    /** Identifier of the pre-checkout query */
    readonly pre_checkout_query_id?: number | string,
    /** An error message, empty on success */
    readonly error_message?: string,
  }

  export type setGameScore = {
    /** Updates the game score of the specified user in the game; for bots only */
    readonly _: 'setGameScore',
    /** The chat to which the message with the game belongs */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** True, if the message needs to be edited */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type setInlineGameScore = {
    /** Updates the game score of the specified user in a game; for bots only */
    readonly _: 'setInlineGameScore',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** True, if the message needs to be edited */
    readonly edit_message?: boolean,
    /** User identifier */
    readonly user_id?: number,
    /** The new score */
    readonly score?: number,
    /**
     * Pass true to update the score even if it decreases. If the score is 0, the user
     * will be deleted from the high score table
     */
    readonly force?: boolean,
  }

  export type getGameHighScores = {
    /**
     * Returns the high scores for a game and some part of the high score table in
     * the range of the specified user; for bots only
     */
    readonly _: 'getGameHighScores',
    /** The chat that contains the message with the game */
    readonly chat_id?: number,
    /** Identifier of the message */
    readonly message_id?: number,
    /** User identifier */
    readonly user_id?: number,
  }

  export type getInlineGameHighScores = {
    /**
     * Returns game high scores and some part of the high score table in the range
     * of the specified user; for bots only
     */
    readonly _: 'getInlineGameHighScores',
    /** Inline message identifier */
    readonly inline_message_id?: string,
    /** User identifier */
    readonly user_id?: number,
  }

  export type deleteChatReplyMarkup = {
    /**
     * Deletes the default reply markup from a chat. Must be called after a one-time
     * keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will
     * be sent if the reply markup is changed
     */
    readonly _: 'deleteChatReplyMarkup',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The message identifier of the used keyboard */
    readonly message_id?: number,
  }

  export type sendChatAction = {
    /** Sends a notification about user activity in a chat */
    readonly _: 'sendChatAction',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the action was performed */
    readonly message_thread_id?: number,
    /** The action description; pass null to cancel the currently active action */
    readonly action?: ChatAction$Input,
  }

  export type openChat = {
    /**
     * Informs TDLib that the chat is opened by the user. Many useful activities depend
     * on the chat being opened or closed (e.g., in supergroups and channels all updates
     * are received only for opened chats)
     */
    readonly _: 'openChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type closeChat = {
    /**
     * Informs TDLib that the chat is closed by the user. Many useful activities depend
     * on the chat being opened or closed
     */
    readonly _: 'closeChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type viewMessages = {
    /**
     * Informs TDLib that messages are being viewed by the user. Sponsored messages
     * must be marked as viewed only when the entire text of the message is shown on
     * the screen (excluding the button). Many useful activities depend on whether
     * the messages are currently being viewed or not (e.g., marking messages as read,
     * incrementing a view counter, updating a view counter, removing deleted messages
     * in supergroups and channels)
     */
    readonly _: 'viewMessages',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the messages are being viewed */
    readonly message_thread_id?: number,
    /** The identifiers of the messages being viewed */
    readonly message_ids?: ReadonlyArray<number>,
    /** True, if messages in closed chats must be marked as read by the request */
    readonly force_read?: boolean,
  }

  export type openMessageContent = {
    /**
     * Informs TDLib that the message content has been opened (e.g., the user has opened
     * a photo, video, document, location or venue, or has listened to an audio file
     * or voice note message). An updateMessageContentOpened update will be generated
     * if something has changed
     */
    readonly _: 'openMessageContent',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the message with the opened content */
    readonly message_id?: number,
  }

  export type clickAnimatedEmojiMessage = {
    /**
     * Informs TDLib that a message with an animated emoji was clicked by the user.
     * Returns a big animated sticker to be played or a 404 error if usual animation
     * needs to be played
     */
    readonly _: 'clickAnimatedEmojiMessage',
    /** Chat identifier of the message */
    readonly chat_id?: number,
    /** Identifier of the clicked message */
    readonly message_id?: number,
  }

  export type getInternalLinkType = {
    /**
     * Returns information about the type of an internal link. Returns a 404 error
     * if the link is not internal. Can be called before authorization
     */
    readonly _: 'getInternalLinkType',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLinkInfo = {
    /**
     * Returns information about an action to be done when the current user clicks
     * an external link. Don't use this method for links from secret chats if web page
     * preview is disabled in secret chats
     */
    readonly _: 'getExternalLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getExternalLink = {
    /**
     * Returns an HTTP URL which can be used to automatically authorize the current
     * user on a website after clicking an HTTP link. Use the method getExternalLinkInfo
     * to find whether a prior user confirmation is needed
     */
    readonly _: 'getExternalLink',
    /** The HTTP link */
    readonly link?: string,
    /**
     * True, if the current user allowed the bot, returned in getExternalLinkInfo,
     * to send them messages
     */
    readonly allow_write_access?: boolean,
  }

  export type readAllChatMentions = {
    /** Marks all mentions in a chat as read */
    readonly _: 'readAllChatMentions',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type createPrivateChat = {
    /** Returns an existing chat corresponding to a given user */
    readonly _: 'createPrivateChat',
    /** User identifier */
    readonly user_id?: number,
    /**
     * If true, the chat will be created without network request. In this case all
     * information about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createBasicGroupChat = {
    /** Returns an existing chat corresponding to a known basic group */
    readonly _: 'createBasicGroupChat',
    /** Basic group identifier */
    readonly basic_group_id?: number,
    /**
     * If true, the chat will be created without network request. In this case all
     * information about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSupergroupChat = {
    /** Returns an existing chat corresponding to a known supergroup or channel */
    readonly _: 'createSupergroupChat',
    /** Supergroup or channel identifier */
    readonly supergroup_id?: number,
    /**
     * If true, the chat will be created without network request. In this case all
     * information about the chat except its type, title and photo can be incorrect
     */
    readonly force?: boolean,
  }

  export type createSecretChat = {
    /** Returns an existing chat corresponding to a known secret chat */
    readonly _: 'createSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type createNewBasicGroupChat = {
    /**
     * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate.
     * Returns the newly created chat
     */
    readonly _: 'createNewBasicGroupChat',
    /** Identifiers of users to be added to the basic group */
    readonly user_ids?: ReadonlyArray<number>,
    /** Title of the new basic group; 1-128 characters */
    readonly title?: string,
  }

  export type createNewSupergroupChat = {
    /**
     * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate.
     * Returns the newly created chat
     */
    readonly _: 'createNewSupergroupChat',
    /** Title of the new chat; 1-128 characters */
    readonly title?: string,
    /** True, if a channel chat needs to be created */
    readonly is_channel?: boolean,
    /** Chat description; 0-255 characters */
    readonly description?: string,
    /**
     * Chat location if a location-based supergroup is being created; pass null to
     * create an ordinary supergroup chat
     */
    readonly location?: chatLocation$Input,
    /** True, if the supergroup is created for importing messages using importMessage */
    readonly for_import?: boolean,
  }

  export type createNewSecretChat = {
    /** Creates a new secret chat. Returns the newly created chat */
    readonly _: 'createNewSecretChat',
    /** Identifier of the target user */
    readonly user_id?: number,
  }

  export type upgradeBasicGroupChatToSupergroupChat = {
    /**
     * Creates a new supergroup from an existing basic group and sends a corresponding
     * messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges.
     * Deactivates the original basic group
     */
    readonly _: 'upgradeBasicGroupChatToSupergroupChat',
    /** Identifier of the chat to upgrade */
    readonly chat_id?: number,
  }

  export type getChatListsToAddChat = {
    /** Returns chat lists to which the chat can be added. This is an offline request */
    readonly _: 'getChatListsToAddChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatToList = {
    /**
     * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive
     * chat lists, so it is automatically removed from another one if needed
     */
    readonly _: 'addChatToList',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The chat list. Use getChatListsToAddChat to get suitable chat lists */
    readonly chat_list?: ChatList$Input,
  }

  export type getChatFilter = {
    /** Returns information about a chat filter by its identifier */
    readonly _: 'getChatFilter',
    /** Chat filter identifier */
    readonly chat_filter_id?: number,
  }

  export type createChatFilter = {
    /** Creates new chat filter. Returns information about the created chat filter */
    readonly _: 'createChatFilter',
    /** Chat filter */
    readonly filter?: chatFilter$Input,
  }

  export type editChatFilter = {
    /** Edits existing chat filter. Returns information about the edited chat filter */
    readonly _: 'editChatFilter',
    /** Chat filter identifier */
    readonly chat_filter_id?: number,
    /** The edited chat filter */
    readonly filter?: chatFilter$Input,
  }

  export type deleteChatFilter = {
    /** Deletes existing chat filter */
    readonly _: 'deleteChatFilter',
    /** Chat filter identifier */
    readonly chat_filter_id?: number,
  }

  export type reorderChatFilters = {
    /** Changes the order of chat filters */
    readonly _: 'reorderChatFilters',
    /** Identifiers of chat filters in the new correct order */
    readonly chat_filter_ids?: ReadonlyArray<number>,
  }

  export type getRecommendedChatFilters = {
    /** Returns recommended chat filters for the current user */
    readonly _: 'getRecommendedChatFilters',
  }

  export type getChatFilterDefaultIconName = {
    /** Returns default icon name for a filter. Can be called synchronously */
    readonly _: 'getChatFilterDefaultIconName',
    /** Chat filter */
    readonly filter?: chatFilter$Input,
  }

  export type setChatTitle = {
    /**
     * Changes the chat title. Supported only for basic groups, supergroups and channels.
     * Requires can_change_info administrator right
     */
    readonly _: 'setChatTitle',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New title of the chat; 1-128 characters */
    readonly title?: string,
  }

  export type setChatPhoto = {
    /**
     * Changes the photo of a chat. Supported only for basic groups, supergroups and
     * channels. Requires can_change_info administrator right
     */
    readonly _: 'setChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New chat photo; pass null to delete the chat photo */
    readonly photo?: InputChatPhoto$Input,
  }

  export type setChatMessageTtl = {
    /**
     * Changes the message TTL in a chat. Requires can_delete_messages administrator
     * right in basic groups, supergroups and channels Message TTL can't be changed
     * in a chat with the current user (Saved Messages) and the chat 777000 (Telegram)
     */
    readonly _: 'setChatMessageTtl',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New TTL value, in seconds; must be one of 0, 86400, 7 * 86400, or 31 * 86400
     * unless the chat is secret
     */
    readonly ttl?: number,
  }

  export type setChatPermissions = {
    /**
     * Changes the chat members permissions. Supported only for basic groups and supergroups.
     * Requires can_restrict_members administrator right
     */
    readonly _: 'setChatPermissions',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New non-administrator members permissions in the chat */
    readonly permissions?: chatPermissions$Input,
  }

  export type setChatTheme = {
    /** Changes the chat theme. Supported only in private and secret chats */
    readonly _: 'setChatTheme',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Name of the new chat theme; pass an empty string to return the default theme */
    readonly theme_name?: string,
  }

  export type setChatDraftMessage = {
    /** Changes the draft message in a chat */
    readonly _: 'setChatDraftMessage',
    /** Chat identifier */
    readonly chat_id?: number,
    /** If not 0, a message thread identifier in which the draft was changed */
    readonly message_thread_id?: number,
    /** New draft message; pass null to remove the draft */
    readonly draft_message?: draftMessage$Input,
  }

  export type setChatNotificationSettings = {
    /**
     * Changes the notification settings of a chat. Notification settings of a chat
     * with the current user (Saved Messages) can't be changed
     */
    readonly _: 'setChatNotificationSettings',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New notification settings for the chat. If the chat is muted for more than 1
     * week, it is considered to be muted forever
     */
    readonly notification_settings?: chatNotificationSettings$Input,
  }

  export type toggleChatHasProtectedContent = {
    /**
     * Changes the ability of users to save, forward, or copy chat content. Supported
     * only for basic groups, supergroups and channels. Requires owner privileges
     */
    readonly _: 'toggleChatHasProtectedContent',
    /** Chat identifier */
    readonly chat_id?: number,
    /** True, if chat content can't be saved locally, forwarded, or copied */
    readonly has_protected_content?: boolean,
  }

  export type toggleChatIsMarkedAsUnread = {
    /** Changes the marked as unread state of a chat */
    readonly _: 'toggleChatIsMarkedAsUnread',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of is_marked_as_unread */
    readonly is_marked_as_unread?: boolean,
  }

  export type toggleChatDefaultDisableNotification = {
    /**
     * Changes the value of the default disable_notification parameter, used when a
     * message is sent to a chat
     */
    readonly _: 'toggleChatDefaultDisableNotification',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of default_disable_notification */
    readonly default_disable_notification?: boolean,
  }

  export type setChatClientData = {
    /** Changes application-specific data associated with a chat */
    readonly _: 'setChatClientData',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New value of client_data */
    readonly client_data?: string,
  }

  export type setChatDescription = {
    /**
     * Changes information about a chat. Available for basic groups, supergroups, and
     * channels. Requires can_change_info administrator right
     */
    readonly _: 'setChatDescription',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** New chat description; 0-255 characters */
    readonly description?: string,
  }

  export type setChatDiscussionGroup = {
    /**
     * Changes the discussion group of a channel chat; requires can_change_info administrator
     * right in the channel if it is specified
     */
    readonly _: 'setChatDiscussionGroup',
    /**
     * Identifier of the channel chat. Pass 0 to remove a link from the supergroup
     * passed in the second argument to a linked channel chat (requires can_pin_messages
     * rights in the supergroup)
     */
    readonly chat_id?: number,
    /**
     * Identifier of a new channel's discussion group. Use 0 to remove the discussion
     * group. Use the method getSuitableDiscussionChats to find all suitable groups.
     * Basic group chats must be first upgraded to supergroup chats. If new chat members
     * don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable
     * must be used first to change that
     */
    readonly discussion_chat_id?: number,
  }

  export type setChatLocation = {
    /**
     * Changes the location of a chat. Available only for some location-based supergroups,
     * use supergroupFullInfo.can_set_location to check whether the method is allowed
     * to use
     */
    readonly _: 'setChatLocation',
    /** Chat identifier */
    readonly chat_id?: number,
    /** New location for the chat; must be valid and not null */
    readonly location?: chatLocation$Input,
  }

  export type setChatSlowModeDelay = {
    /**
     * Changes the slow mode delay of a chat. Available only for supergroups; requires
     * can_restrict_members rights
     */
    readonly _: 'setChatSlowModeDelay',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60,
     * 300, 900, 3600
     */
    readonly slow_mode_delay?: number,
  }

  export type pinChatMessage = {
    /**
     * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages
     * rights in the channel
     */
    readonly _: 'pinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the new pinned message */
    readonly message_id?: number,
    /**
     * True, if there must be no notification about the pinned message. Notifications
     * are always disabled in channels and private chats
     */
    readonly disable_notification?: boolean,
    /** True, if the message needs to be pinned for one side only; private chats only */
    readonly only_for_self?: boolean,
  }

  export type unpinChatMessage = {
    /**
     * Removes a pinned message from a chat; requires can_pin_messages rights in the
     * group or can_edit_messages rights in the channel
     */
    readonly _: 'unpinChatMessage',
    /** Identifier of the chat */
    readonly chat_id?: number,
    /** Identifier of the removed pinned message */
    readonly message_id?: number,
  }

  export type unpinAllChatMessages = {
    /**
     * Removes all pinned messages from a chat; requires can_pin_messages rights in
     * the group or can_edit_messages rights in the channel
     */
    readonly _: 'unpinAllChatMessages',
    /** Identifier of the chat */
    readonly chat_id?: number,
  }

  export type joinChat = {
    /**
     * Adds the current user as a new member to a chat. Private and secret chats can't
     * be joined using this method
     */
    readonly _: 'joinChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type leaveChat = {
    /**
     * Removes the current user from chat members. Private and secret chats can't be
     * left using this method
     */
    readonly _: 'leaveChat',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type addChatMember = {
    /** Adds a new member to a chat. Members can't be added to private or secret chats */
    readonly _: 'addChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user */
    readonly user_id?: number,
    /**
     * The number of earlier messages from the chat to be forwarded to the new member;
     * up to 100. Ignored for supergroups and channels, or if the added user is a bot
     */
    readonly forward_limit?: number,
  }

  export type addChatMembers = {
    /**
     * Adds multiple new members to a chat. Currently, this method is only available
     * for supergroups and channels. This method can't be used to join a chat. Members
     * can't be added to a channel if it has more than 200 members
     */
    readonly _: 'addChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifiers of the users to be added to the chat. The maximum number of added
     * users is 20 for supergroups and 100 for channels
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type setChatMemberStatus = {
    /**
     * Changes the status of a chat member, needs appropriate privileges. This function
     * is currently not suitable for transferring chat ownership; use transferChatOwnership
     * instead. Use addChatMember or banChatMember if some additional parameters needs
     * to be passed
     */
    readonly _: 'setChatMemberStatus',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Member identifier. Chats can be only banned and unbanned in supergroups and
     * channels
     */
    readonly member_id?: MessageSender$Input,
    /** The new status of the member in the chat */
    readonly status?: ChatMemberStatus$Input,
  }

  export type banChatMember = {
    /**
     * Bans a member in a chat. Members can't be banned in private or secret chats.
     * In supergroups and channels, the user will not be able to return to the group
     * on their own using invite links, etc., unless unbanned first
     */
    readonly _: 'banChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
    /**
     * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If
     * the user is banned for more than 366 days or for less than 30 seconds from the
     * current time, the user is considered to be banned forever. Ignored in basic
     * groups and if a chat is banned
     */
    readonly banned_until_date?: number,
    /**
     * Pass true to delete all messages in the chat for the user that is being removed.
     * Always true for supergroups and channels
     */
    readonly revoke_messages?: boolean,
  }

  export type canTransferOwnership = {
    /**
     * Checks whether the current session can be used to transfer a chat ownership
     * to another user
     */
    readonly _: 'canTransferOwnership',
  }

  export type transferChatOwnership = {
    /**
     * Changes the owner of a chat. The current user must be a current owner of the
     * chat. Use the method canTransferOwnership to check whether the ownership can
     * be transferred from the current session. Available only for supergroups and
     * channel chats
     */
    readonly _: 'transferChatOwnership',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Identifier of the user to which transfer the ownership. The ownership can't
     * be transferred to a bot or to a deleted user
     */
    readonly user_id?: number,
    /** The password of the current user */
    readonly password?: string,
  }

  export type getChatMember = {
    /** Returns information about a single member of a chat */
    readonly _: 'getChatMember',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Member identifier */
    readonly member_id?: MessageSender$Input,
  }

  export type searchChatMembers = {
    /**
     * Searches for a specified query in the first name, last name and username of
     * the members of a specified chat. Requires administrator rights in channels
     */
    readonly _: 'searchChatMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of users to be returned; up to 200 */
    readonly limit?: number,
    /** The type of users to search for; pass null to search among all chat members */
    readonly filter?: ChatMembersFilter$Input,
  }

  export type getChatAdministrators = {
    /** Returns a list of administrators of the chat with their custom titles */
    readonly _: 'getChatAdministrators',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type clearAllDraftMessages = {
    /** Clears draft messages in all chats */
    readonly _: 'clearAllDraftMessages',
    /** If true, local draft messages in secret chats will not be cleared */
    readonly exclude_secret_chats?: boolean,
  }

  export type getChatNotificationSettingsExceptions = {
    /** Returns list of chats with non-default notification settings */
    readonly _: 'getChatNotificationSettingsExceptions',
    /**
     * If specified, only chats from the scope will be returned; pass null to return
     * chats from all scopes
     */
    readonly scope?: NotificationSettingsScope$Input,
    /** If true, also chats with non-default sound will be returned */
    readonly compare_sound?: boolean,
  }

  export type getScopeNotificationSettings = {
    /** Returns the notification settings for chats of a given type */
    readonly _: 'getScopeNotificationSettings',
    /** Types of chats for which to return the notification settings information */
    readonly scope?: NotificationSettingsScope$Input,
  }

  export type setScopeNotificationSettings = {
    /** Changes notification settings for chats of a given type */
    readonly _: 'setScopeNotificationSettings',
    /** Types of chats for which to change the notification settings */
    readonly scope?: NotificationSettingsScope$Input,
    /** The new notification settings for the given scope */
    readonly notification_settings?: scopeNotificationSettings$Input,
  }

  export type resetAllNotificationSettings = {
    /**
     * Resets all notification settings to their default values. By default, all chats
     * are unmuted, the sound is set to "default" and message previews are shown
     */
    readonly _: 'resetAllNotificationSettings',
  }

  export type toggleChatIsPinned = {
    /**
     * Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max")
     * pinned non-secret chats and the same number of secret chats in the main/arhive
     * chat list
     */
    readonly _: 'toggleChatIsPinned',
    /** Chat list in which to change the pinned state of the chat */
    readonly chat_list?: ChatList$Input,
    /** Chat identifier */
    readonly chat_id?: number,
    /** True, if the chat is pinned */
    readonly is_pinned?: boolean,
  }

  export type setPinnedChats = {
    /** Changes the order of pinned chats */
    readonly _: 'setPinnedChats',
    /** Chat list in which to change the order of pinned chats */
    readonly chat_list?: ChatList$Input,
    /** The new list of pinned chats */
    readonly chat_ids?: ReadonlyArray<number>,
  }

  export type downloadFile = {
    /**
     * Downloads a file from the cloud. Download progress and completion of the download
     * will be notified through updateFile updates
     */
    readonly _: 'downloadFile',
    /** Identifier of the file to download */
    readonly file_id?: number,
    /**
     * Priority of the download (1-32). The higher the priority, the earlier the file
     * will be downloaded. If the priorities of two files are equal, then the last
     * one for which downloadFile was called will be downloaded first
     */
    readonly priority?: number,
    /** The starting position from which the file needs to be downloaded */
    readonly offset?: number,
    /**
     * Number of bytes which need to be downloaded starting from the "offset" position
     * before the download will automatically be canceled; use 0 to download without
     * a limit
     */
    readonly limit?: number,
    /**
     * If false, this request returns file state just after the download has been started.
     * If true, this request returns file state only after the download has succeeded,
     * has failed, has been canceled or a new downloadFile request with different offset/limit
     * parameters was sent
     */
    readonly synchronous?: boolean,
  }

  export type getFileDownloadedPrefixSize = {
    /** Returns file downloaded prefix size from a given offset, in bytes */
    readonly _: 'getFileDownloadedPrefixSize',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Offset from which downloaded prefix size needs to be calculated */
    readonly offset?: number,
  }

  export type cancelDownloadFile = {
    /**
     * Stops the downloading of a file. If a file has already been downloaded, does
     * nothing
     */
    readonly _: 'cancelDownloadFile',
    /** Identifier of a file to stop downloading */
    readonly file_id?: number,
    /**
     * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't
     * been sent to server
     */
    readonly only_if_pending?: boolean,
  }

  export type getSuggestedFileName = {
    /** Returns suggested name for saving a file in a given directory */
    readonly _: 'getSuggestedFileName',
    /** Identifier of the file */
    readonly file_id?: number,
    /** Directory in which the file is supposed to be saved */
    readonly directory?: string,
  }

  export type uploadFile = {
    /**
     * Asynchronously uploads a file to the cloud without sending it in a message.
     * updateFile will be used to notify about upload progress and successful completion
     * of the upload. The file will not have a persistent remote identifier until it
     * will be sent in a message
     */
    readonly _: 'uploadFile',
    /** File to upload */
    readonly file?: InputFile$Input,
    /** File type; pass null if unknown */
    readonly file_type?: FileType$Input,
    /**
     * Priority of the upload (1-32). The higher the priority, the earlier the file
     * will be uploaded. If the priorities of two files are equal, then the first one
     * for which uploadFile was called will be uploaded first
     */
    readonly priority?: number,
  }

  export type cancelUploadFile = {
    /**
     * Stops the uploading of a file. Supported only for files uploaded by using uploadFile.
     * For other files the behavior is undefined
     */
    readonly _: 'cancelUploadFile',
    /** Identifier of the file to stop uploading */
    readonly file_id?: number,
  }

  export type writeGeneratedFilePart = {
    /**
     * Writes a part of a generated file. This method is intended to be used only if
     * the application has no direct access to TDLib's file system, because it is usually
     * slower than a direct write to the destination file
     */
    readonly _: 'writeGeneratedFilePart',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** The offset from which to write the data to the file */
    readonly offset?: number,
    /** The data to write */
    readonly data?: string,
  }

  export type setFileGenerationProgress = {
    /** Informs TDLib on a file generation progress */
    readonly _: 'setFileGenerationProgress',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /** Expected size of the generated file, in bytes; 0 if unknown */
    readonly expected_size?: number,
    /** The number of bytes already generated */
    readonly local_prefix_size?: number,
  }

  export type finishFileGeneration = {
    /** Finishes the file generation */
    readonly _: 'finishFileGeneration',
    /** The identifier of the generation process */
    readonly generation_id?: number | string,
    /**
     * If passed, the file generation has failed and must be terminated; pass null
     * if the file generation succeeded
     */
    readonly error?: error$Input,
  }

  export type readFilePart = {
    /**
     * Reads a part of a file from the TDLib file cache and returns read bytes. This
     * method is intended to be used only if the application has no direct access to
     * TDLib's file system, because it is usually slower than a direct read from the
     * file
     */
    readonly _: 'readFilePart',
    /** Identifier of the file. The file must be located in the TDLib file cache */
    readonly file_id?: number,
    /** The offset from which to read the file */
    readonly offset?: number,
    /**
     * Number of bytes to read. An error will be returned if there are not enough bytes
     * available in the file from the specified position. Pass 0 to read all available
     * data from the specified position
     */
    readonly count?: number,
  }

  export type deleteFile = {
    /** Deletes a file from the TDLib file cache */
    readonly _: 'deleteFile',
    /** Identifier of the file to delete */
    readonly file_id?: number,
  }

  export type getMessageFileType = {
    /** Returns information about a file with messages exported from another app */
    readonly _: 'getMessageFileType',
    /** Beginning of the message file; up to 100 first lines */
    readonly message_file_head?: string,
  }

  export type getMessageImportConfirmationText = {
    /**
     * Returns a confirmation text to be shown to the user before starting message
     * import
     */
    readonly _: 'getMessageImportConfirmationText',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info administrator right
     */
    readonly chat_id?: number,
  }

  export type importMessages = {
    /** Imports messages exported from another app */
    readonly _: 'importMessages',
    /**
     * Identifier of a chat to which the messages will be imported. It must be an identifier
     * of a private chat with a mutual contact or an identifier of a supergroup chat
     * with can_change_info administrator right
     */
    readonly chat_id?: number,
    /**
     * File with messages to import. Only inputFileLocal and inputFileGenerated are
     * supported. The file must not be previously uploaded
     */
    readonly message_file?: InputFile$Input,
    /**
     * Files used in the imported messages. Only inputFileLocal and inputFileGenerated
     * are supported. The files must not be previously uploaded
     */
    readonly attached_files?: ReadonlyArray<InputFile$Input>,
  }

  export type replacePrimaryChatInviteLink = {
    /**
     * Replaces current primary invite link for a chat with a new primary invite link.
     * Available for basic groups, supergroups, and channels. Requires administrator
     * privileges and can_invite_users right
     */
    readonly _: 'replacePrimaryChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type createChatInviteLink = {
    /**
     * Creates a new invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat
     */
    readonly _: 'createChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * True, if the link only creates join request. If true, member_limit must not
     * be specified
     */
    readonly creates_join_request?: boolean,
  }

  export type editChatInviteLink = {
    /**
     * Edits a non-primary invite link for a chat. Available for basic groups, supergroups,
     * and channels. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    readonly _: 'editChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be edited */
    readonly invite_link?: string,
    /** Invite link name; 0-32 characters */
    readonly name?: string,
    /** Point in time (Unix timestamp) when the link will expire; pass 0 if never */
    readonly expiration_date?: number,
    /**
     * The maximum number of chat members that can join the chat via the link simultaneously;
     * 0-99999; pass 0 if not limited
     */
    readonly member_limit?: number,
    /**
     * True, if the link only creates join request. If true, member_limit must not
     * be specified
     */
    readonly creates_join_request?: boolean,
  }

  export type getChatInviteLink = {
    /**
     * Returns information about an invite link. Requires administrator privileges
     * and can_invite_users right in the chat to get own links and owner privileges
     * to get other links
     */
    readonly _: 'getChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to get */
    readonly invite_link?: string,
  }

  export type getChatInviteLinkCounts = {
    /**
     * Returns list of chat administrators with number of their invite links. Requires
     * owner privileges in the chat
     */
    readonly _: 'getChatInviteLinkCounts',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type getChatInviteLinks = {
    /**
     * Returns invite links for a chat created by specified administrator. Requires
     * administrator privileges and can_invite_users right in the chat to get own links
     * and owner privileges to get other links
     */
    readonly _: 'getChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator. Must be an identifier of the current
     * user for non-owner
     */
    readonly creator_user_id?: number,
    /** Pass true if revoked links needs to be returned instead of active or expired */
    readonly is_revoked?: boolean,
    /**
     * Creation date of an invite link starting after which to return invite links;
     * use 0 to get results from the beginning
     */
    readonly offset_date?: number,
    /**
     * Invite link starting after which to return invite links; use empty string to
     * get results from the beginning
     */
    readonly offset_invite_link?: string,
    /** The maximum number of invite links to return; up to 100 */
    readonly limit?: number,
  }

  export type getChatInviteLinkMembers = {
    /**
     * Returns chat members joined a chat via an invite link. Requires administrator
     * privileges and can_invite_users right in the chat for own links and owner privileges
     * for other links
     */
    readonly _: 'getChatInviteLinkMembers',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link for which to return chat members */
    readonly invite_link?: string,
    /**
     * A chat member from which to return next chat members; pass null to get results
     * from the beginning
     */
    readonly offset_member?: chatInviteLinkMember$Input,
    /** The maximum number of chat members to return; up to 100 */
    readonly limit?: number,
  }

  export type revokeChatInviteLink = {
    /**
     * Revokes invite link for a chat. Available for basic groups, supergroups, and
     * channels. Requires administrator privileges and can_invite_users right in the
     * chat for own links and owner privileges for other links. If a primary link is
     * revoked, then additionally to the revoked link returns new primary link
     */
    readonly _: 'revokeChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to be revoked */
    readonly invite_link?: string,
  }

  export type deleteRevokedChatInviteLink = {
    /**
     * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users
     * right in the chat for own links and owner privileges for other links
     */
    readonly _: 'deleteRevokedChatInviteLink',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Invite link to revoke */
    readonly invite_link?: string,
  }

  export type deleteAllRevokedChatInviteLinks = {
    /**
     * Deletes all revoked chat invite links created by a given chat administrator.
     * Requires administrator privileges and can_invite_users right in the chat for
     * own links and owner privileges for other links
     */
    readonly _: 'deleteAllRevokedChatInviteLinks',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * User identifier of a chat administrator, which links will be deleted. Must be
     * an identifier of the current user for non-owner
     */
    readonly creator_user_id?: number,
  }

  export type checkChatInviteLink = {
    /**
     * Checks the validity of an invite link for a chat and returns information about
     * the corresponding chat
     */
    readonly _: 'checkChatInviteLink',
    /** Invite link to be checked */
    readonly invite_link?: string,
  }

  export type joinChatByInviteLink = {
    /** Uses an invite link to add the current user to the chat if possible */
    readonly _: 'joinChatByInviteLink',
    /** Invite link to use */
    readonly invite_link?: string,
  }

  export type getChatJoinRequests = {
    /** Returns pending join requests in a chat */
    readonly _: 'getChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to return join requests. If empty, all join requests will
     * be returned. Requires administrator privileges and can_invite_users right in
     * the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /**
     * A query to search for in the first names, last names and usernames of the users
     * to return
     */
    readonly query?: string,
    /**
     * A chat join request from which to return next requests; pass null to get results
     * from the beginning
     */
    readonly offset_request?: chatJoinRequest$Input,
    /** The maximum number of requests to join the chat to return */
    readonly limit?: number,
  }

  export type processChatJoinRequest = {
    /** Handles a pending join request in a chat */
    readonly _: 'processChatJoinRequest',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the user that sent the request */
    readonly user_id?: number,
    /** True, if the request is approved. Otherwise the request is declived */
    readonly approve?: boolean,
  }

  export type processChatJoinRequests = {
    /** Handles all pending join requests for a given link in a chat */
    readonly _: 'processChatJoinRequests',
    /** Chat identifier */
    readonly chat_id?: number,
    /**
     * Invite link for which to process join requests. If empty, all join requests
     * will be processed. Requires administrator privileges and can_invite_users right
     * in the chat for own links and owner privileges for other links
     */
    readonly invite_link?: string,
    /** True, if the requests are approved. Otherwise the requests are declived */
    readonly approve?: boolean,
  }

  export type createCall = {
    /** Creates a new call */
    readonly _: 'createCall',
    /** Identifier of the user to be called */
    readonly user_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
    /** True, if a video call needs to be created */
    readonly is_video?: boolean,
  }

  export type acceptCall = {
    /** Accepts an incoming call */
    readonly _: 'acceptCall',
    /** Call identifier */
    readonly call_id?: number,
    /** The call protocols supported by the application */
    readonly protocol?: callProtocol$Input,
  }

  export type sendCallSignalingData = {
    /** Sends call signaling data */
    readonly _: 'sendCallSignalingData',
    /** Call identifier */
    readonly call_id?: number,
    /** The data */
    readonly data?: string,
  }

  export type discardCall = {
    /** Discards a call */
    readonly _: 'discardCall',
    /** Call identifier */
    readonly call_id?: number,
    /** True, if the user was disconnected */
    readonly is_disconnected?: boolean,
    /** The call duration, in seconds */
    readonly duration?: number,
    /** True, if the call was a video call */
    readonly is_video?: boolean,
    /** Identifier of the connection used during the call */
    readonly connection_id?: number | string,
  }

  export type sendCallRating = {
    /** Sends a call rating */
    readonly _: 'sendCallRating',
    /** Call identifier */
    readonly call_id?: number,
    /** Call rating; 1-5 */
    readonly rating?: number,
    /** An optional user comment if the rating is less than 5 */
    readonly comment?: string,
    /** List of the exact types of problems with the call, specified by the user */
    readonly problems?: ReadonlyArray<CallProblem$Input>,
  }

  export type sendCallDebugInformation = {
    /** Sends debug information for a call */
    readonly _: 'sendCallDebugInformation',
    /** Call identifier */
    readonly call_id?: number,
    /** Debug information in application-specific format */
    readonly debug_information?: string,
  }

  export type getVideoChatAvailableParticipants = {
    /**
     * Returns list of participant identifiers, on whose behalf a video chat in the
     * chat can be joined
     */
    readonly _: 'getVideoChatAvailableParticipants',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type setVideoChatDefaultParticipant = {
    /**
     * Changes default participant identifier, on whose behalf a video chat in the
     * chat will be joined
     */
    readonly _: 'setVideoChatDefaultParticipant',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Default group call participant identifier to join the video chats */
    readonly default_participant_id?: MessageSender$Input,
  }

  export type createVideoChat = {
    /**
     * Creates a video chat (a group call bound to a chat). Available only for basic
     * groups, supergroups and channels; requires can_manage_video_chats rights
     */
    readonly _: 'createVideoChat',
    /** Chat identifier, in which the video chat will be created */
    readonly chat_id?: number,
    /** Group call title; if empty, chat title will be used */
    readonly title?: string,
    /**
     * Point in time (Unix timestamp) when the group call is supposed to be started
     * by an administrator; 0 to start the video chat immediately. The date must be
     * at least 10 seconds and at most 8 days in the future
     */
    readonly start_date?: number,
  }

  export type getGroupCall = {
    /** Returns information about a group call */
    readonly _: 'getGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startScheduledGroupCall = {
    /** Starts a scheduled group call */
    readonly _: 'startScheduledGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type toggleGroupCallEnabledStartNotification = {
    /**
     * Toggles whether the current user will receive a notification when the group
     * call will start; scheduled group calls only
     */
    readonly _: 'toggleGroupCallEnabledStartNotification',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the enabled_start_notification setting */
    readonly enabled_start_notification?: boolean,
  }

  export type joinGroupCall = {
    /** Joins an active group call. Returns join response payload for tgcalls */
    readonly _: 'joinGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Identifier of a group call participant, which will be used to join the call;
     * pass null to join as self; video chats only
     */
    readonly participant_id?: MessageSender$Input,
    /** Caller audio channel synchronization source identifier; received from tgcalls */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
    /** True, if the user's microphone is muted */
    readonly is_muted?: boolean,
    /** True, if the user's video is enabled */
    readonly is_my_video_enabled?: boolean,
    /**
     * If non-empty, invite hash to be used to join the group call without being muted
     * by administrators
     */
    readonly invite_hash?: string,
  }

  export type startGroupCallScreenSharing = {
    /**
     * Starts screen sharing in a joined group call. Returns join response payload
     * for tgcalls
     */
    readonly _: 'startGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Screen sharing audio channel synchronization source identifier; received from
     * tgcalls
     */
    readonly audio_source_id?: number,
    /** Group call join payload; received from tgcalls */
    readonly payload?: string,
  }

  export type toggleGroupCallScreenSharingIsPaused = {
    /** Pauses or unpauses screen sharing in a joined group call */
    readonly _: 'toggleGroupCallScreenSharingIsPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** True if screen sharing is paused */
    readonly is_paused?: boolean,
  }

  export type endGroupCallScreenSharing = {
    /** Ends screen sharing in a joined group call */
    readonly _: 'endGroupCallScreenSharing',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type setGroupCallTitle = {
    /** Sets group call title. Requires groupCall.can_be_managed group call flag */
    readonly _: 'setGroupCallTitle',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New group call title; 1-64 characters */
    readonly title?: string,
  }

  export type toggleGroupCallMuteNewParticipants = {
    /**
     * Toggles whether new participants of a group call can be unmuted only by administrators
     * of the group call. Requires groupCall.can_toggle_mute_new_participants group
     * call flag
     */
    readonly _: 'toggleGroupCallMuteNewParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** New value of the mute_new_participants setting */
    readonly mute_new_participants?: boolean,
  }

  export type inviteGroupCallParticipants = {
    /**
     * Invites users to an active group call. Sends a service message of type messageInviteToGroupCall
     * for video chats
     */
    readonly _: 'inviteGroupCallParticipants',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** User identifiers. At most 10 users can be invited simultaneously */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getGroupCallInviteLink = {
    /** Returns invite link to a video chat in a public chat */
    readonly _: 'getGroupCallInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Pass true if the invite link needs to contain an invite hash, passing which
     * to joinGroupCall would allow the invited user to unmute themselves. Requires
     * groupCall.can_be_managed group call flag
     */
    readonly can_self_unmute?: boolean,
  }

  export type revokeGroupCallInviteLink = {
    /**
     * Revokes invite link for a group call. Requires groupCall.can_be_managed group
     * call flag
     */
    readonly _: 'revokeGroupCallInviteLink',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type startGroupCallRecording = {
    /**
     * Starts recording of an active group call. Requires groupCall.can_be_managed
     * group call flag
     */
    readonly _: 'startGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Group call recording title; 0-64 characters */
    readonly title?: string,
    /** Pass true to record a video file instead of an audio file */
    readonly record_video?: boolean,
    /** Pass true to use portrait orientation for video instead of landscape one */
    readonly use_portrait_orientation?: boolean,
  }

  export type endGroupCallRecording = {
    /**
     * Ends recording of an active group call. Requires groupCall.can_be_managed group
     * call flag
     */
    readonly _: 'endGroupCallRecording',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type toggleGroupCallIsMyVideoPaused = {
    /** Toggles whether current user's video is paused */
    readonly _: 'toggleGroupCallIsMyVideoPaused',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is paused */
    readonly is_my_video_paused?: boolean,
  }

  export type toggleGroupCallIsMyVideoEnabled = {
    /** Toggles whether current user's video is enabled */
    readonly _: 'toggleGroupCallIsMyVideoEnabled',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Pass true if the current user's video is enabled */
    readonly is_my_video_enabled?: boolean,
  }

  export type setGroupCallParticipantIsSpeaking = {
    /** Informs TDLib that speaking state of a participant of an active group has changed */
    readonly _: 'setGroupCallParticipantIsSpeaking',
    /** Group call identifier */
    readonly group_call_id?: number,
    /**
     * Group call participant's synchronization audio source identifier, or 0 for the
     * current user
     */
    readonly audio_source?: number,
    /** True, if the user is speaking */
    readonly is_speaking?: boolean,
  }

  export type toggleGroupCallParticipantIsMuted = {
    /**
     * Toggles whether a participant of an active group call is muted, unmuted, or
     * allowed to unmute themselves
     */
    readonly _: 'toggleGroupCallParticipantIsMuted',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** Pass true if the user must be muted and false otherwise */
    readonly is_muted?: boolean,
  }

  export type setGroupCallParticipantVolumeLevel = {
    /**
     * Changes volume level of a participant of an active group call. If the current
     * user can manage the group call, then the participant's volume level will be
     * changed for all users with the default volume level
     */
    readonly _: 'setGroupCallParticipantVolumeLevel',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /** New participant's volume level; 1-20000 in hundreds of percents */
    readonly volume_level?: number,
  }

  export type toggleGroupCallParticipantIsHandRaised = {
    /** Toggles whether a group call participant hand is rased */
    readonly _: 'toggleGroupCallParticipantIsHandRaised',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Participant identifier */
    readonly participant_id?: MessageSender$Input,
    /**
     * Pass true if the user's hand needs to be raised. Only self hand can be raised.
     * Requires groupCall.can_be_managed group call flag to lower other's hand
     */
    readonly is_hand_raised?: boolean,
  }

  export type loadGroupCallParticipants = {
    /**
     * Loads more participants of a group call. The loaded participants will be received
     * through updates. Use the field groupCall.loaded_all_participants to check whether
     * all participants have already been loaded
     */
    readonly _: 'loadGroupCallParticipants',
    /**
     * Group call identifier. The group call must be previously received through getGroupCall
     * and must be joined or being joined
     */
    readonly group_call_id?: number,
    /** The maximum number of participants to load; up to 100 */
    readonly limit?: number,
  }

  export type leaveGroupCall = {
    /** Leaves a group call */
    readonly _: 'leaveGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type endGroupCall = {
    /** Ends a group call. Requires groupCall.can_be_managed */
    readonly _: 'endGroupCall',
    /** Group call identifier */
    readonly group_call_id?: number,
  }

  export type getGroupCallStreamSegment = {
    /**
     * Returns a file with a segment of a group call stream in a modified OGG format
     * for audio or MPEG-4 format for video
     */
    readonly _: 'getGroupCallStreamSegment',
    /** Group call identifier */
    readonly group_call_id?: number,
    /** Point in time when the stream segment begins; Unix timestamp in milliseconds */
    readonly time_offset?: number,
    /** Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds */
    readonly scale?: number,
    /** Identifier of an audio/video channel to get as received from tgcalls */
    readonly channel_id?: number,
    /**
     * Video quality as received from tgcalls; pass null to get the worst available
     * quality
     */
    readonly video_quality?: GroupCallVideoQuality$Input,
  }

  export type toggleMessageSenderIsBlocked = {
    /**
     * Changes the block state of a message sender. Currently, only users and supergroup
     * chats can be blocked
     */
    readonly _: 'toggleMessageSenderIsBlocked',
    /** Identifier of a message sender to block/unblock */
    readonly sender_id?: MessageSender$Input,
    /** New value of is_blocked */
    readonly is_blocked?: boolean,
  }

  export type blockMessageSenderFromReplies = {
    /** Blocks an original sender of a message in the Replies chat */
    readonly _: 'blockMessageSenderFromReplies',
    /** The identifier of an incoming message in the Replies chat */
    readonly message_id?: number,
    /** Pass true if the message must be deleted */
    readonly delete_message?: boolean,
    /** Pass true if all messages from the same sender must be deleted */
    readonly delete_all_messages?: boolean,
    /** Pass true if the sender must be reported to the Telegram moderators */
    readonly report_spam?: boolean,
  }

  export type getBlockedMessageSenders = {
    /** Returns users and chats that were blocked by the current user */
    readonly _: 'getBlockedMessageSenders',
    /** Number of users and chats to skip in the result; must be non-negative */
    readonly offset?: number,
    /** The maximum number of users and chats to return; up to 100 */
    readonly limit?: number,
  }

  export type addContact = {
    /** Adds a user to the contact list or edits an existing contact by their user identifier */
    readonly _: 'addContact',
    /**
     * The contact to add or edit; phone number can be empty and needs to be specified
     * only if known, vCard is ignored
     */
    readonly contact?: contact$Input,
    /**
     * True, if the new contact needs to be allowed to see current user's phone number.
     * A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed.
     * Use the field userFullInfo.need_phone_number_privacy_exception to check whether
     * the current user needs to be asked to share their phone number
     */
    readonly share_phone_number?: boolean,
  }

  export type importContacts = {
    /**
     * Adds new contacts or edits existing contacts by their phone numbers; contacts'
     * user identifiers are ignored
     */
    readonly _: 'importContacts',
    /**
     * The list of contacts to import or edit; contacts' vCard are ignored and are
     * not imported
     */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type getContacts = {
    /** Returns all user contacts */
    readonly _: 'getContacts',
  }

  export type searchContacts = {
    /**
     * Searches for the specified query in the first names, last names and usernames
     * of the known user contacts
     */
    readonly _: 'searchContacts',
    /** Query to search for; may be empty to return all contacts */
    readonly query?: string,
    /** The maximum number of users to be returned */
    readonly limit?: number,
  }

  export type removeContacts = {
    /** Removes users from the contact list */
    readonly _: 'removeContacts',
    /** Identifiers of users to be deleted */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getImportedContactCount = {
    /** Returns the total number of imported contacts */
    readonly _: 'getImportedContactCount',
  }

  export type changeImportedContacts = {
    /**
     * Changes imported contacts using the list of contacts saved on the device. Imports
     * newly added contacts and, if at least the file database is enabled, deletes
     * recently deleted contacts. Query result depends on the result of the previous
     * query, so only one query is possible at the same time
     */
    readonly _: 'changeImportedContacts',
    /** The new list of contacts, contact's vCard are ignored and are not imported */
    readonly contacts?: ReadonlyArray<contact$Input>,
  }

  export type clearImportedContacts = {
    /** Clears all imported contacts, contact list remains unchanged */
    readonly _: 'clearImportedContacts',
  }

  export type sharePhoneNumber = {
    /**
     * Shares the phone number of the current user with a mutual contact. Supposed
     * to be called when the user clicks on chatActionBarSharePhoneNumber
     */
    readonly _: 'sharePhoneNumber',
    /**
     * Identifier of the user with whom to share the phone number. The user must be
     * a mutual contact
     */
    readonly user_id?: number,
  }

  export type getUserProfilePhotos = {
    /**
     * Returns the profile photos of a user. The result of this query may be outdated:
     * some photos might have been deleted already
     */
    readonly _: 'getUserProfilePhotos',
    /** User identifier */
    readonly user_id?: number,
    /** The number of photos to skip; must be non-negative */
    readonly offset?: number,
    /** The maximum number of photos to be returned; up to 100 */
    readonly limit?: number,
  }

  export type getStickers = {
    /**
     * Returns stickers from the installed sticker sets that correspond to a given
     * emoji. If the emoji is non-empty, favorite and recently used stickers may also
     * be returned
     */
    readonly _: 'getStickers',
    /** String representation of emoji. If empty, returns all known installed stickers */
    readonly emoji?: string,
    /** The maximum number of stickers to be returned */
    readonly limit?: number,
  }

  export type searchStickers = {
    /** Searches for stickers from public sticker sets that correspond to a given emoji */
    readonly _: 'searchStickers',
    /** String representation of emoji; must be non-empty */
    readonly emoji?: string,
    /** The maximum number of stickers to be returned */
    readonly limit?: number,
  }

  export type getInstalledStickerSets = {
    /** Returns a list of installed sticker sets */
    readonly _: 'getInstalledStickerSets',
    /**
     * Pass true to return mask sticker sets; pass false to return ordinary sticker
     * sets
     */
    readonly is_masks?: boolean,
  }

  export type getArchivedStickerSets = {
    /** Returns a list of archived sticker sets */
    readonly _: 'getArchivedStickerSets',
    /**
     * Pass true to return mask stickers sets; pass false to return ordinary sticker
     * sets
     */
    readonly is_masks?: boolean,
    /** Identifier of the sticker set from which to return the result */
    readonly offset_sticker_set_id?: number | string,
    /** The maximum number of sticker sets to return; up to 100 */
    readonly limit?: number,
  }

  export type getTrendingStickerSets = {
    /**
     * Returns a list of trending sticker sets. For optimal performance, the number
     * of returned sticker sets is chosen by TDLib
     */
    readonly _: 'getTrendingStickerSets',
    /** The offset from which to return the sticker sets; must be non-negative */
    readonly offset?: number,
    /**
     * The maximum number of sticker sets to be returned; up to 100. For optimal performance,
     * the number of returned sticker sets is chosen by TDLib and can be smaller than
     * the specified limit, even if the end of the list has not been reached
     */
    readonly limit?: number,
  }

  export type getAttachedStickerSets = {
    /**
     * Returns a list of sticker sets attached to a file. Currently, only photos and
     * videos can have attached sticker sets
     */
    readonly _: 'getAttachedStickerSets',
    /** File identifier */
    readonly file_id?: number,
  }

  export type getStickerSet = {
    /** Returns information about a sticker set by its identifier */
    readonly _: 'getStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
  }

  export type searchStickerSet = {
    /** Searches for a sticker set by its name */
    readonly _: 'searchStickerSet',
    /** Name of the sticker set */
    readonly name?: string,
  }

  export type searchInstalledStickerSets = {
    /**
     * Searches for installed sticker sets by looking for specified query in their
     * title and name
     */
    readonly _: 'searchInstalledStickerSets',
    /**
     * Pass true to return mask sticker sets; pass false to return ordinary sticker
     * sets
     */
    readonly is_masks?: boolean,
    /** Query to search for */
    readonly query?: string,
    /** The maximum number of sticker sets to return */
    readonly limit?: number,
  }

  export type searchStickerSets = {
    /**
     * Searches for ordinary sticker sets by looking for specified query in their title
     * and name. Excludes installed sticker sets from the results
     */
    readonly _: 'searchStickerSets',
    /** Query to search for */
    readonly query?: string,
  }

  export type changeStickerSet = {
    /** Installs/uninstalls or activates/archives a sticker set */
    readonly _: 'changeStickerSet',
    /** Identifier of the sticker set */
    readonly set_id?: number | string,
    /** The new value of is_installed */
    readonly is_installed?: boolean,
    /**
     * The new value of is_archived. A sticker set can't be installed and archived
     * simultaneously
     */
    readonly is_archived?: boolean,
  }

  export type viewTrendingStickerSets = {
    /** Informs the server that some trending sticker sets have been viewed by the user */
    readonly _: 'viewTrendingStickerSets',
    /** Identifiers of viewed trending sticker sets */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type reorderInstalledStickerSets = {
    /** Changes the order of installed sticker sets */
    readonly _: 'reorderInstalledStickerSets',
    /**
     * Pass true to change the order of mask sticker sets; pass false to change the
     * order of ordinary sticker sets
     */
    readonly is_masks?: boolean,
    /** Identifiers of installed sticker sets in the new correct order */
    readonly sticker_set_ids?: ReadonlyArray<number | string>,
  }

  export type getRecentStickers = {
    /** Returns a list of recently used stickers */
    readonly _: 'getRecentStickers',
    /**
     * Pass true to return stickers and masks that were recently attached to photos
     * or video files; pass false to return recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type addRecentSticker = {
    /**
     * Manually adds a new sticker to the list of recently used stickers. The new sticker
     * is added to the top of the list. If the sticker was already in the list, it
     * is removed from the list first. Only stickers belonging to a sticker set can
     * be added to this list
     */
    readonly _: 'addRecentSticker',
    /**
     * Pass true to add the sticker to the list of stickers recently attached to photo
     * or video files; pass false to add the sticker to the list of recently sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeRecentSticker = {
    /** Removes a sticker from the list of recently used stickers */
    readonly _: 'removeRecentSticker',
    /**
     * Pass true to remove the sticker from the list of stickers recently attached
     * to photo or video files; pass false to remove the sticker from the list of recently
     * sent stickers
     */
    readonly is_attached?: boolean,
    /** Sticker file to delete */
    readonly sticker?: InputFile$Input,
  }

  export type clearRecentStickers = {
    /** Clears the list of recently used stickers */
    readonly _: 'clearRecentStickers',
    /**
     * Pass true to clear the list of stickers recently attached to photo or video
     * files; pass false to clear the list of recently sent stickers
     */
    readonly is_attached?: boolean,
  }

  export type getFavoriteStickers = {
    /** Returns favorite stickers */
    readonly _: 'getFavoriteStickers',
  }

  export type addFavoriteSticker = {
    /**
     * Adds a new sticker to the list of favorite stickers. The new sticker is added
     * to the top of the list. If the sticker was already in the list, it is removed
     * from the list first. Only stickers belonging to a sticker set can be added to
     * this list
     */
    readonly _: 'addFavoriteSticker',
    /** Sticker file to add */
    readonly sticker?: InputFile$Input,
  }

  export type removeFavoriteSticker = {
    /** Removes a sticker from the list of favorite stickers */
    readonly _: 'removeFavoriteSticker',
    /** Sticker file to delete from the list */
    readonly sticker?: InputFile$Input,
  }

  export type getStickerEmojis = {
    /**
     * Returns emoji corresponding to a sticker. The list is only for informational
     * purposes, because a sticker is always sent with a fixed emoji from the corresponding
     * Sticker object
     */
    readonly _: 'getStickerEmojis',
    /** Sticker file identifier */
    readonly sticker?: InputFile$Input,
  }

  export type searchEmojis = {
    /** Searches for emojis by keywords. Supported only if the file database is enabled */
    readonly _: 'searchEmojis',
    /** Text to search for */
    readonly text?: string,
    /** True, if only emojis, which exactly match text needs to be returned */
    readonly exact_match?: boolean,
    /**
     * List of possible IETF language tags of the user's input language; may be empty
     * if unknown
     */
    readonly input_language_codes?: ReadonlyArray<string>,
  }

  export type getAnimatedEmoji = {
    /**
     * Returns an animated emoji corresponding to a given emoji. Returns a 404 error
     * if the emoji has no animated emoji
     */
    readonly _: 'getAnimatedEmoji',
    /** The emoji */
    readonly emoji?: string,
  }

  export type getEmojiSuggestionsUrl = {
    /**
     * Returns an HTTP URL which can be used to automatically log in to the translation
     * platform and suggest new emoji replacements. The URL will be valid for 30 seconds
     * after generation
     */
    readonly _: 'getEmojiSuggestionsUrl',
    /** Language code for which the emoji replacements will be suggested */
    readonly language_code?: string,
  }

  export type getSavedAnimations = {
    /** Returns saved animations */
    readonly _: 'getSavedAnimations',
  }

  export type addSavedAnimation = {
    /**
     * Manually adds a new animation to the list of saved animations. The new animation
     * is added to the beginning of the list. If the animation was already in the list,
     * it is removed first. Only non-secret video animations with MIME type "video/mp4"
     * can be added to the list
     */
    readonly _: 'addSavedAnimation',
    /**
     * The animation file to be added. Only animations known to the server (i.e., successfully
     * sent via a message) can be added to the list
     */
    readonly animation?: InputFile$Input,
  }

  export type removeSavedAnimation = {
    /** Removes an animation from the list of saved animations */
    readonly _: 'removeSavedAnimation',
    /** Animation file to be removed */
    readonly animation?: InputFile$Input,
  }

  export type getRecentInlineBots = {
    /** Returns up to 20 recently used inline bots in the order of their last usage */
    readonly _: 'getRecentInlineBots',
  }

  export type searchHashtags = {
    /** Searches for recently used hashtags by their prefix */
    readonly _: 'searchHashtags',
    /** Hashtag prefix to search for */
    readonly prefix?: string,
    /** The maximum number of hashtags to be returned */
    readonly limit?: number,
  }

  export type removeRecentHashtag = {
    /** Removes a hashtag from the list of recently used hashtags */
    readonly _: 'removeRecentHashtag',
    /** Hashtag to delete */
    readonly hashtag?: string,
  }

  export type getWebPagePreview = {
    /**
     * Returns a web page preview by the text of the message. Do not call this function
     * too often. Returns a 404 error if the web page has no preview
     */
    readonly _: 'getWebPagePreview',
    /** Message text with formatting */
    readonly text?: formattedText$Input,
  }

  export type getWebPageInstantView = {
    /**
     * Returns an instant view version of a web page if available. Returns a 404 error
     * if the web page has no instant view page
     */
    readonly _: 'getWebPageInstantView',
    /** The web page URL */
    readonly url?: string,
    /** If true, the full instant view for the web page will be returned */
    readonly force_full?: boolean,
  }

  export type setProfilePhoto = {
    /** Changes a profile photo for the current user */
    readonly _: 'setProfilePhoto',
    /** Profile photo to set */
    readonly photo?: InputChatPhoto$Input,
  }

  export type deleteProfilePhoto = {
    /** Deletes a profile photo */
    readonly _: 'deleteProfilePhoto',
    /** Identifier of the profile photo to delete */
    readonly profile_photo_id?: number | string,
  }

  export type setName = {
    /** Changes the first and last name of the current user */
    readonly _: 'setName',
    /** The new value of the first name for the current user; 1-64 characters */
    readonly first_name?: string,
    /** The new value of the optional last name for the current user; 0-64 characters */
    readonly last_name?: string,
  }

  export type setBio = {
    /** Changes the bio of the current user */
    readonly _: 'setBio',
    /** The new value of the user bio; 0-70 characters without line feeds */
    readonly bio?: string,
  }

  export type setUsername = {
    /** Changes the username of the current user */
    readonly _: 'setUsername',
    /** The new value of the username. Use an empty string to remove the username */
    readonly username?: string,
  }

  export type setLocation = {
    /**
     * Changes the location of the current user. Needs to be called if GetOption("is_location_visible")
     * is true and location changes for more than 1 kilometer
     */
    readonly _: 'setLocation',
    /** The new location of the user */
    readonly location?: location$Input,
  }

  export type changePhoneNumber = {
    /**
     * Changes the phone number of the user and sends an authentication code to the
     * user's new phone number. On success, returns information about the sent code
     */
    readonly _: 'changePhoneNumber',
    /** The new phone number of the user in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendChangePhoneNumberCode = {
    /**
     * Re-sends the authentication code sent to confirm a new phone number for the
     * current user. Works only if the previously received authenticationCodeInfo next_code_type
     * was not null and the server-specified timeout has passed
     */
    readonly _: 'resendChangePhoneNumberCode',
  }

  export type checkChangePhoneNumberCode = {
    /** Checks the authentication code sent to confirm a new phone number of the user */
    readonly _: 'checkChangePhoneNumberCode',
    /** Authentication code to check */
    readonly code?: string,
  }

  export type setCommands = {
    /**
     * Sets the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    readonly _: 'setCommands',
    /**
     * The scope to which the commands are relevant; pass null to change commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /**
     * A two-letter ISO 639-1 country code. If empty, the commands will be applied
     * to all users from the given scope, for which language there are no dedicated
     * commands
     */
    readonly language_code?: string,
    /** List of the bot's commands */
    readonly commands?: ReadonlyArray<botCommand$Input>,
  }

  export type deleteCommands = {
    /**
     * Deletes commands supported by the bot for the given user scope and language;
     * for bots only
     */
    readonly _: 'deleteCommands',
    /**
     * The scope to which the commands are relevant; pass null to delete commands in
     * the default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 country code or an empty string */
    readonly language_code?: string,
  }

  export type getCommands = {
    /**
     * Returns the list of commands supported by the bot for the given user scope and
     * language; for bots only
     */
    readonly _: 'getCommands',
    /**
     * The scope to which the commands are relevant; pass null to get commands in the
     * default bot command scope
     */
    readonly scope?: BotCommandScope$Input,
    /** A two-letter ISO 639-1 country code or an empty string */
    readonly language_code?: string,
  }

  export type getActiveSessions = {
    /** Returns all active sessions of the current user */
    readonly _: 'getActiveSessions',
  }

  export type terminateSession = {
    /** Terminates a session of the current user */
    readonly _: 'terminateSession',
    /** Session identifier */
    readonly session_id?: number | string,
  }

  export type terminateAllOtherSessions = {
    /** Terminates all other sessions of the current user */
    readonly _: 'terminateAllOtherSessions',
  }

  export type toggleSessionCanAcceptCalls = {
    /** Toggles whether a session can accept incoming calls */
    readonly _: 'toggleSessionCanAcceptCalls',
    /** Session identifier */
    readonly session_id?: number | string,
    /** True, if incoming calls can be accepted by the session */
    readonly can_accept_calls?: boolean,
  }

  export type toggleSessionCanAcceptSecretChats = {
    /** Toggles whether a session can accept incoming secret chats */
    readonly _: 'toggleSessionCanAcceptSecretChats',
    /** Session identifier */
    readonly session_id?: number | string,
    /** True, if incoming secret chats can be accepted by the session */
    readonly can_accept_secret_chats?: boolean,
  }

  export type setInactiveSessionTtl = {
    /**
     * Changes the period of inactivity after which sessions will automatically be
     * terminated
     */
    readonly _: 'setInactiveSessionTtl',
    /**
     * New number of days of inactivity before sessions will be automatically terminated;
     * 1-366 days
     */
    readonly inactive_session_ttl_days?: number,
  }

  export type getConnectedWebsites = {
    /** Returns all website where the current user used Telegram to log in */
    readonly _: 'getConnectedWebsites',
  }

  export type disconnectWebsite = {
    /** Disconnects website from the current user's Telegram account */
    readonly _: 'disconnectWebsite',
    /** Website identifier */
    readonly website_id?: number | string,
  }

  export type disconnectAllWebsites = {
    /** Disconnects all websites from the current user's Telegram account */
    readonly _: 'disconnectAllWebsites',
  }

  export type setSupergroupUsername = {
    /**
     * Changes the username of a supergroup or channel, requires owner privileges in
     * the supergroup or channel
     */
    readonly _: 'setSupergroupUsername',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** New value of the username. Use an empty string to remove the username */
    readonly username?: string,
  }

  export type setSupergroupStickerSet = {
    /**
     * Changes the sticker set of a supergroup; requires can_change_info administrator
     * right
     */
    readonly _: 'setSupergroupStickerSet',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
    /**
     * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup
     * sticker set
     */
    readonly sticker_set_id?: number | string,
  }

  export type toggleSupergroupSignMessages = {
    /**
     * Toggles whether sender signature is added to sent messages in a channel; requires
     * can_change_info administrator right
     */
    readonly _: 'toggleSupergroupSignMessages',
    /** Identifier of the channel */
    readonly supergroup_id?: number,
    /** New value of sign_messages */
    readonly sign_messages?: boolean,
  }

  export type toggleSupergroupIsAllHistoryAvailable = {
    /**
     * Toggles whether the message history of a supergroup is available to new members;
     * requires can_change_info administrator right
     */
    readonly _: 'toggleSupergroupIsAllHistoryAvailable',
    /** The identifier of the supergroup */
    readonly supergroup_id?: number,
    /** The new value of is_all_history_available */
    readonly is_all_history_available?: boolean,
  }

  export type toggleSupergroupIsBroadcastGroup = {
    /** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
    readonly _: 'toggleSupergroupIsBroadcastGroup',
    /** Identifier of the supergroup */
    readonly supergroup_id?: number,
  }

  export type reportSupergroupSpam = {
    /**
     * Reports messages in a supergroup as spam; requires administrator rights in the
     * supergroup
     */
    readonly _: 'reportSupergroupSpam',
    /** Supergroup identifier */
    readonly supergroup_id?: number,
    /** Identifiers of messages to report */
    readonly message_ids?: ReadonlyArray<number>,
  }

  export type getSupergroupMembers = {
    /**
     * Returns information about members or banned users in a supergroup or channel.
     * Can be used only if supergroupFullInfo.can_get_members == true; additionally,
     * administrator privileges may be required for some filters
     */
    readonly _: 'getSupergroupMembers',
    /** Identifier of the supergroup or channel */
    readonly supergroup_id?: number,
    /** The type of users to return; pass null to use supergroupMembersFilterRecent */
    readonly filter?: SupergroupMembersFilter$Input,
    /** Number of users to skip */
    readonly offset?: number,
    /** The maximum number of users be returned; up to 200 */
    readonly limit?: number,
  }

  export type closeSecretChat = {
    /** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
    readonly _: 'closeSecretChat',
    /** Secret chat identifier */
    readonly secret_chat_id?: number,
  }

  export type getChatEventLog = {
    /**
     * Returns a list of service actions taken by chat members and administrators in
     * the last 48 hours. Available only for supergroups and channels. Requires administrator
     * rights. Returns results in reverse chronological order (i. e., in order of decreasing
     * event_id)
     */
    readonly _: 'getChatEventLog',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Search query by which to filter events */
    readonly query?: string,
    /**
     * Identifier of an event from which to return results. Use 0 to get results from
     * the latest events
     */
    readonly from_event_id?: number | string,
    /** The maximum number of events to return; up to 100 */
    readonly limit?: number,
    /** The types of events to return; pass null to get chat events of all types */
    readonly filters?: chatEventLogFilters$Input,
    /**
     * User identifiers by which to filter events. By default, events relating to all
     * users will be returned
     */
    readonly user_ids?: ReadonlyArray<number>,
  }

  export type getPaymentForm = {
    /**
     * Returns an invoice payment form. This method must be called when the user presses
     * inlineKeyboardButtonBuy
     */
    readonly _: 'getPaymentForm',
    /** Chat identifier of the Invoice message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Preferred payment form theme; pass null to use the default theme */
    readonly theme?: paymentFormTheme$Input,
  }

  export type validateOrderInfo = {
    /**
     * Validates the order information provided by a user and returns the available
     * shipping options for a flexible invoice
     */
    readonly _: 'validateOrderInfo',
    /** Chat identifier of the Invoice message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** The order information, provided by the user; pass null if empty */
    readonly order_info?: orderInfo$Input,
    /** True, if the order information can be saved */
    readonly allow_save?: boolean,
  }

  export type sendPaymentForm = {
    /** Sends a filled-out payment form to the bot for final verification */
    readonly _: 'sendPaymentForm',
    /** Chat identifier of the Invoice message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Payment form identifier returned by getPaymentForm */
    readonly payment_form_id?: number | string,
    /** Identifier returned by validateOrderInfo, or an empty string */
    readonly order_info_id?: string,
    /** Identifier of a chosen shipping option, if applicable */
    readonly shipping_option_id?: string,
    /** The credentials chosen by user for payment */
    readonly credentials?: InputCredentials$Input,
    /** Chosen by the user amount of tip in the smallest units of the currency */
    readonly tip_amount?: number,
  }

  export type getPaymentReceipt = {
    /** Returns information about a successful payment */
    readonly _: 'getPaymentReceipt',
    /** Chat identifier of the PaymentSuccessful message */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
  }

  export type getSavedOrderInfo = {
    /** Returns saved order info, if any */
    readonly _: 'getSavedOrderInfo',
  }

  export type deleteSavedOrderInfo = {
    /** Deletes saved order info */
    readonly _: 'deleteSavedOrderInfo',
  }

  export type deleteSavedCredentials = {
    /** Deletes saved credentials for all payment provider bots */
    readonly _: 'deleteSavedCredentials',
  }

  export type getSupportUser = {
    /** Returns a user that can be contacted to get support */
    readonly _: 'getSupportUser',
  }

  export type getBackgrounds = {
    /** Returns backgrounds installed by the user */
    readonly _: 'getBackgrounds',
    /** True, if the backgrounds must be ordered for dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type getBackgroundUrl = {
    /** Constructs a persistent HTTP URL for a background */
    readonly _: 'getBackgroundUrl',
    /** Background name */
    readonly name?: string,
    /** Background type */
    readonly type?: BackgroundType$Input,
  }

  export type searchBackground = {
    /** Searches for a background by its name */
    readonly _: 'searchBackground',
    /** The name of the background */
    readonly name?: string,
  }

  export type setBackground = {
    /**
     * Changes the background selected by the user; adds background to the list of
     * installed backgrounds
     */
    readonly _: 'setBackground',
    /**
     * The input background to use; pass null to create a new filled backgrounds or
     * to remove the current background
     */
    readonly background?: InputBackground$Input,
    /**
     * Background type; pass null to use the default type of the remote background
     * or to remove the current background
     */
    readonly type?: BackgroundType$Input,
    /** True, if the background is chosen for dark theme */
    readonly for_dark_theme?: boolean,
  }

  export type removeBackground = {
    /** Removes background from the list of installed backgrounds */
    readonly _: 'removeBackground',
    /** The background identifier */
    readonly background_id?: number | string,
  }

  export type resetBackgrounds = {
    /** Resets list of installed backgrounds to its default value */
    readonly _: 'resetBackgrounds',
  }

  export type getLocalizationTargetInfo = {
    /**
     * Returns information about the current localization target. This is an offline
     * request if only_local is true. Can be called before authorization
     */
    readonly _: 'getLocalizationTargetInfo',
    /**
     * If true, returns only locally available information without sending network
     * requests
     */
    readonly only_local?: boolean,
  }

  export type getLanguagePackInfo = {
    /**
     * Returns information about a language pack. Returned language pack identifier
     * may be different from a provided one. Can be called before authorization
     */
    readonly _: 'getLanguagePackInfo',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type getLanguagePackStrings = {
    /**
     * Returns strings from a language pack in the current localization target by their
     * keys. Can be called before authorization
     */
    readonly _: 'getLanguagePackStrings',
    /** Language pack identifier of the strings to be returned */
    readonly language_pack_id?: string,
    /**
     * Language pack keys of the strings to be returned; leave empty to request all
     * available strings
     */
    readonly keys?: ReadonlyArray<string>,
  }

  export type synchronizeLanguagePack = {
    /**
     * Fetches the latest versions of all strings from a language pack in the current
     * localization target from the server. This method doesn't need to be called explicitly
     * for the current used/base language packs. Can be called before authorization
     */
    readonly _: 'synchronizeLanguagePack',
    /** Language pack identifier */
    readonly language_pack_id?: string,
  }

  export type addCustomServerLanguagePack = {
    /**
     * Adds a custom server language pack to the list of installed language packs in
     * current localization target. Can be called before authorization
     */
    readonly _: 'addCustomServerLanguagePack',
    /**
     * Identifier of a language pack to be added; may be different from a name that
     * is used in an "https://t.me/setlanguage/" link
     */
    readonly language_pack_id?: string,
  }

  export type setCustomLanguagePack = {
    /** Adds or changes a custom local language pack to the current localization target */
    readonly _: 'setCustomLanguagePack',
    /**
     * Information about the language pack. Language pack ID must start with 'X', consist
     * only of English letters, digits and hyphens, and must not exceed 64 characters.
     * Can be called before authorization
     */
    readonly info?: languagePackInfo$Input,
    /** Strings of the new language pack */
    readonly strings?: ReadonlyArray<languagePackString$Input>,
  }

  export type editCustomLanguagePackInfo = {
    /**
     * Edits information about a custom local language pack in the current localization
     * target. Can be called before authorization
     */
    readonly _: 'editCustomLanguagePackInfo',
    /** New information about the custom local language pack */
    readonly info?: languagePackInfo$Input,
  }

  export type setCustomLanguagePackString = {
    /**
     * Adds, edits or deletes a string in a custom local language pack. Can be called
     * before authorization
     */
    readonly _: 'setCustomLanguagePackString',
    /**
     * Identifier of a previously added custom local language pack in the current localization
     * target
     */
    readonly language_pack_id?: string,
    /** New language pack string */
    readonly new_string?: languagePackString$Input,
  }

  export type deleteLanguagePack = {
    /**
     * Deletes all information about a language pack in the current localization target.
     * The language pack which is currently in use (including base language pack) or
     * is being synchronized can't be deleted. Can be called before authorization
     */
    readonly _: 'deleteLanguagePack',
    /** Identifier of the language pack to delete */
    readonly language_pack_id?: string,
  }

  export type registerDevice = {
    /**
     * Registers the currently used device for receiving push notifications. Returns
     * a globally unique identifier of the push notification subscription
     */
    readonly _: 'registerDevice',
    /** Device token */
    readonly device_token?: DeviceToken$Input,
    /** List of user identifiers of other users currently using the application */
    readonly other_user_ids?: ReadonlyArray<number>,
  }

  export type processPushNotification = {
    /**
     * Handles a push notification. Returns error with code 406 if the push notification
     * is not supported and connection to the server is required to fetch new data.
     * Can be called before authorization
     */
    readonly _: 'processPushNotification',
    /**
     * JSON-encoded push notification payload with all fields sent by the server, and
     * "google.sent_time" and "google.notification.sound" fields added
     */
    readonly payload?: string,
  }

  export type getPushReceiverId = {
    /**
     * Returns a globally unique push notification subscription identifier for identification
     * of an account, which has received a push notification. Can be called synchronously
     */
    readonly _: 'getPushReceiverId',
    /** JSON-encoded push notification payload */
    readonly payload?: string,
  }

  export type getRecentlyVisitedTMeUrls = {
    /** Returns t.me URLs recently visited by a newly registered user */
    readonly _: 'getRecentlyVisitedTMeUrls',
    /** Google Play referrer to identify the user */
    readonly referrer?: string,
  }

  export type setUserPrivacySettingRules = {
    /** Changes user privacy settings */
    readonly _: 'setUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
    /** The new privacy rules */
    readonly rules?: userPrivacySettingRules$Input,
  }

  export type getUserPrivacySettingRules = {
    /** Returns the current privacy settings */
    readonly _: 'getUserPrivacySettingRules',
    /** The privacy setting */
    readonly setting?: UserPrivacySetting$Input,
  }

  export type getOption = {
    /**
     * Returns the value of an option by its name. (Check the list of available options
     * on https://core.telegram.org/tdlib/options.) Can be called before authorization
     */
    readonly _: 'getOption',
    /** The name of the option */
    readonly name?: string,
  }

  export type setOption = {
    /**
     * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.)
     * Only writable options can be set. Can be called before authorization
     */
    readonly _: 'setOption',
    /** The name of the option */
    readonly name?: string,
    /** The new value of the option; pass null to reset option value to a default value */
    readonly value?: OptionValue$Input,
  }

  export type setAccountTtl = {
    /**
     * Changes the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'setAccountTtl',
    /** New account TTL */
    readonly ttl?: accountTtl$Input,
  }

  export type getAccountTtl = {
    /**
     * Returns the period of inactivity after which the account of the current user
     * will automatically be deleted
     */
    readonly _: 'getAccountTtl',
  }

  export type deleteAccount = {
    /**
     * Deletes the account of the current user, deleting all information associated
     * with the user from the server. The phone number of the account can be used to
     * create a new account. Can be called before authorization when the current authorization
     * state is authorizationStateWaitPassword
     */
    readonly _: 'deleteAccount',
    /** The reason why the account was deleted; optional */
    readonly reason?: string,
  }

  export type removeChatActionBar = {
    /** Removes a chat action bar without any other action */
    readonly _: 'removeChatActionBar',
    /** Chat identifier */
    readonly chat_id?: number,
  }

  export type reportChat = {
    /**
     * Reports a chat to the Telegram moderators. A chat can be reported only from
     * the chat action bar, or if chat.can_be_reported
     */
    readonly _: 'reportChat',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifiers of reported messages, if any */
    readonly message_ids?: ReadonlyArray<number>,
    /** The reason for reporting the chat */
    readonly reason?: ChatReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type reportChatPhoto = {
    /**
     * Reports a chat photo to the Telegram moderators. A chat photo can be reported
     * only if chat.can_be_reported
     */
    readonly _: 'reportChatPhoto',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Identifier of the photo to report. Only full photos from chatPhoto can be reported */
    readonly file_id?: number,
    /** The reason for reporting the chat photo */
    readonly reason?: ChatReportReason$Input,
    /** Additional report details; 0-1024 characters */
    readonly text?: string,
  }

  export type getChatStatistics = {
    /**
     * Returns detailed statistics about a chat. Currently, this method can be used
     * only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics
     * == true
     */
    readonly _: 'getChatStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getMessageStatistics = {
    /**
     * Returns detailed statistics about a message. Can be used only if message.can_get_statistics
     * == true
     */
    readonly _: 'getMessageStatistics',
    /** Chat identifier */
    readonly chat_id?: number,
    /** Message identifier */
    readonly message_id?: number,
    /** Pass true if a dark theme is used by the application */
    readonly is_dark?: boolean,
  }

  export type getStatisticalGraph = {
    /** Loads an asynchronous or a zoomed in statistical graph */
    readonly _: 'getStatisticalGraph',
    /** Chat identifier */
    readonly chat_id?: number,
    /** The token for graph loading */
    readonly token?: string,
    /** X-value for zoomed in graph or 0 otherwise */
    readonly x?: number,
  }

  export type getStorageStatistics = {
    /** Returns storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatistics',
    /**
     * The maximum number of chats with the largest storage usage for which separate
     * statistics need to be returned. All other chats will be grouped in entries with
     * chat_id == 0. If the chat info database is not used, the chat_limit is ignored
     * and is always set to 0
     */
    readonly chat_limit?: number,
  }

  export type getStorageStatisticsFast = {
    /** Quickly returns approximate storage usage statistics. Can be called before authorization */
    readonly _: 'getStorageStatisticsFast',
  }

  export type getDatabaseStatistics = {
    /** Returns database statistics */
    readonly _: 'getDatabaseStatistics',
  }

  export type optimizeStorage = {
    /**
     * Optimizes storage usage, i.e. deletes some files and returns new storage usage
     * statistics. Secret thumbnails can't be deleted
     */
    readonly _: 'optimizeStorage',
    /**
     * Limit on the total size of files after deletion, in bytes. Pass -1 to use the
     * default limit
     */
    readonly size?: number,
    /**
     * Limit on the time that has passed since the last time a file was accessed (or
     * creation time for some filesystems). Pass -1 to use the default limit
     */
    readonly ttl?: number,
    /**
     * Limit on the total count of files after deletion. Pass -1 to use the default
     * limit
     */
    readonly count?: number,
    /**
     * The amount of time after the creation of a file during which it can't be deleted,
     * in seconds. Pass -1 to use the default value
     */
    readonly immunity_delay?: number,
    /**
     * If non-empty, only files with the given types are considered. By default, all
     * types except thumbnails, profile photos, stickers and wallpapers are deleted
     */
    readonly file_types?: ReadonlyArray<FileType$Input>,
    /**
     * If non-empty, only files from the given chats are considered. Use 0 as chat
     * identifier to delete files not belonging to any chat (e.g., profile photos)
     */
    readonly chat_ids?: ReadonlyArray<number>,
    /**
     * If non-empty, files from the given chats are excluded. Use 0 as chat identifier
     * to exclude all files not belonging to any chat (e.g., profile photos)
     */
    readonly exclude_chat_ids?: ReadonlyArray<number>,
    /**
     * Pass true if statistics about the files that were deleted must be returned instead
     * of the whole storage usage statistics. Affects only returned statistics
     */
    readonly return_deleted_file_statistics?: boolean,
    /** Same as in getStorageStatistics. Affects only returned statistics */
    readonly chat_limit?: number,
  }

  export type setNetworkType = {
    /**
     * Sets the current network type. Can be called before authorization. Calling this
     * method forces all network connections to reopen, mitigating the delay in switching
     * between different networks, so it must be called whenever the network is changed,
     * even if the network type remains the same. Network type is used to check whether
     * the library can use the network at all and also for collecting detailed network
     * data usage statistics
     */
    readonly _: 'setNetworkType',
    /** The new network type; pass null to set network type to networkTypeOther */
    readonly type?: NetworkType$Input,
  }

  export type getNetworkStatistics = {
    /** Returns network data usage statistics. Can be called before authorization */
    readonly _: 'getNetworkStatistics',
    /** If true, returns only data for the current library launch */
    readonly only_current?: boolean,
  }

  export type addNetworkStatistics = {
    /** Adds the specified data to data usage statistics. Can be called before authorization */
    readonly _: 'addNetworkStatistics',
    /** The network statistics entry with the data to be added to statistics */
    readonly entry?: NetworkStatisticsEntry$Input,
  }

  export type resetNetworkStatistics = {
    /** Resets all network data usage statistics to zero. Can be called before authorization */
    readonly _: 'resetNetworkStatistics',
  }

  export type getAutoDownloadSettingsPresets = {
    /** Returns auto-download settings presets for the current user */
    readonly _: 'getAutoDownloadSettingsPresets',
  }

  export type setAutoDownloadSettings = {
    /** Sets auto-download settings */
    readonly _: 'setAutoDownloadSettings',
    /** New user auto-download settings */
    readonly settings?: autoDownloadSettings$Input,
    /** Type of the network for which the new settings are relevant */
    readonly type?: NetworkType$Input,
  }

  export type getBankCardInfo = {
    /** Returns information about a bank card */
    readonly _: 'getBankCardInfo',
    /** The bank card number */
    readonly bank_card_number?: string,
  }

  export type getPassportElement = {
    /** Returns one of the available Telegram Passport elements */
    readonly _: 'getPassportElement',
    /** Telegram Passport element type */
    readonly type?: PassportElementType$Input,
    /** Password of the current user */
    readonly password?: string,
  }

  export type getAllPassportElements = {
    /** Returns all available Telegram Passport elements */
    readonly _: 'getAllPassportElements',
    /** Password of the current user */
    readonly password?: string,
  }

  export type setPassportElement = {
    /**
     * Adds an element to the user's Telegram Passport. May return an error with a
     * message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen
     * phone number or the chosen email address must be verified first
     */
    readonly _: 'setPassportElement',
    /** Input Telegram Passport element */
    readonly element?: InputPassportElement$Input,
    /** Password of the current user */
    readonly password?: string,
  }

  export type deletePassportElement = {
    /** Deletes a Telegram Passport element */
    readonly _: 'deletePassportElement',
    /** Element type */
    readonly type?: PassportElementType$Input,
  }

  export type setPassportElementErrors = {
    /**
     * Informs the user that some of the elements in their Telegram Passport contain
     * errors; for bots only. The user will not be able to resend the elements, until
     * the errors are fixed
     */
    readonly _: 'setPassportElementErrors',
    /** User identifier */
    readonly user_id?: number,
    /** The errors */
    readonly errors?: ReadonlyArray<inputPassportElementError$Input>,
  }

  export type getPreferredCountryLanguage = {
    /**
     * Returns an IETF language tag of the language preferred in the country, which
     * must be used to fill native fields in Telegram Passport personal details. Returns
     * a 404 error if unknown
     */
    readonly _: 'getPreferredCountryLanguage',
    /** A two-letter ISO 3166-1 alpha-2 country code */
    readonly country_code?: string,
  }

  export type sendPhoneNumberVerificationCode = {
    /** Sends a code to verify a phone number to be added to a user's Telegram Passport */
    readonly _: 'sendPhoneNumberVerificationCode',
    /** The phone number of the user, in international format */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendPhoneNumberVerificationCode = {
    /**
     * Re-sends the code to verify a phone number to be added to a user's Telegram
     * Passport
     */
    readonly _: 'resendPhoneNumberVerificationCode',
  }

  export type checkPhoneNumberVerificationCode = {
    /** Checks the phone number verification code for Telegram Passport */
    readonly _: 'checkPhoneNumberVerificationCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type sendEmailAddressVerificationCode = {
    /** Sends a code to verify an email address to be added to a user's Telegram Passport */
    readonly _: 'sendEmailAddressVerificationCode',
    /** Email address */
    readonly email_address?: string,
  }

  export type resendEmailAddressVerificationCode = {
    /**
     * Re-sends the code to verify an email address to be added to a user's Telegram
     * Passport
     */
    readonly _: 'resendEmailAddressVerificationCode',
  }

  export type checkEmailAddressVerificationCode = {
    /** Checks the email address verification code for Telegram Passport */
    readonly _: 'checkEmailAddressVerificationCode',
    /** Verification code to check */
    readonly code?: string,
  }

  export type getPassportAuthorizationForm = {
    /** Returns a Telegram Passport authorization form for sharing data with a service */
    readonly _: 'getPassportAuthorizationForm',
    /** User identifier of the service's bot */
    readonly bot_user_id?: number,
    /** Telegram Passport element types requested by the service */
    readonly scope?: string,
    /** Service's public key */
    readonly public_key?: string,
    /** Unique request identifier provided by the service */
    readonly nonce?: string,
  }

  export type getPassportAuthorizationFormAvailableElements = {
    /**
     * Returns already available Telegram Passport elements suitable for completing
     * a Telegram Passport authorization form. Result can be received only once for
     * each authorization form
     */
    readonly _: 'getPassportAuthorizationFormAvailableElements',
    /** Authorization form identifier */
    readonly autorization_form_id?: number,
    /** Password of the current user */
    readonly password?: string,
  }

  export type sendPassportAuthorizationForm = {
    /**
     * Sends a Telegram Passport authorization form, effectively sharing data with
     * the service. This method must be called after getPassportAuthorizationFormAvailableElements
     * if some previously available elements are going to be reused
     */
    readonly _: 'sendPassportAuthorizationForm',
    /** Authorization form identifier */
    readonly autorization_form_id?: number,
    /**
     * Types of Telegram Passport elements chosen by user to complete the authorization
     * form
     */
    readonly types?: ReadonlyArray<PassportElementType$Input>,
  }

  export type sendPhoneNumberConfirmationCode = {
    /** Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation */
    readonly _: 'sendPhoneNumberConfirmationCode',
    /** Hash value from the link */
    readonly hash?: string,
    /** Phone number value from the link */
    readonly phone_number?: string,
    /**
     * Settings for the authentication of the user's phone number; pass null to use
     * default settings
     */
    readonly settings?: phoneNumberAuthenticationSettings$Input,
  }

  export type resendPhoneNumberConfirmationCode = {
    /** Resends phone number confirmation code */
    readonly _: 'resendPhoneNumberConfirmationCode',
  }

  export type checkPhoneNumberConfirmationCode = {
    /** Checks phone number confirmation code */
    readonly _: 'checkPhoneNumberConfirmationCode',
    /** Confirmation code to check */
    readonly code?: string,
  }

  export type setBotUpdatesStatus = {
    /**
     * Informs the server about the number of pending bot updates if they haven't been
     * processed for a long time; for bots only
     */
    readonly _: 'setBotUpdatesStatus',
    /** The number of pending updates */
    readonly pending_update_count?: number,
    /** The last error message */
    readonly error_message?: string,
  }

  export type uploadStickerFile = {
    /** Uploads a file with a sticker; returns the uploaded file */
    readonly _: 'uploadStickerFile',
    /** Sticker file owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker file to upload */
    readonly sticker?: InputSticker$Input,
  }

  export type getSuggestedStickerSetName = {
    /** Returns a suggested name for a new sticker set with a given title */
    readonly _: 'getSuggestedStickerSetName',
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
  }

  export type checkStickerSetName = {
    /** Checks whether a name can be used for a new sticker set */
    readonly _: 'checkStickerSetName',
    /** Name to be checked */
    readonly name?: string,
  }

  export type createNewStickerSet = {
    /** Creates a new sticker set. Returns the newly created sticker set */
    readonly _: 'createNewStickerSet',
    /** Sticker set owner; ignored for regular users */
    readonly user_id?: number,
    /** Sticker set title; 1-64 characters */
    readonly title?: string,
    /**
     * Sticker set name. Can contain only English letters, digits and underscores.
     * Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive)
     * for bots; 1-64 characters
     */
    readonly name?: string,
    /** True, if stickers are masks. Animated stickers can't be masks */
    readonly is_masks?: boolean,
    /**
     * List of stickers to be added to the set; must be non-empty. All stickers must
     * be of the same type. For animated stickers, uploadStickerFile must be used before
     * the sticker is shown
     */
    readonly stickers?: ReadonlyArray<InputSticker$Input>,
    /** Source of the sticker set; may be empty if unknown */
    readonly source?: string,
  }

  export type addStickerToSet = {
    /** Adds a new sticker to a set; for bots only. Returns the sticker set */
    readonly _: 'addStickerToSet',
    /** Sticker set owner */
    readonly user_id?: number,
    /** Sticker set name */
    readonly name?: string,
    /** Sticker to add to the set */
    readonly sticker?: InputSticker$Input,
  }

  export type setStickerSetThumbnail = {
    /** Sets a sticker set thumbnail; for bots only. Returns the sticker set */
    readonly _: 'setStickerSetThumbnail',
    /** Sticker set owner */
    readonly user_id?: number,
    /** Sticker set name */
    readonly name?: string,
    /**
     * Thumbnail to set in PNG or TGS format; pass null to remove the sticker set thumbnail.
     * Animated thumbnail must be set for animated sticker sets and only for them
     */
    readonly thumbnail?: InputFile$Input,
  }

  export type setStickerPositionInSet = {
    /**
     * Changes the position of a sticker in the set to which it belongs; for bots only.
     * The sticker set must have been created by the bot
     */
    readonly _: 'setStickerPositionInSet',
    /** Sticker */
    readonly sticker?: InputFile$Input,
    /** New position of the sticker in the set, zero-based */
    readonly position?: number,
  }

  export type removeStickerFromSet = {
    /**
     * Removes a sticker from the set to which it belongs; for bots only. The sticker
     * set must have been created by the bot
     */
    readonly _: 'removeStickerFromSet',
    /** Sticker */
    readonly sticker?: InputFile$Input,
  }

  export type getMapThumbnailFile = {
    /**
     * Returns information about a file with a map thumbnail in PNG format. Only map
     * thumbnail files with size less than 1MB can be downloaded
     */
    readonly _: 'getMapThumbnailFile',
    /** Location of the map center */
    readonly location?: location$Input,
    /** Map zoom level; 13-20 */
    readonly zoom?: number,
    /** Map width in pixels before applying scale; 16-1024 */
    readonly width?: number,
    /** Map height in pixels before applying scale; 16-1024 */
    readonly height?: number,
    /** Map scale; 1-3 */
    readonly scale?: number,
    /** Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown */
    readonly chat_id?: number,
  }

  export type acceptTermsOfService = {
    /** Accepts Telegram terms of services */
    readonly _: 'acceptTermsOfService',
    /** Terms of service identifier */
    readonly terms_of_service_id?: string,
  }

  export type sendCustomRequest = {
    /** Sends a custom request; for bots only */
    readonly _: 'sendCustomRequest',
    /** The method name */
    readonly method?: string,
    /** JSON-serialized method parameters */
    readonly parameters?: string,
  }

  export type answerCustomQuery = {
    /** Answers a custom query; for bots only */
    readonly _: 'answerCustomQuery',
    /** Identifier of a custom query */
    readonly custom_query_id?: number | string,
    /** JSON-serialized answer to the query */
    readonly data?: string,
  }

  export type setAlarm = {
    /** Succeeds after a specified amount of time has passed. Can be called before initialization */
    readonly _: 'setAlarm',
    /** Number of seconds before the function returns */
    readonly seconds?: number,
  }

  export type getCountries = {
    /** Returns information about existing countries. Can be called before authorization */
    readonly _: 'getCountries',
  }

  export type getCountryCode = {
    /**
     * Uses the current IP address to find the current country. Returns two-letter
     * ISO 3166-1 alpha-2 country code. Can be called before authorization
     */
    readonly _: 'getCountryCode',
  }

  export type getPhoneNumberInfo = {
    /**
     * Returns information about a phone number by its prefix. Can be called before
     * authorization
     */
    readonly _: 'getPhoneNumberInfo',
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getPhoneNumberInfoSync = {
    /**
     * Returns information about a phone number by its prefix synchronously. getCountries
     * must be called at least once after changing localization to the specified language
     * if properly localized country information is expected. Can be called synchronously
     */
    readonly _: 'getPhoneNumberInfoSync',
    /** A two-letter ISO 639-1 country code for country information localization */
    readonly language_code?: string,
    /** The phone number prefix */
    readonly phone_number_prefix?: string,
  }

  export type getApplicationDownloadLink = {
    /**
     * Returns the link for downloading official Telegram application to be used when
     * the current user invites friends to Telegram
     */
    readonly _: 'getApplicationDownloadLink',
  }

  export type getDeepLinkInfo = {
    /**
     * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature"
     * or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown
     * links. Can be called before authorization
     */
    readonly _: 'getDeepLinkInfo',
    /** The link */
    readonly link?: string,
  }

  export type getApplicationConfig = {
    /** Returns application config, provided by the server. Can be called before authorization */
    readonly _: 'getApplicationConfig',
  }

  export type saveApplicationLogEvent = {
    /** Saves application log event on the server. Can be called before authorization */
    readonly _: 'saveApplicationLogEvent',
    /** Event type */
    readonly type?: string,
    /** Optional chat identifier, associated with the event */
    readonly chat_id?: number,
    /** The log event data */
    readonly data?: JsonValue$Input,
  }

  export type addProxy = {
    /** Adds a proxy server for network requests. Can be called before authorization */
    readonly _: 'addProxy',
    /** Proxy server IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** True, if the proxy needs to be enabled */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type editProxy = {
    /** Edits an existing proxy server for network requests. Can be called before authorization */
    readonly _: 'editProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
    /** Proxy server IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** True, if the proxy needs to be enabled */
    readonly enable?: boolean,
    /** Proxy type */
    readonly type?: ProxyType$Input,
  }

  export type enableProxy = {
    /**
     * Enables a proxy. Only one proxy can be enabled at a time. Can be called before
     * authorization
     */
    readonly _: 'enableProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type disableProxy = {
    /** Disables the currently enabled proxy. Can be called before authorization */
    readonly _: 'disableProxy',
  }

  export type removeProxy = {
    /** Removes a proxy server. Can be called before authorization */
    readonly _: 'removeProxy',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type getProxies = {
    /** Returns list of proxies that are currently set up. Can be called before authorization */
    readonly _: 'getProxies',
  }

  export type getProxyLink = {
    /**
     * Returns an HTTPS link, which can be used to add a proxy. Available only for
     * SOCKS5 and MTProto proxies. Can be called before authorization
     */
    readonly _: 'getProxyLink',
    /** Proxy identifier */
    readonly proxy_id?: number,
  }

  export type pingProxy = {
    /**
     * Computes time needed to receive a response from a Telegram server through a
     * proxy. Can be called before authorization
     */
    readonly _: 'pingProxy',
    /** Proxy identifier. Use 0 to ping a Telegram server without a proxy */
    readonly proxy_id?: number,
  }

  export type setLogStream = {
    /** Sets new log stream for internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogStream',
    /** New log stream */
    readonly log_stream?: LogStream$Input,
  }

  export type getLogStream = {
    /**
     * Returns information about currently used log stream for internal logging of
     * TDLib. Can be called synchronously
     */
    readonly _: 'getLogStream',
  }

  export type setLogVerbosityLevel = {
    /** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
    readonly _: 'setLogVerbosityLevel',
    /**
     * New value of the verbosity level for logging. Value 0 corresponds to fatal errors,
     * value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
     * value 3 corresponds to informational, value 4 corresponds to debug, value 5
     * corresponds to verbose debug, value greater than 5 and up to 1023 can be used
     * to enable even more logging
     */
    readonly new_verbosity_level?: number,
  }

  export type getLogVerbosityLevel = {
    /**
     * Returns current verbosity level of the internal logging of TDLib. Can be called
     * synchronously
     */
    readonly _: 'getLogVerbosityLevel',
  }

  export type getLogTags = {
    /**
     * Returns list of available TDLib internal log tags, for example, ["actor", "binlog",
     * "connections", "notifications", "proxy"]. Can be called synchronously
     */
    readonly _: 'getLogTags',
  }

  export type setLogTagVerbosityLevel = {
    /**
     * Sets the verbosity level for a specified TDLib internal log tag. Can be called
     * synchronously
     */
    readonly _: 'setLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
    /** New verbosity level; 1-1024 */
    readonly new_verbosity_level?: number,
  }

  export type getLogTagVerbosityLevel = {
    /**
     * Returns current verbosity level for a specified TDLib internal log tag. Can
     * be called synchronously
     */
    readonly _: 'getLogTagVerbosityLevel',
    /** Logging tag to change verbosity level */
    readonly tag?: string,
  }

  export type addLogMessage = {
    /** Adds a message to TDLib internal log. Can be called synchronously */
    readonly _: 'addLogMessage',
    /** The minimum verbosity level needed for the message to be logged; 0-1023 */
    readonly verbosity_level?: number,
    /** Text of a message to log */
    readonly text?: string,
  }

  export type testCallEmpty = {
    /**
     * Does nothing; for testing only. This is an offline method. Can be called before
     * authorization
     */
    readonly _: 'testCallEmpty',
  }

  export type testCallString = {
    /**
     * Returns the received string; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallString',
    /** String to return */
    readonly x?: string,
  }

  export type testCallBytes = {
    /**
     * Returns the received bytes; for testing only. This is an offline method. Can
     * be called before authorization
     */
    readonly _: 'testCallBytes',
    /** Bytes to return */
    readonly x?: string,
  }

  export type testCallVectorInt = {
    /**
     * Returns the received vector of numbers; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorInt',
    /** Vector of numbers to return */
    readonly x?: ReadonlyArray<number>,
  }

  export type testCallVectorIntObject = {
    /**
     * Returns the received vector of objects containing a number; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorIntObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testInt$Input>,
  }

  export type testCallVectorString = {
    /**
     * Returns the received vector of strings; for testing only. This is an offline
     * method. Can be called before authorization
     */
    readonly _: 'testCallVectorString',
    /** Vector of strings to return */
    readonly x?: ReadonlyArray<string>,
  }

  export type testCallVectorStringObject = {
    /**
     * Returns the received vector of objects containing a string; for testing only.
     * This is an offline method. Can be called before authorization
     */
    readonly _: 'testCallVectorStringObject',
    /** Vector of objects to return */
    readonly x?: ReadonlyArray<testString$Input>,
  }

  export type testSquareInt = {
    /**
     * Returns the squared received number; for testing only. This is an offline method.
     * Can be called before authorization
     */
    readonly _: 'testSquareInt',
    /** Number to square */
    readonly x?: number,
  }

  export type testNetwork = {
    /**
     * Sends a simple network request to the Telegram servers; for testing only. Can
     * be called before authorization
     */
    readonly _: 'testNetwork',
  }

  export type testProxy = {
    /**
     * Sends a simple network request to the Telegram servers via proxy; for testing
     * only. Can be called before authorization
     */
    readonly _: 'testProxy',
    /** Proxy server IP address */
    readonly server?: string,
    /** Proxy server port */
    readonly port?: number,
    /** Proxy type */
    readonly type?: ProxyType$Input,
    /** Identifier of a datacenter, with which to test connection */
    readonly dc_id?: number,
    /** The maximum overall timeout for the request */
    readonly timeout?: number,
  }

  export type testGetDifference = {
    /** Forces an updates.getDifference call to the Telegram servers; for testing only */
    readonly _: 'testGetDifference',
  }

  export type testUseUpdate = {
    /**
     * Does nothing and ensures that the Update object is used; for testing only. This
     * is an offline method. Can be called before authorization
     */
    readonly _: 'testUseUpdate',
  }

  export type testReturnError = {
    /**
     * Returns the specified error and ensures that the Error object is used; for testing
     * only. Can be called synchronously
     */
    readonly _: 'testReturnError',
    /** The error to be returned */
    readonly error?: error$Input,
  }

  // ----

  export type Error = error

  export type Ok = ok

  /**
   * Provides information about the method by which an authentication code is delivered
   * to the user
   */
  export type AuthenticationCodeType =
    | authenticationCodeTypeTelegramMessage
    | authenticationCodeTypeSms
    | authenticationCodeTypeCall
    | authenticationCodeTypeFlashCall
    | authenticationCodeTypeMissedCall

  export type AuthenticationCodeInfo = authenticationCodeInfo

  export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo

  export type TextEntities = textEntities

  export type FormattedText = formattedText

  /** Represents the current authorization state of the TDLib client */
  export type AuthorizationState =
    | authorizationStateWaitTdlibParameters
    | authorizationStateWaitEncryptionKey
    | authorizationStateWaitPhoneNumber
    | authorizationStateWaitCode
    | authorizationStateWaitOtherDeviceConfirmation
    | authorizationStateWaitRegistration
    | authorizationStateWaitPassword
    | authorizationStateReady
    | authorizationStateLoggingOut
    | authorizationStateClosing
    | authorizationStateClosed

  export type PasswordState = passwordState

  export type RecoveryEmailAddress = recoveryEmailAddress

  export type TemporaryPasswordState = temporaryPasswordState

  export type File = file

  /** Points to a file */
  export type InputFile =
    | inputFileId
    | inputFileRemote
    | inputFileLocal
    | inputFileGenerated

  /** Points to a file */
  export type InputFile$Input =
    | inputFileId$Input
    | inputFileRemote$Input
    | inputFileLocal$Input
    | inputFileGenerated$Input

  /** Describes format of the thumbnail */
  export type ThumbnailFormat =
    | thumbnailFormatJpeg
    | thumbnailFormatPng
    | thumbnailFormatWebp
    | thumbnailFormatGif
    | thumbnailFormatTgs
    | thumbnailFormatMpeg4

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint =
    | maskPointForehead
    | maskPointEyes
    | maskPointMouth
    | maskPointChin

  /** Part of the face, relative to which a mask is placed */
  export type MaskPoint$Input =
    | maskPointForehead$Input
    | maskPointEyes$Input
    | maskPointMouth$Input
    | maskPointChin$Input

  /** Describes the type of a poll */
  export type PollType =
    | pollTypeRegular
    | pollTypeQuiz

  /** Describes the type of a poll */
  export type PollType$Input =
    | pollTypeRegular$Input
    | pollTypeQuiz$Input

  export type Sticker = sticker

  export type AnimatedEmoji = animatedEmoji

  /**
   * Represents the type of a user. The following types are possible: regular users,
   * deleted users and bots
   */
  export type UserType =
    | userTypeRegular
    | userTypeDeleted
    | userTypeBot
    | userTypeUnknown

  export type BotCommands = botCommands

  export type ChatPhotos = chatPhotos

  /** Describes a photo to be set as a user profile or chat photo */
  export type InputChatPhoto$Input =
    | inputChatPhotoPrevious$Input
    | inputChatPhotoStatic$Input
    | inputChatPhotoAnimation$Input

  export type User = user

  export type UserFullInfo = userFullInfo

  export type Users = users

  export type ChatAdministrators = chatAdministrators

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus =
    | chatMemberStatusCreator
    | chatMemberStatusAdministrator
    | chatMemberStatusMember
    | chatMemberStatusRestricted
    | chatMemberStatusLeft
    | chatMemberStatusBanned

  /** Provides information about the status of a member in a chat */
  export type ChatMemberStatus$Input =
    | chatMemberStatusCreator$Input
    | chatMemberStatusAdministrator$Input
    | chatMemberStatusMember$Input
    | chatMemberStatusRestricted$Input
    | chatMemberStatusLeft$Input
    | chatMemberStatusBanned$Input

  export type ChatMember = chatMember

  export type ChatMembers = chatMembers

  /** Specifies the kind of chat members to return in searchChatMembers */
  export type ChatMembersFilter$Input =
    | chatMembersFilterContacts$Input
    | chatMembersFilterAdministrators$Input
    | chatMembersFilterMembers$Input
    | chatMembersFilterMention$Input
    | chatMembersFilterRestricted$Input
    | chatMembersFilterBanned$Input
    | chatMembersFilterBots$Input

  /** Specifies the kind of chat members to return in getSupergroupMembers */
  export type SupergroupMembersFilter$Input =
    | supergroupMembersFilterRecent$Input
    | supergroupMembersFilterContacts$Input
    | supergroupMembersFilterAdministrators$Input
    | supergroupMembersFilterSearch$Input
    | supergroupMembersFilterRestricted$Input
    | supergroupMembersFilterBanned$Input
    | supergroupMembersFilterMention$Input
    | supergroupMembersFilterBots$Input

  export type ChatInviteLink = chatInviteLink

  export type ChatInviteLinks = chatInviteLinks

  export type ChatInviteLinkCounts = chatInviteLinkCounts

  export type ChatInviteLinkMembers = chatInviteLinkMembers

  export type ChatInviteLinkInfo = chatInviteLinkInfo

  export type ChatJoinRequests = chatJoinRequests

  export type BasicGroup = basicGroup

  export type BasicGroupFullInfo = basicGroupFullInfo

  export type Supergroup = supergroup

  export type SupergroupFullInfo = supergroupFullInfo

  /** Describes the current secret chat state */
  export type SecretChatState =
    | secretChatStatePending
    | secretChatStateReady
    | secretChatStateClosed

  export type SecretChat = secretChat

  /** Contains information about the sender of a message */
  export type MessageSender =
    | messageSenderUser
    | messageSenderChat

  /** Contains information about the sender of a message */
  export type MessageSender$Input =
    | messageSenderUser$Input
    | messageSenderChat$Input

  export type MessageSenders = messageSenders

  /** Contains information about the origin of a forwarded message */
  export type MessageForwardOrigin =
    | messageForwardOriginUser
    | messageForwardOriginChat
    | messageForwardOriginHiddenUser
    | messageForwardOriginChannel
    | messageForwardOriginMessageImport

  /** Contains information about the sending state of the message */
  export type MessageSendingState =
    | messageSendingStatePending
    | messageSendingStateFailed

  export type Message = message

  export type Messages = messages

  export type FoundMessages = foundMessages

  export type MessagePositions = messagePositions

  export type MessageCalendar = messageCalendar

  export type SponsoredMessage = sponsoredMessage

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope =
    | notificationSettingsScopePrivateChats
    | notificationSettingsScopeGroupChats
    | notificationSettingsScopeChannelChats

  /** Describes the types of chats to which notification settings are relevant */
  export type NotificationSettingsScope$Input =
    | notificationSettingsScopePrivateChats$Input
    | notificationSettingsScopeGroupChats$Input
    | notificationSettingsScopeChannelChats$Input

  export type ScopeNotificationSettings = scopeNotificationSettings

  /** Describes the type of a chat */
  export type ChatType =
    | chatTypePrivate
    | chatTypeBasicGroup
    | chatTypeSupergroup
    | chatTypeSecret

  export type ChatFilter = chatFilter

  export type ChatFilterInfo = chatFilterInfo

  export type RecommendedChatFilters = recommendedChatFilters

  /** Describes a list of chats */
  export type ChatList =
    | chatListMain
    | chatListArchive
    | chatListFilter

  /** Describes a list of chats */
  export type ChatList$Input =
    | chatListMain$Input
    | chatListArchive$Input
    | chatListFilter$Input

  export type ChatLists = chatLists

  /** Describes a reason why an external chat is shown in a chat list */
  export type ChatSource =
    | chatSourceMtprotoProxy
    | chatSourcePublicServiceAnnouncement

  export type Chat = chat

  export type Chats = chats

  export type ChatsNearby = chatsNearby

  /** Describes a type of public chats */
  export type PublicChatType$Input =
    | publicChatTypeHasUsername$Input
    | publicChatTypeIsLocationBased$Input

  /** Describes actions which must be possible to do through a chat action bar */
  export type ChatActionBar =
    | chatActionBarReportSpam
    | chatActionBarReportUnrelatedLocation
    | chatActionBarInviteMembers
    | chatActionBarReportAddBlock
    | chatActionBarAddContact
    | chatActionBarSharePhoneNumber
    | chatActionBarJoinRequest

  /** Describes a keyboard button type */
  export type KeyboardButtonType =
    | keyboardButtonTypeText
    | keyboardButtonTypeRequestPhoneNumber
    | keyboardButtonTypeRequestLocation
    | keyboardButtonTypeRequestPoll

  /** Describes a keyboard button type */
  export type KeyboardButtonType$Input =
    | keyboardButtonTypeText$Input
    | keyboardButtonTypeRequestPhoneNumber$Input
    | keyboardButtonTypeRequestLocation$Input
    | keyboardButtonTypeRequestPoll$Input

  /** Describes the type of an inline keyboard button */
  export type InlineKeyboardButtonType =
    | inlineKeyboardButtonTypeUrl
    | inlineKeyboardButtonTypeLoginUrl
    | inlineKeyboardButtonTypeCallback
    | inlineKeyboardButtonTypeCallbackWithPassword
    | inlineKeyboardButtonTypeCallbackGame
    | inlineKeyboardButtonTypeSwitchInline
    | inlineKeyboardButtonTypeBuy
    | inlineKeyboardButtonTypeUser

  /** Describes the type of an inline keyboard button */
  export type InlineKeyboardButtonType$Input =
    | inlineKeyboardButtonTypeUrl$Input
    | inlineKeyboardButtonTypeLoginUrl$Input
    | inlineKeyboardButtonTypeCallback$Input
    | inlineKeyboardButtonTypeCallbackWithPassword$Input
    | inlineKeyboardButtonTypeCallbackGame$Input
    | inlineKeyboardButtonTypeSwitchInline$Input
    | inlineKeyboardButtonTypeBuy$Input
    | inlineKeyboardButtonTypeUser$Input

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup =
    | replyMarkupRemoveKeyboard
    | replyMarkupForceReply
    | replyMarkupShowKeyboard
    | replyMarkupInlineKeyboard

  /**
   * Contains a description of a custom keyboard and actions that can be done with
   * it to quickly reply to bots
   */
  export type ReplyMarkup$Input =
    | replyMarkupRemoveKeyboard$Input
    | replyMarkupForceReply$Input
    | replyMarkupShowKeyboard$Input
    | replyMarkupInlineKeyboard$Input

  /** Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl */
  export type LoginUrlInfo =
    | loginUrlInfoOpen
    | loginUrlInfoRequestConfirmation

  export type MessageThreadInfo = messageThreadInfo

  /** Describes a text object inside an instant-view web page */
  export type RichText =
    | richTextPlain
    | richTextBold
    | richTextItalic
    | richTextUnderline
    | richTextStrikethrough
    | richTextFixed
    | richTextUrl
    | richTextEmailAddress
    | richTextSubscript
    | richTextSuperscript
    | richTextMarked
    | richTextPhoneNumber
    | richTextIcon
    | richTextReference
    | richTextAnchor
    | richTextAnchorLink
    | richTexts

  /** Describes a horizontal alignment of a table cell content */
  export type PageBlockHorizontalAlignment =
    | pageBlockHorizontalAlignmentLeft
    | pageBlockHorizontalAlignmentCenter
    | pageBlockHorizontalAlignmentRight

  /** Describes a Vertical alignment of a table cell content */
  export type PageBlockVerticalAlignment =
    | pageBlockVerticalAlignmentTop
    | pageBlockVerticalAlignmentMiddle
    | pageBlockVerticalAlignmentBottom

  /** Describes a block of an instant view web page */
  export type PageBlock =
    | pageBlockTitle
    | pageBlockSubtitle
    | pageBlockAuthorDate
    | pageBlockHeader
    | pageBlockSubheader
    | pageBlockKicker
    | pageBlockParagraph
    | pageBlockPreformatted
    | pageBlockFooter
    | pageBlockDivider
    | pageBlockAnchor
    | pageBlockList
    | pageBlockBlockQuote
    | pageBlockPullQuote
    | pageBlockAnimation
    | pageBlockAudio
    | pageBlockPhoto
    | pageBlockVideo
    | pageBlockVoiceNote
    | pageBlockCover
    | pageBlockEmbedded
    | pageBlockEmbeddedPost
    | pageBlockCollage
    | pageBlockSlideshow
    | pageBlockChatLink
    | pageBlockTable
    | pageBlockDetails
    | pageBlockRelatedArticles
    | pageBlockMap

  export type WebPageInstantView = webPageInstantView

  export type WebPage = webPage

  export type Countries = countries

  export type PhoneNumberInfo = phoneNumberInfo

  export type BankCardInfo = bankCardInfo

  export type OrderInfo = orderInfo

  /** Contains information about the payment method chosen by the user */
  export type InputCredentials$Input =
    | inputCredentialsSaved$Input
    | inputCredentialsNew$Input
    | inputCredentialsApplePay$Input
    | inputCredentialsGooglePay$Input

  export type PaymentForm = paymentForm

  export type ValidatedOrderInfo = validatedOrderInfo

  export type PaymentResult = paymentResult

  export type PaymentReceipt = paymentReceipt

  /** Contains the type of a Telegram Passport element */
  export type PassportElementType =
    | passportElementTypePersonalDetails
    | passportElementTypePassport
    | passportElementTypeDriverLicense
    | passportElementTypeIdentityCard
    | passportElementTypeInternalPassport
    | passportElementTypeAddress
    | passportElementTypeUtilityBill
    | passportElementTypeBankStatement
    | passportElementTypeRentalAgreement
    | passportElementTypePassportRegistration
    | passportElementTypeTemporaryRegistration
    | passportElementTypePhoneNumber
    | passportElementTypeEmailAddress

  /** Contains the type of a Telegram Passport element */
  export type PassportElementType$Input =
    | passportElementTypePersonalDetails$Input
    | passportElementTypePassport$Input
    | passportElementTypeDriverLicense$Input
    | passportElementTypeIdentityCard$Input
    | passportElementTypeInternalPassport$Input
    | passportElementTypeAddress$Input
    | passportElementTypeUtilityBill$Input
    | passportElementTypeBankStatement$Input
    | passportElementTypeRentalAgreement$Input
    | passportElementTypePassportRegistration$Input
    | passportElementTypeTemporaryRegistration$Input
    | passportElementTypePhoneNumber$Input
    | passportElementTypeEmailAddress$Input

  /** Contains information about a Telegram Passport element */
  export type PassportElement =
    | passportElementPersonalDetails
    | passportElementPassport
    | passportElementDriverLicense
    | passportElementIdentityCard
    | passportElementInternalPassport
    | passportElementAddress
    | passportElementUtilityBill
    | passportElementBankStatement
    | passportElementRentalAgreement
    | passportElementPassportRegistration
    | passportElementTemporaryRegistration
    | passportElementPhoneNumber
    | passportElementEmailAddress

  /** Contains information about a Telegram Passport element to be saved */
  export type InputPassportElement$Input =
    | inputPassportElementPersonalDetails$Input
    | inputPassportElementPassport$Input
    | inputPassportElementDriverLicense$Input
    | inputPassportElementIdentityCard$Input
    | inputPassportElementInternalPassport$Input
    | inputPassportElementAddress$Input
    | inputPassportElementUtilityBill$Input
    | inputPassportElementBankStatement$Input
    | inputPassportElementRentalAgreement$Input
    | inputPassportElementPassportRegistration$Input
    | inputPassportElementTemporaryRegistration$Input
    | inputPassportElementPhoneNumber$Input
    | inputPassportElementEmailAddress$Input

  export type PassportElements = passportElements

  /** Contains the description of an error in a Telegram Passport element */
  export type PassportElementErrorSource =
    | passportElementErrorSourceUnspecified
    | passportElementErrorSourceDataField
    | passportElementErrorSourceFrontSide
    | passportElementErrorSourceReverseSide
    | passportElementErrorSourceSelfie
    | passportElementErrorSourceTranslationFile
    | passportElementErrorSourceTranslationFiles
    | passportElementErrorSourceFile
    | passportElementErrorSourceFiles

  export type PassportAuthorizationForm = passportAuthorizationForm

  export type PassportElementsWithErrors = passportElementsWithErrors

  /**
   * Contains the description of an error in a Telegram Passport element; for bots
   * only
   */
  export type InputPassportElementErrorSource$Input =
    | inputPassportElementErrorSourceUnspecified$Input
    | inputPassportElementErrorSourceDataField$Input
    | inputPassportElementErrorSourceFrontSide$Input
    | inputPassportElementErrorSourceReverseSide$Input
    | inputPassportElementErrorSourceSelfie$Input
    | inputPassportElementErrorSourceTranslationFile$Input
    | inputPassportElementErrorSourceTranslationFiles$Input
    | inputPassportElementErrorSourceFile$Input
    | inputPassportElementErrorSourceFiles$Input

  /** Contains the content of a message */
  export type MessageContent =
    | messageText
    | messageAnimation
    | messageAudio
    | messageDocument
    | messagePhoto
    | messageExpiredPhoto
    | messageSticker
    | messageVideo
    | messageExpiredVideo
    | messageVideoNote
    | messageVoiceNote
    | messageLocation
    | messageVenue
    | messageContact
    | messageAnimatedEmoji
    | messageDice
    | messageGame
    | messagePoll
    | messageInvoice
    | messageCall
    | messageVideoChatScheduled
    | messageVideoChatStarted
    | messageVideoChatEnded
    | messageInviteVideoChatParticipants
    | messageBasicGroupChatCreate
    | messageSupergroupChatCreate
    | messageChatChangeTitle
    | messageChatChangePhoto
    | messageChatDeletePhoto
    | messageChatAddMembers
    | messageChatJoinByLink
    | messageChatJoinByRequest
    | messageChatDeleteMember
    | messageChatUpgradeTo
    | messageChatUpgradeFrom
    | messagePinMessage
    | messageScreenshotTaken
    | messageChatSetTheme
    | messageChatSetTtl
    | messageCustomServiceAction
    | messageGameScore
    | messagePaymentSuccessful
    | messagePaymentSuccessfulBot
    | messageContactRegistered
    | messageWebsiteConnected
    | messagePassportDataSent
    | messagePassportDataReceived
    | messageProximityAlertTriggered
    | messageUnsupported

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType =
    | textEntityTypeMention
    | textEntityTypeHashtag
    | textEntityTypeCashtag
    | textEntityTypeBotCommand
    | textEntityTypeUrl
    | textEntityTypeEmailAddress
    | textEntityTypePhoneNumber
    | textEntityTypeBankCardNumber
    | textEntityTypeBold
    | textEntityTypeItalic
    | textEntityTypeUnderline
    | textEntityTypeStrikethrough
    | textEntityTypeCode
    | textEntityTypePre
    | textEntityTypePreCode
    | textEntityTypeTextUrl
    | textEntityTypeMentionName
    | textEntityTypeMediaTimestamp

  /** Represents a part of the text which must be formatted differently */
  export type TextEntityType$Input =
    | textEntityTypeMention$Input
    | textEntityTypeHashtag$Input
    | textEntityTypeCashtag$Input
    | textEntityTypeBotCommand$Input
    | textEntityTypeUrl$Input
    | textEntityTypeEmailAddress$Input
    | textEntityTypePhoneNumber$Input
    | textEntityTypeBankCardNumber$Input
    | textEntityTypeBold$Input
    | textEntityTypeItalic$Input
    | textEntityTypeUnderline$Input
    | textEntityTypeStrikethrough$Input
    | textEntityTypeCode$Input
    | textEntityTypePre$Input
    | textEntityTypePreCode$Input
    | textEntityTypeTextUrl$Input
    | textEntityTypeMentionName$Input
    | textEntityTypeMediaTimestamp$Input

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState =
    | messageSchedulingStateSendAtDate
    | messageSchedulingStateSendWhenOnline

  /** Contains information about the time when a scheduled message will be sent */
  export type MessageSchedulingState$Input =
    | messageSchedulingStateSendAtDate$Input
    | messageSchedulingStateSendWhenOnline$Input

  /** The content of a message to send */
  export type InputMessageContent =
    | inputMessageText
    | inputMessageAnimation
    | inputMessageAudio
    | inputMessageDocument
    | inputMessagePhoto
    | inputMessageSticker
    | inputMessageVideo
    | inputMessageVideoNote
    | inputMessageVoiceNote
    | inputMessageLocation
    | inputMessageVenue
    | inputMessageContact
    | inputMessageDice
    | inputMessageGame
    | inputMessageInvoice
    | inputMessagePoll
    | inputMessageForwarded

  /** The content of a message to send */
  export type InputMessageContent$Input =
    | inputMessageText$Input
    | inputMessageAnimation$Input
    | inputMessageAudio$Input
    | inputMessageDocument$Input
    | inputMessagePhoto$Input
    | inputMessageSticker$Input
    | inputMessageVideo$Input
    | inputMessageVideoNote$Input
    | inputMessageVoiceNote$Input
    | inputMessageLocation$Input
    | inputMessageVenue$Input
    | inputMessageContact$Input
    | inputMessageDice$Input
    | inputMessageGame$Input
    | inputMessageInvoice$Input
    | inputMessagePoll$Input
    | inputMessageForwarded$Input

  /** Represents a filter for message search results */
  export type SearchMessagesFilter$Input =
    | searchMessagesFilterEmpty$Input
    | searchMessagesFilterAnimation$Input
    | searchMessagesFilterAudio$Input
    | searchMessagesFilterDocument$Input
    | searchMessagesFilterPhoto$Input
    | searchMessagesFilterVideo$Input
    | searchMessagesFilterVoiceNote$Input
    | searchMessagesFilterPhotoAndVideo$Input
    | searchMessagesFilterUrl$Input
    | searchMessagesFilterChatPhoto$Input
    | searchMessagesFilterVideoNote$Input
    | searchMessagesFilterVoiceAndVideoNote$Input
    | searchMessagesFilterMention$Input
    | searchMessagesFilterUnreadMention$Input
    | searchMessagesFilterFailedToSend$Input
    | searchMessagesFilterPinned$Input

  /** Describes the different types of activity in a chat */
  export type ChatAction =
    | chatActionTyping
    | chatActionRecordingVideo
    | chatActionUploadingVideo
    | chatActionRecordingVoiceNote
    | chatActionUploadingVoiceNote
    | chatActionUploadingPhoto
    | chatActionUploadingDocument
    | chatActionChoosingSticker
    | chatActionChoosingLocation
    | chatActionChoosingContact
    | chatActionStartPlayingGame
    | chatActionRecordingVideoNote
    | chatActionUploadingVideoNote
    | chatActionWatchingAnimations
    | chatActionCancel

  /** Describes the different types of activity in a chat */
  export type ChatAction$Input =
    | chatActionTyping$Input
    | chatActionRecordingVideo$Input
    | chatActionUploadingVideo$Input
    | chatActionRecordingVoiceNote$Input
    | chatActionUploadingVoiceNote$Input
    | chatActionUploadingPhoto$Input
    | chatActionUploadingDocument$Input
    | chatActionChoosingSticker$Input
    | chatActionChoosingLocation$Input
    | chatActionChoosingContact$Input
    | chatActionStartPlayingGame$Input
    | chatActionRecordingVideoNote$Input
    | chatActionUploadingVideoNote$Input
    | chatActionWatchingAnimations$Input
    | chatActionCancel$Input

  /** Describes the last time the user was online */
  export type UserStatus =
    | userStatusEmpty
    | userStatusOnline
    | userStatusOffline
    | userStatusRecently
    | userStatusLastWeek
    | userStatusLastMonth

  export type Stickers = stickers

  export type Emojis = emojis

  export type StickerSet = stickerSet

  export type StickerSets = stickerSets

  /** Describes the reason why a call was discarded */
  export type CallDiscardReason =
    | callDiscardReasonEmpty
    | callDiscardReasonMissed
    | callDiscardReasonDeclined
    | callDiscardReasonDisconnected
    | callDiscardReasonHungUp

  /** Describes the type of a call server */
  export type CallServerType =
    | callServerTypeTelegramReflector
    | callServerTypeWebrtc

  export type CallId = callId

  export type GroupCallId = groupCallId

  /** Describes the current call state */
  export type CallState =
    | callStatePending
    | callStateExchangingKeys
    | callStateReady
    | callStateHangingUp
    | callStateDiscarded
    | callStateError

  /** Describes the quality of a group call video */
  export type GroupCallVideoQuality$Input =
    | groupCallVideoQualityThumbnail$Input
    | groupCallVideoQualityMedium$Input
    | groupCallVideoQualityFull$Input

  export type GroupCall = groupCall

  /** Describes the exact type of a problem with a call */
  export type CallProblem$Input =
    | callProblemEcho$Input
    | callProblemNoise$Input
    | callProblemInterruptions$Input
    | callProblemDistortedSpeech$Input
    | callProblemSilentLocal$Input
    | callProblemSilentRemote$Input
    | callProblemDropped$Input
    | callProblemDistortedVideo$Input
    | callProblemPixelatedVideo$Input

  export type Animations = animations

  /** Contains animated stickers which must be used for dice animation rendering */
  export type DiceStickers =
    | diceStickersRegular
    | diceStickersSlotMachine

  export type ImportedContacts = importedContacts

  export type HttpUrl = httpUrl

  /** Represents a single result of an inline query; for bots only */
  export type InputInlineQueryResult$Input =
    | inputInlineQueryResultAnimation$Input
    | inputInlineQueryResultArticle$Input
    | inputInlineQueryResultAudio$Input
    | inputInlineQueryResultContact$Input
    | inputInlineQueryResultDocument$Input
    | inputInlineQueryResultGame$Input
    | inputInlineQueryResultLocation$Input
    | inputInlineQueryResultPhoto$Input
    | inputInlineQueryResultSticker$Input
    | inputInlineQueryResultVenue$Input
    | inputInlineQueryResultVideo$Input
    | inputInlineQueryResultVoiceNote$Input

  /** Represents a single result of an inline query */
  export type InlineQueryResult =
    | inlineQueryResultArticle
    | inlineQueryResultContact
    | inlineQueryResultLocation
    | inlineQueryResultVenue
    | inlineQueryResultGame
    | inlineQueryResultAnimation
    | inlineQueryResultAudio
    | inlineQueryResultDocument
    | inlineQueryResultPhoto
    | inlineQueryResultSticker
    | inlineQueryResultVideo
    | inlineQueryResultVoiceNote

  export type InlineQueryResults = inlineQueryResults

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload =
    | callbackQueryPayloadData
    | callbackQueryPayloadDataWithPassword
    | callbackQueryPayloadGame

  /** Represents a payload of a callback query */
  export type CallbackQueryPayload$Input =
    | callbackQueryPayloadData$Input
    | callbackQueryPayloadDataWithPassword$Input
    | callbackQueryPayloadGame$Input

  export type CallbackQueryAnswer = callbackQueryAnswer

  export type CustomRequestResult = customRequestResult

  export type GameHighScores = gameHighScores

  /** Represents a chat event */
  export type ChatEventAction =
    | chatEventMessageEdited
    | chatEventMessageDeleted
    | chatEventPollStopped
    | chatEventMessagePinned
    | chatEventMessageUnpinned
    | chatEventMemberJoined
    | chatEventMemberJoinedByInviteLink
    | chatEventMemberJoinedByRequest
    | chatEventMemberLeft
    | chatEventMemberInvited
    | chatEventMemberPromoted
    | chatEventMemberRestricted
    | chatEventTitleChanged
    | chatEventPermissionsChanged
    | chatEventDescriptionChanged
    | chatEventUsernameChanged
    | chatEventPhotoChanged
    | chatEventInvitesToggled
    | chatEventLinkedChatChanged
    | chatEventSlowModeDelayChanged
    | chatEventMessageTtlChanged
    | chatEventSignMessagesToggled
    | chatEventHasProtectedContentToggled
    | chatEventStickerSetChanged
    | chatEventLocationChanged
    | chatEventIsAllHistoryAvailableToggled
    | chatEventInviteLinkEdited
    | chatEventInviteLinkRevoked
    | chatEventInviteLinkDeleted
    | chatEventVideoChatCreated
    | chatEventVideoChatEnded
    | chatEventVideoChatParticipantIsMutedToggled
    | chatEventVideoChatParticipantVolumeLevelChanged
    | chatEventVideoChatMuteNewParticipantsToggled

  export type ChatEvents = chatEvents

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue =
    | languagePackStringValueOrdinary
    | languagePackStringValuePluralized
    | languagePackStringValueDeleted

  /** Represents the value of a string in a language pack */
  export type LanguagePackStringValue$Input =
    | languagePackStringValueOrdinary$Input
    | languagePackStringValuePluralized$Input
    | languagePackStringValueDeleted$Input

  export type LanguagePackStrings = languagePackStrings

  export type LanguagePackInfo = languagePackInfo

  export type LocalizationTargetInfo = localizationTargetInfo

  /**
   * Represents a data needed to subscribe for push notifications through registerDevice
   * method. To use specific push notification service, the correct application platform
   * must be specified and a valid server authentication data must be uploaded at
   * https://my.telegram.org
   */
  export type DeviceToken$Input =
    | deviceTokenFirebaseCloudMessaging$Input
    | deviceTokenApplePush$Input
    | deviceTokenApplePushVoIP$Input
    | deviceTokenWindowsPush$Input
    | deviceTokenMicrosoftPush$Input
    | deviceTokenMicrosoftPushVoIP$Input
    | deviceTokenWebPush$Input
    | deviceTokenSimplePush$Input
    | deviceTokenUbuntuPush$Input
    | deviceTokenBlackBerryPush$Input
    | deviceTokenTizenPush$Input

  export type PushReceiverId = pushReceiverId

  /** Describes a fill of a background */
  export type BackgroundFill =
    | backgroundFillSolid
    | backgroundFillGradient
    | backgroundFillFreeformGradient

  /** Describes a fill of a background */
  export type BackgroundFill$Input =
    | backgroundFillSolid$Input
    | backgroundFillGradient$Input
    | backgroundFillFreeformGradient$Input

  /** Describes the type of a background */
  export type BackgroundType =
    | backgroundTypeWallpaper
    | backgroundTypePattern
    | backgroundTypeFill

  /** Describes the type of a background */
  export type BackgroundType$Input =
    | backgroundTypeWallpaper$Input
    | backgroundTypePattern$Input
    | backgroundTypeFill$Input

  export type Background = background

  export type Backgrounds = backgrounds

  /** Contains information about background to set */
  export type InputBackground$Input =
    | inputBackgroundLocal$Input
    | inputBackgroundRemote$Input

  export type Hashtags = hashtags

  /**
   * Represents result of checking whether the current session can be used to transfer
   * a chat ownership to another user
   */
  export type CanTransferOwnershipResult =
    | canTransferOwnershipResultOk
    | canTransferOwnershipResultPasswordNeeded
    | canTransferOwnershipResultPasswordTooFresh
    | canTransferOwnershipResultSessionTooFresh

  /** Represents result of checking whether a username can be set for a chat */
  export type CheckChatUsernameResult =
    | checkChatUsernameResultOk
    | checkChatUsernameResultUsernameInvalid
    | checkChatUsernameResultUsernameOccupied
    | checkChatUsernameResultPublicChatsTooMuch
    | checkChatUsernameResultPublicGroupsUnavailable

  /** Represents result of checking whether a name can be used for a new sticker set */
  export type CheckStickerSetNameResult =
    | checkStickerSetNameResultOk
    | checkStickerSetNameResultNameInvalid
    | checkStickerSetNameResultNameOccupied

  /** Represents result of 2-step verification password reset */
  export type ResetPasswordResult =
    | resetPasswordResultOk
    | resetPasswordResultPending
    | resetPasswordResultDeclined

  /** Contains information about a file with messages exported from another app */
  export type MessageFileType =
    | messageFileTypePrivate
    | messageFileTypeGroup
    | messageFileTypeUnknown

  /** Contains content of a push message notification */
  export type PushMessageContent =
    | pushMessageContentHidden
    | pushMessageContentAnimation
    | pushMessageContentAudio
    | pushMessageContentContact
    | pushMessageContentContactRegistered
    | pushMessageContentDocument
    | pushMessageContentGame
    | pushMessageContentGameScore
    | pushMessageContentInvoice
    | pushMessageContentLocation
    | pushMessageContentPhoto
    | pushMessageContentPoll
    | pushMessageContentScreenshotTaken
    | pushMessageContentSticker
    | pushMessageContentText
    | pushMessageContentVideo
    | pushMessageContentVideoNote
    | pushMessageContentVoiceNote
    | pushMessageContentBasicGroupChatCreate
    | pushMessageContentChatAddMembers
    | pushMessageContentChatChangePhoto
    | pushMessageContentChatChangeTitle
    | pushMessageContentChatSetTheme
    | pushMessageContentChatDeleteMember
    | pushMessageContentChatJoinByLink
    | pushMessageContentChatJoinByRequest
    | pushMessageContentMessageForwards
    | pushMessageContentMediaAlbum

  /** Contains detailed information about a notification */
  export type NotificationType =
    | notificationTypeNewMessage
    | notificationTypeNewSecretChat
    | notificationTypeNewCall
    | notificationTypeNewPushMessage

  /** Describes the type of notifications in a notification group */
  export type NotificationGroupType =
    | notificationGroupTypeMessages
    | notificationGroupTypeMentions
    | notificationGroupTypeSecretChat
    | notificationGroupTypeCalls

  /** Represents the value of an option */
  export type OptionValue =
    | optionValueBoolean
    | optionValueEmpty
    | optionValueInteger
    | optionValueString

  /** Represents the value of an option */
  export type OptionValue$Input =
    | optionValueBoolean$Input
    | optionValueEmpty$Input
    | optionValueInteger$Input
    | optionValueString$Input

  /** Represents a JSON value */
  export type JsonValue =
    | jsonValueNull
    | jsonValueBoolean
    | jsonValueNumber
    | jsonValueString
    | jsonValueArray
    | jsonValueObject

  /** Represents a JSON value */
  export type JsonValue$Input =
    | jsonValueNull$Input
    | jsonValueBoolean$Input
    | jsonValueNumber$Input
    | jsonValueString$Input
    | jsonValueArray$Input
    | jsonValueObject$Input

  /** Represents a single rule for managing privacy settings */
  export type UserPrivacySettingRule =
    | userPrivacySettingRuleAllowAll
    | userPrivacySettingRuleAllowContacts
    | userPrivacySettingRuleAllowUsers
    | userPrivacySettingRuleAllowChatMembers
    | userPrivacySettingRuleRestrictAll
    | userPrivacySettingRuleRestrictContacts
    | userPrivacySettingRuleRestrictUsers
    | userPrivacySettingRuleRestrictChatMembers

  /** Represents a single rule for managing privacy settings */
  export type UserPrivacySettingRule$Input =
    | userPrivacySettingRuleAllowAll$Input
    | userPrivacySettingRuleAllowContacts$Input
    | userPrivacySettingRuleAllowUsers$Input
    | userPrivacySettingRuleAllowChatMembers$Input
    | userPrivacySettingRuleRestrictAll$Input
    | userPrivacySettingRuleRestrictContacts$Input
    | userPrivacySettingRuleRestrictUsers$Input
    | userPrivacySettingRuleRestrictChatMembers$Input

  export type UserPrivacySettingRules = userPrivacySettingRules

  /** Describes available user privacy settings */
  export type UserPrivacySetting =
    | userPrivacySettingShowStatus
    | userPrivacySettingShowProfilePhoto
    | userPrivacySettingShowLinkInForwardedMessages
    | userPrivacySettingShowPhoneNumber
    | userPrivacySettingAllowChatInvites
    | userPrivacySettingAllowCalls
    | userPrivacySettingAllowPeerToPeerCalls
    | userPrivacySettingAllowFindingByPhoneNumber

  /** Describes available user privacy settings */
  export type UserPrivacySetting$Input =
    | userPrivacySettingShowStatus$Input
    | userPrivacySettingShowProfilePhoto$Input
    | userPrivacySettingShowLinkInForwardedMessages$Input
    | userPrivacySettingShowPhoneNumber$Input
    | userPrivacySettingAllowChatInvites$Input
    | userPrivacySettingAllowCalls$Input
    | userPrivacySettingAllowPeerToPeerCalls$Input
    | userPrivacySettingAllowFindingByPhoneNumber$Input

  export type AccountTtl = accountTtl

  export type Session = session

  export type Sessions = sessions

  export type ConnectedWebsites = connectedWebsites

  /** Describes the reason why a chat is reported */
  export type ChatReportReason$Input =
    | chatReportReasonSpam$Input
    | chatReportReasonViolence$Input
    | chatReportReasonPornography$Input
    | chatReportReasonChildAbuse$Input
    | chatReportReasonCopyright$Input
    | chatReportReasonUnrelatedLocation$Input
    | chatReportReasonFake$Input
    | chatReportReasonCustom$Input

  /**
   * Describes an internal https://t.me or tg: link, which must be processed by the
   * app in a special way
   */
  export type InternalLinkType =
    | internalLinkTypeActiveSessions
    | internalLinkTypeAuthenticationCode
    | internalLinkTypeBackground
    | internalLinkTypeBotStart
    | internalLinkTypeBotStartInGroup
    | internalLinkTypeChangePhoneNumber
    | internalLinkTypeChatInvite
    | internalLinkTypeFilterSettings
    | internalLinkTypeGame
    | internalLinkTypeLanguagePack
    | internalLinkTypeMessage
    | internalLinkTypeMessageDraft
    | internalLinkTypePassportDataRequest
    | internalLinkTypePhoneNumberConfirmation
    | internalLinkTypeProxy
    | internalLinkTypePublicChat
    | internalLinkTypeQrCodeAuthentication
    | internalLinkTypeSettings
    | internalLinkTypeStickerSet
    | internalLinkTypeTheme
    | internalLinkTypeThemeSettings
    | internalLinkTypeUnknownDeepLink
    | internalLinkTypeUnsupportedProxy
    | internalLinkTypeVideoChat

  export type MessageLink = messageLink

  export type MessageLinkInfo = messageLinkInfo

  export type FilePart = filePart

  /** Represents the type of a file */
  export type FileType =
    | fileTypeNone
    | fileTypeAnimation
    | fileTypeAudio
    | fileTypeDocument
    | fileTypePhoto
    | fileTypeProfilePhoto
    | fileTypeSecret
    | fileTypeSecretThumbnail
    | fileTypeSecure
    | fileTypeSticker
    | fileTypeThumbnail
    | fileTypeUnknown
    | fileTypeVideo
    | fileTypeVideoNote
    | fileTypeVoiceNote
    | fileTypeWallpaper

  /** Represents the type of a file */
  export type FileType$Input =
    | fileTypeNone$Input
    | fileTypeAnimation$Input
    | fileTypeAudio$Input
    | fileTypeDocument$Input
    | fileTypePhoto$Input
    | fileTypeProfilePhoto$Input
    | fileTypeSecret$Input
    | fileTypeSecretThumbnail$Input
    | fileTypeSecure$Input
    | fileTypeSticker$Input
    | fileTypeThumbnail$Input
    | fileTypeUnknown$Input
    | fileTypeVideo$Input
    | fileTypeVideoNote$Input
    | fileTypeVoiceNote$Input
    | fileTypeWallpaper$Input

  export type StorageStatistics = storageStatistics

  export type StorageStatisticsFast = storageStatisticsFast

  export type DatabaseStatistics = databaseStatistics

  /** Represents the type of a network */
  export type NetworkType =
    | networkTypeNone
    | networkTypeMobile
    | networkTypeMobileRoaming
    | networkTypeWiFi
    | networkTypeOther

  /** Represents the type of a network */
  export type NetworkType$Input =
    | networkTypeNone$Input
    | networkTypeMobile$Input
    | networkTypeMobileRoaming$Input
    | networkTypeWiFi$Input
    | networkTypeOther$Input

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry =
    | networkStatisticsEntryFile
    | networkStatisticsEntryCall

  /** Contains statistics about network usage */
  export type NetworkStatisticsEntry$Input =
    | networkStatisticsEntryFile$Input
    | networkStatisticsEntryCall$Input

  export type NetworkStatistics = networkStatistics

  export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets

  /** Describes the current state of the connection to Telegram servers */
  export type ConnectionState =
    | connectionStateWaitingForNetwork
    | connectionStateConnectingToProxy
    | connectionStateConnecting
    | connectionStateUpdating
    | connectionStateReady

  /**
   * Represents the categories of chats for which a list of frequently used chats
   * can be retrieved
   */
  export type TopChatCategory$Input =
    | topChatCategoryUsers$Input
    | topChatCategoryBots$Input
    | topChatCategoryGroups$Input
    | topChatCategoryChannels$Input
    | topChatCategoryInlineBots$Input
    | topChatCategoryCalls$Input
    | topChatCategoryForwardChats$Input

  /** Describes the type of a URL linking to an internal Telegram entity */
  export type TMeUrlType =
    | tMeUrlTypeUser
    | tMeUrlTypeSupergroup
    | tMeUrlTypeChatInvite
    | tMeUrlTypeStickerSet

  export type TMeUrls = tMeUrls

  /** Describes an action suggested to the current user */
  export type SuggestedAction =
    | suggestedActionEnableArchiveAndMuteNewChats
    | suggestedActionCheckPassword
    | suggestedActionCheckPhoneNumber
    | suggestedActionViewChecksHint
    | suggestedActionConvertToBroadcastGroup
    | suggestedActionSetPassword

  /** Describes an action suggested to the current user */
  export type SuggestedAction$Input =
    | suggestedActionEnableArchiveAndMuteNewChats$Input
    | suggestedActionCheckPassword$Input
    | suggestedActionCheckPhoneNumber$Input
    | suggestedActionViewChecksHint$Input
    | suggestedActionConvertToBroadcastGroup$Input
    | suggestedActionSetPassword$Input

  export type Count = count

  export type Text = text

  export type Seconds = seconds

  export type DeepLinkInfo = deepLinkInfo

  /** Describes the way the text needs to be parsed for TextEntities */
  export type TextParseMode$Input =
    | textParseModeMarkdown$Input
    | textParseModeHTML$Input

  /** Describes the type of a proxy server */
  export type ProxyType =
    | proxyTypeSocks5
    | proxyTypeHttp
    | proxyTypeMtproto

  /** Describes the type of a proxy server */
  export type ProxyType$Input =
    | proxyTypeSocks5$Input
    | proxyTypeHttp$Input
    | proxyTypeMtproto$Input

  export type Proxy = proxy

  export type Proxies = proxies

  /** Describes a sticker that needs to be added to a sticker set */
  export type InputSticker$Input =
    | inputStickerStatic$Input
    | inputStickerAnimated$Input

  /** Describes a statistical graph */
  export type StatisticalGraph =
    | statisticalGraphData
    | statisticalGraphAsync
    | statisticalGraphError

  /** Contains a detailed statistics about a chat */
  export type ChatStatistics =
    | chatStatisticsSupergroup
    | chatStatisticsChannel

  export type MessageStatistics = messageStatistics

  /** Represents a vector path command */
  export type VectorPathCommand =
    | vectorPathCommandLine
    | vectorPathCommandCubicBezierCurve

  /** Represents the scope to which bot commands are relevant */
  export type BotCommandScope$Input =
    | botCommandScopeDefault$Input
    | botCommandScopeAllPrivateChats$Input
    | botCommandScopeAllGroupChats$Input
    | botCommandScopeAllChatAdministrators$Input
    | botCommandScopeChat$Input
    | botCommandScopeChatAdministrators$Input
    | botCommandScopeChatMember$Input

  /** Contains notifications about data changes */
  export type Update =
    | updateAuthorizationState
    | updateNewMessage
    | updateMessageSendAcknowledged
    | updateMessageSendSucceeded
    | updateMessageSendFailed
    | updateMessageContent
    | updateMessageEdited
    | updateMessageIsPinned
    | updateMessageInteractionInfo
    | updateMessageContentOpened
    | updateMessageMentionRead
    | updateMessageLiveLocationViewed
    | updateNewChat
    | updateChatTitle
    | updateChatPhoto
    | updateChatPermissions
    | updateChatLastMessage
    | updateChatPosition
    | updateChatReadInbox
    | updateChatReadOutbox
    | updateChatActionBar
    | updateChatDraftMessage
    | updateChatMessageSender
    | updateChatMessageTtl
    | updateChatNotificationSettings
    | updateChatPendingJoinRequests
    | updateChatReplyMarkup
    | updateChatTheme
    | updateChatUnreadMentionCount
    | updateChatVideoChat
    | updateChatDefaultDisableNotification
    | updateChatHasProtectedContent
    | updateChatHasScheduledMessages
    | updateChatIsBlocked
    | updateChatIsMarkedAsUnread
    | updateChatFilters
    | updateChatOnlineMemberCount
    | updateScopeNotificationSettings
    | updateNotification
    | updateNotificationGroup
    | updateActiveNotifications
    | updateHavePendingNotifications
    | updateDeleteMessages
    | updateChatAction
    | updateUserStatus
    | updateUser
    | updateBasicGroup
    | updateSupergroup
    | updateSecretChat
    | updateUserFullInfo
    | updateBasicGroupFullInfo
    | updateSupergroupFullInfo
    | updateServiceNotification
    | updateFile
    | updateFileGenerationStart
    | updateFileGenerationStop
    | updateCall
    | updateGroupCall
    | updateGroupCallParticipant
    | updateNewCallSignalingData
    | updateUserPrivacySettingRules
    | updateUnreadMessageCount
    | updateUnreadChatCount
    | updateOption
    | updateStickerSet
    | updateInstalledStickerSets
    | updateTrendingStickerSets
    | updateRecentStickers
    | updateFavoriteStickers
    | updateSavedAnimations
    | updateSelectedBackground
    | updateChatThemes
    | updateLanguagePackStrings
    | updateConnectionState
    | updateTermsOfService
    | updateUsersNearby
    | updateDiceEmojis
    | updateAnimatedEmojiMessageClicked
    | updateAnimationSearchParameters
    | updateSuggestedActions
    | updateNewInlineQuery
    | updateNewChosenInlineResult
    | updateNewCallbackQuery
    | updateNewInlineCallbackQuery
    | updateNewShippingQuery
    | updateNewPreCheckoutQuery
    | updateNewCustomEvent
    | updateNewCustomQuery
    | updatePoll
    | updatePollAnswer
    | updateChatMember
    | updateNewChatJoinRequest

  export type Updates = updates

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream =
    | logStreamDefault
    | logStreamFile
    | logStreamEmpty

  /** Describes a stream to which TDLib internal log is written */
  export type LogStream$Input =
    | logStreamDefault$Input
    | logStreamFile$Input
    | logStreamEmpty$Input

  export type LogVerbosityLevel = logVerbosityLevel

  export type LogTags = logTags

  export type TestInt = testInt

  export type TestString = testString

  export type TestBytes = testBytes

  export type TestVectorInt = testVectorInt

  export type TestVectorIntObject = testVectorIntObject

  export type TestVectorString = testVectorString

  export type TestVectorStringObject = testVectorStringObject

  // ----

  export type Invoke = <T>(query: { readonly _: T } & (
    getAuthorizationState
    | setTdlibParameters
    | checkDatabaseEncryptionKey
    | setAuthenticationPhoneNumber
    | resendAuthenticationCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageThread
    | getMessageViewers
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | searchChatsNearby
    | getTopChats
    | removeTopChat
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchCallMessages
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getActiveLiveLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatScheduledMessages
    | getMessagePublicForwards
    | getChatSponsoredMessage
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | resendMessages
    | sendChatScreenshotTakenNotification
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | hideSuggestedAction
    | getLoginUrlInfo
    | getLoginUrl
    | getInlineQueryResults
    | answerInlineQuery
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFilter
    | createChatFilter
    | editChatFilter
    | deleteChatFilter
    | reorderChatFilters
    | getRecommendedChatFilters
    | getChatFilterDefaultIconName
    | setChatTitle
    | setChatPhoto
    | setChatMessageTtl
    | setChatPermissions
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | uploadFile
    | cancelUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | editChatInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | getGroupCall
    | startScheduledGroupCall
    | toggleGroupCallEnabledStartNotification
    | joinGroupCall
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setGroupCallTitle
    | toggleGroupCallMuteNewParticipants
    | inviteGroupCallParticipants
    | getGroupCallInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getGroupCallStreamSegment
    | toggleMessageSenderIsBlocked
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickers
    | searchStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | searchHashtags
    | removeRecentHashtag
    | getWebPagePreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setName
    | setBio
    | setUsername
    | setLocation
    | changePhoneNumber
    | resendChangePhoneNumberCode
    | checkChangePhoneNumberCode
    | setCommands
    | deleteCommands
    | getCommands
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | setSupergroupStickerSet
    | toggleSupergroupSignMessages
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | getSupportUser
    | getBackgrounds
    | getBackgroundUrl
    | searchBackground
    | setBackground
    | removeBackground
    | resetBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | getChatStatistics
    | getMessageStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendPhoneNumberVerificationCode
    | resendPhoneNumberVerificationCode
    | checkPhoneNumberVerificationCode
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | sendPhoneNumberConfirmationCode
    | resendPhoneNumberConfirmationCode
    | checkPhoneNumberConfirmationCode
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | setStickerSetThumbnail
    | setStickerPositionInSet
    | removeStickerFromSet
    | getMapThumbnailFile
    | acceptTermsOfService
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getApplicationDownloadLink
    | getDeepLinkInfo
    | getApplicationConfig
    | saveApplicationLogEvent
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError
  )) => Promise<
    T extends 'getAuthorizationState' ? AuthorizationState :
    T extends 'setTdlibParameters' ? Ok :
    T extends 'checkDatabaseEncryptionKey' ? Ok :
    T extends 'setAuthenticationPhoneNumber' ? Ok :
    T extends 'resendAuthenticationCode' ? Ok :
    T extends 'checkAuthenticationCode' ? Ok :
    T extends 'requestQrCodeAuthentication' ? Ok :
    T extends 'registerUser' ? Ok :
    T extends 'checkAuthenticationPassword' ? Ok :
    T extends 'requestAuthenticationPasswordRecovery' ? Ok :
    T extends 'checkAuthenticationPasswordRecoveryCode' ? Ok :
    T extends 'recoverAuthenticationPassword' ? Ok :
    T extends 'checkAuthenticationBotToken' ? Ok :
    T extends 'logOut' ? Ok :
    T extends 'close' ? Ok :
    T extends 'destroy' ? Ok :
    T extends 'confirmQrCodeAuthentication' ? Session :
    T extends 'getCurrentState' ? Updates :
    T extends 'setDatabaseEncryptionKey' ? Ok :
    T extends 'getPasswordState' ? PasswordState :
    T extends 'setPassword' ? PasswordState :
    T extends 'getRecoveryEmailAddress' ? RecoveryEmailAddress :
    T extends 'setRecoveryEmailAddress' ? PasswordState :
    T extends 'checkRecoveryEmailAddressCode' ? PasswordState :
    T extends 'resendRecoveryEmailAddressCode' ? PasswordState :
    T extends 'requestPasswordRecovery' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkPasswordRecoveryCode' ? Ok :
    T extends 'recoverPassword' ? PasswordState :
    T extends 'resetPassword' ? ResetPasswordResult :
    T extends 'cancelPasswordReset' ? Ok :
    T extends 'createTemporaryPassword' ? TemporaryPasswordState :
    T extends 'getTemporaryPasswordState' ? TemporaryPasswordState :
    T extends 'getMe' ? User :
    T extends 'getUser' ? User :
    T extends 'getUserFullInfo' ? UserFullInfo :
    T extends 'getBasicGroup' ? BasicGroup :
    T extends 'getBasicGroupFullInfo' ? BasicGroupFullInfo :
    T extends 'getSupergroup' ? Supergroup :
    T extends 'getSupergroupFullInfo' ? SupergroupFullInfo :
    T extends 'getSecretChat' ? SecretChat :
    T extends 'getChat' ? Chat :
    T extends 'getMessage' ? Message :
    T extends 'getMessageLocally' ? Message :
    T extends 'getRepliedMessage' ? Message :
    T extends 'getChatPinnedMessage' ? Message :
    T extends 'getCallbackQueryMessage' ? Message :
    T extends 'getMessages' ? Messages :
    T extends 'getMessageThread' ? MessageThreadInfo :
    T extends 'getMessageViewers' ? Users :
    T extends 'getFile' ? File :
    T extends 'getRemoteFile' ? File :
    T extends 'loadChats' ? Ok :
    T extends 'getChats' ? Chats :
    T extends 'searchPublicChat' ? Chat :
    T extends 'searchPublicChats' ? Chats :
    T extends 'searchChats' ? Chats :
    T extends 'searchChatsOnServer' ? Chats :
    T extends 'searchChatsNearby' ? ChatsNearby :
    T extends 'getTopChats' ? Chats :
    T extends 'removeTopChat' ? Ok :
    T extends 'addRecentlyFoundChat' ? Ok :
    T extends 'removeRecentlyFoundChat' ? Ok :
    T extends 'clearRecentlyFoundChats' ? Ok :
    T extends 'getRecentlyOpenedChats' ? Chats :
    T extends 'checkChatUsername' ? CheckChatUsernameResult :
    T extends 'getCreatedPublicChats' ? Chats :
    T extends 'checkCreatedPublicChatsLimit' ? Ok :
    T extends 'getSuitableDiscussionChats' ? Chats :
    T extends 'getInactiveSupergroupChats' ? Chats :
    T extends 'getGroupsInCommon' ? Chats :
    T extends 'getChatHistory' ? Messages :
    T extends 'getMessageThreadHistory' ? Messages :
    T extends 'deleteChatHistory' ? Ok :
    T extends 'deleteChat' ? Ok :
    T extends 'searchChatMessages' ? Messages :
    T extends 'searchMessages' ? Messages :
    T extends 'searchSecretMessages' ? FoundMessages :
    T extends 'searchCallMessages' ? Messages :
    T extends 'deleteAllCallMessages' ? Ok :
    T extends 'searchChatRecentLocationMessages' ? Messages :
    T extends 'getActiveLiveLocationMessages' ? Messages :
    T extends 'getChatMessageByDate' ? Message :
    T extends 'getChatSparseMessagePositions' ? MessagePositions :
    T extends 'getChatMessageCalendar' ? MessageCalendar :
    T extends 'getChatMessageCount' ? Count :
    T extends 'getChatScheduledMessages' ? Messages :
    T extends 'getMessagePublicForwards' ? FoundMessages :
    T extends 'getChatSponsoredMessage' ? SponsoredMessage :
    T extends 'removeNotification' ? Ok :
    T extends 'removeNotificationGroup' ? Ok :
    T extends 'getMessageLink' ? MessageLink :
    T extends 'getMessageEmbeddingCode' ? Text :
    T extends 'getMessageLinkInfo' ? MessageLinkInfo :
    T extends 'getChatAvailableMessageSenders' ? MessageSenders :
    T extends 'setChatMessageSender' ? Ok :
    T extends 'sendMessage' ? Message :
    T extends 'sendMessageAlbum' ? Messages :
    T extends 'sendBotStartMessage' ? Message :
    T extends 'sendInlineQueryResultMessage' ? Message :
    T extends 'forwardMessages' ? Messages :
    T extends 'resendMessages' ? Messages :
    T extends 'sendChatScreenshotTakenNotification' ? Ok :
    T extends 'addLocalMessage' ? Message :
    T extends 'deleteMessages' ? Ok :
    T extends 'deleteChatMessagesBySender' ? Ok :
    T extends 'deleteChatMessagesByDate' ? Ok :
    T extends 'editMessageText' ? Message :
    T extends 'editMessageLiveLocation' ? Message :
    T extends 'editMessageMedia' ? Message :
    T extends 'editMessageCaption' ? Message :
    T extends 'editMessageReplyMarkup' ? Message :
    T extends 'editInlineMessageText' ? Ok :
    T extends 'editInlineMessageLiveLocation' ? Ok :
    T extends 'editInlineMessageMedia' ? Ok :
    T extends 'editInlineMessageCaption' ? Ok :
    T extends 'editInlineMessageReplyMarkup' ? Ok :
    T extends 'editMessageSchedulingState' ? Ok :
    T extends 'getTextEntities' ? TextEntities :
    T extends 'parseTextEntities' ? FormattedText :
    T extends 'parseMarkdown' ? FormattedText :
    T extends 'getMarkdownText' ? FormattedText :
    T extends 'getFileMimeType' ? Text :
    T extends 'getFileExtension' ? Text :
    T extends 'cleanFileName' ? Text :
    T extends 'getLanguagePackString' ? LanguagePackStringValue :
    T extends 'getJsonValue' ? JsonValue :
    T extends 'getJsonString' ? Text :
    T extends 'setPollAnswer' ? Ok :
    T extends 'getPollVoters' ? Users :
    T extends 'stopPoll' ? Ok :
    T extends 'hideSuggestedAction' ? Ok :
    T extends 'getLoginUrlInfo' ? LoginUrlInfo :
    T extends 'getLoginUrl' ? HttpUrl :
    T extends 'getInlineQueryResults' ? InlineQueryResults :
    T extends 'answerInlineQuery' ? Ok :
    T extends 'getCallbackQueryAnswer' ? CallbackQueryAnswer :
    T extends 'answerCallbackQuery' ? Ok :
    T extends 'answerShippingQuery' ? Ok :
    T extends 'answerPreCheckoutQuery' ? Ok :
    T extends 'setGameScore' ? Message :
    T extends 'setInlineGameScore' ? Ok :
    T extends 'getGameHighScores' ? GameHighScores :
    T extends 'getInlineGameHighScores' ? GameHighScores :
    T extends 'deleteChatReplyMarkup' ? Ok :
    T extends 'sendChatAction' ? Ok :
    T extends 'openChat' ? Ok :
    T extends 'closeChat' ? Ok :
    T extends 'viewMessages' ? Ok :
    T extends 'openMessageContent' ? Ok :
    T extends 'clickAnimatedEmojiMessage' ? Sticker :
    T extends 'getInternalLinkType' ? InternalLinkType :
    T extends 'getExternalLinkInfo' ? LoginUrlInfo :
    T extends 'getExternalLink' ? HttpUrl :
    T extends 'readAllChatMentions' ? Ok :
    T extends 'createPrivateChat' ? Chat :
    T extends 'createBasicGroupChat' ? Chat :
    T extends 'createSupergroupChat' ? Chat :
    T extends 'createSecretChat' ? Chat :
    T extends 'createNewBasicGroupChat' ? Chat :
    T extends 'createNewSupergroupChat' ? Chat :
    T extends 'createNewSecretChat' ? Chat :
    T extends 'upgradeBasicGroupChatToSupergroupChat' ? Chat :
    T extends 'getChatListsToAddChat' ? ChatLists :
    T extends 'addChatToList' ? Ok :
    T extends 'getChatFilter' ? ChatFilter :
    T extends 'createChatFilter' ? ChatFilterInfo :
    T extends 'editChatFilter' ? ChatFilterInfo :
    T extends 'deleteChatFilter' ? Ok :
    T extends 'reorderChatFilters' ? Ok :
    T extends 'getRecommendedChatFilters' ? RecommendedChatFilters :
    T extends 'getChatFilterDefaultIconName' ? Text :
    T extends 'setChatTitle' ? Ok :
    T extends 'setChatPhoto' ? Ok :
    T extends 'setChatMessageTtl' ? Ok :
    T extends 'setChatPermissions' ? Ok :
    T extends 'setChatTheme' ? Ok :
    T extends 'setChatDraftMessage' ? Ok :
    T extends 'setChatNotificationSettings' ? Ok :
    T extends 'toggleChatHasProtectedContent' ? Ok :
    T extends 'toggleChatIsMarkedAsUnread' ? Ok :
    T extends 'toggleChatDefaultDisableNotification' ? Ok :
    T extends 'setChatClientData' ? Ok :
    T extends 'setChatDescription' ? Ok :
    T extends 'setChatDiscussionGroup' ? Ok :
    T extends 'setChatLocation' ? Ok :
    T extends 'setChatSlowModeDelay' ? Ok :
    T extends 'pinChatMessage' ? Ok :
    T extends 'unpinChatMessage' ? Ok :
    T extends 'unpinAllChatMessages' ? Ok :
    T extends 'joinChat' ? Ok :
    T extends 'leaveChat' ? Ok :
    T extends 'addChatMember' ? Ok :
    T extends 'addChatMembers' ? Ok :
    T extends 'setChatMemberStatus' ? Ok :
    T extends 'banChatMember' ? Ok :
    T extends 'canTransferOwnership' ? CanTransferOwnershipResult :
    T extends 'transferChatOwnership' ? Ok :
    T extends 'getChatMember' ? ChatMember :
    T extends 'searchChatMembers' ? ChatMembers :
    T extends 'getChatAdministrators' ? ChatAdministrators :
    T extends 'clearAllDraftMessages' ? Ok :
    T extends 'getChatNotificationSettingsExceptions' ? Chats :
    T extends 'getScopeNotificationSettings' ? ScopeNotificationSettings :
    T extends 'setScopeNotificationSettings' ? Ok :
    T extends 'resetAllNotificationSettings' ? Ok :
    T extends 'toggleChatIsPinned' ? Ok :
    T extends 'setPinnedChats' ? Ok :
    T extends 'downloadFile' ? File :
    T extends 'getFileDownloadedPrefixSize' ? Count :
    T extends 'cancelDownloadFile' ? Ok :
    T extends 'getSuggestedFileName' ? Text :
    T extends 'uploadFile' ? File :
    T extends 'cancelUploadFile' ? Ok :
    T extends 'writeGeneratedFilePart' ? Ok :
    T extends 'setFileGenerationProgress' ? Ok :
    T extends 'finishFileGeneration' ? Ok :
    T extends 'readFilePart' ? FilePart :
    T extends 'deleteFile' ? Ok :
    T extends 'getMessageFileType' ? MessageFileType :
    T extends 'getMessageImportConfirmationText' ? Text :
    T extends 'importMessages' ? Ok :
    T extends 'replacePrimaryChatInviteLink' ? ChatInviteLink :
    T extends 'createChatInviteLink' ? ChatInviteLink :
    T extends 'editChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLinkCounts' ? ChatInviteLinkCounts :
    T extends 'getChatInviteLinks' ? ChatInviteLinks :
    T extends 'getChatInviteLinkMembers' ? ChatInviteLinkMembers :
    T extends 'revokeChatInviteLink' ? ChatInviteLinks :
    T extends 'deleteRevokedChatInviteLink' ? Ok :
    T extends 'deleteAllRevokedChatInviteLinks' ? Ok :
    T extends 'checkChatInviteLink' ? ChatInviteLinkInfo :
    T extends 'joinChatByInviteLink' ? Chat :
    T extends 'getChatJoinRequests' ? ChatJoinRequests :
    T extends 'processChatJoinRequest' ? Ok :
    T extends 'processChatJoinRequests' ? Ok :
    T extends 'createCall' ? CallId :
    T extends 'acceptCall' ? Ok :
    T extends 'sendCallSignalingData' ? Ok :
    T extends 'discardCall' ? Ok :
    T extends 'sendCallRating' ? Ok :
    T extends 'sendCallDebugInformation' ? Ok :
    T extends 'getVideoChatAvailableParticipants' ? MessageSenders :
    T extends 'setVideoChatDefaultParticipant' ? Ok :
    T extends 'createVideoChat' ? GroupCallId :
    T extends 'getGroupCall' ? GroupCall :
    T extends 'startScheduledGroupCall' ? Ok :
    T extends 'toggleGroupCallEnabledStartNotification' ? Ok :
    T extends 'joinGroupCall' ? Text :
    T extends 'startGroupCallScreenSharing' ? Text :
    T extends 'toggleGroupCallScreenSharingIsPaused' ? Ok :
    T extends 'endGroupCallScreenSharing' ? Ok :
    T extends 'setGroupCallTitle' ? Ok :
    T extends 'toggleGroupCallMuteNewParticipants' ? Ok :
    T extends 'inviteGroupCallParticipants' ? Ok :
    T extends 'getGroupCallInviteLink' ? HttpUrl :
    T extends 'revokeGroupCallInviteLink' ? Ok :
    T extends 'startGroupCallRecording' ? Ok :
    T extends 'endGroupCallRecording' ? Ok :
    T extends 'toggleGroupCallIsMyVideoPaused' ? Ok :
    T extends 'toggleGroupCallIsMyVideoEnabled' ? Ok :
    T extends 'setGroupCallParticipantIsSpeaking' ? Ok :
    T extends 'toggleGroupCallParticipantIsMuted' ? Ok :
    T extends 'setGroupCallParticipantVolumeLevel' ? Ok :
    T extends 'toggleGroupCallParticipantIsHandRaised' ? Ok :
    T extends 'loadGroupCallParticipants' ? Ok :
    T extends 'leaveGroupCall' ? Ok :
    T extends 'endGroupCall' ? Ok :
    T extends 'getGroupCallStreamSegment' ? FilePart :
    T extends 'toggleMessageSenderIsBlocked' ? Ok :
    T extends 'blockMessageSenderFromReplies' ? Ok :
    T extends 'getBlockedMessageSenders' ? MessageSenders :
    T extends 'addContact' ? Ok :
    T extends 'importContacts' ? ImportedContacts :
    T extends 'getContacts' ? Users :
    T extends 'searchContacts' ? Users :
    T extends 'removeContacts' ? Ok :
    T extends 'getImportedContactCount' ? Count :
    T extends 'changeImportedContacts' ? ImportedContacts :
    T extends 'clearImportedContacts' ? Ok :
    T extends 'sharePhoneNumber' ? Ok :
    T extends 'getUserProfilePhotos' ? ChatPhotos :
    T extends 'getStickers' ? Stickers :
    T extends 'searchStickers' ? Stickers :
    T extends 'getInstalledStickerSets' ? StickerSets :
    T extends 'getArchivedStickerSets' ? StickerSets :
    T extends 'getTrendingStickerSets' ? StickerSets :
    T extends 'getAttachedStickerSets' ? StickerSets :
    T extends 'getStickerSet' ? StickerSet :
    T extends 'searchStickerSet' ? StickerSet :
    T extends 'searchInstalledStickerSets' ? StickerSets :
    T extends 'searchStickerSets' ? StickerSets :
    T extends 'changeStickerSet' ? Ok :
    T extends 'viewTrendingStickerSets' ? Ok :
    T extends 'reorderInstalledStickerSets' ? Ok :
    T extends 'getRecentStickers' ? Stickers :
    T extends 'addRecentSticker' ? Stickers :
    T extends 'removeRecentSticker' ? Ok :
    T extends 'clearRecentStickers' ? Ok :
    T extends 'getFavoriteStickers' ? Stickers :
    T extends 'addFavoriteSticker' ? Ok :
    T extends 'removeFavoriteSticker' ? Ok :
    T extends 'getStickerEmojis' ? Emojis :
    T extends 'searchEmojis' ? Emojis :
    T extends 'getAnimatedEmoji' ? AnimatedEmoji :
    T extends 'getEmojiSuggestionsUrl' ? HttpUrl :
    T extends 'getSavedAnimations' ? Animations :
    T extends 'addSavedAnimation' ? Ok :
    T extends 'removeSavedAnimation' ? Ok :
    T extends 'getRecentInlineBots' ? Users :
    T extends 'searchHashtags' ? Hashtags :
    T extends 'removeRecentHashtag' ? Ok :
    T extends 'getWebPagePreview' ? WebPage :
    T extends 'getWebPageInstantView' ? WebPageInstantView :
    T extends 'setProfilePhoto' ? Ok :
    T extends 'deleteProfilePhoto' ? Ok :
    T extends 'setName' ? Ok :
    T extends 'setBio' ? Ok :
    T extends 'setUsername' ? Ok :
    T extends 'setLocation' ? Ok :
    T extends 'changePhoneNumber' ? AuthenticationCodeInfo :
    T extends 'resendChangePhoneNumberCode' ? AuthenticationCodeInfo :
    T extends 'checkChangePhoneNumberCode' ? Ok :
    T extends 'setCommands' ? Ok :
    T extends 'deleteCommands' ? Ok :
    T extends 'getCommands' ? BotCommands :
    T extends 'getActiveSessions' ? Sessions :
    T extends 'terminateSession' ? Ok :
    T extends 'terminateAllOtherSessions' ? Ok :
    T extends 'toggleSessionCanAcceptCalls' ? Ok :
    T extends 'toggleSessionCanAcceptSecretChats' ? Ok :
    T extends 'setInactiveSessionTtl' ? Ok :
    T extends 'getConnectedWebsites' ? ConnectedWebsites :
    T extends 'disconnectWebsite' ? Ok :
    T extends 'disconnectAllWebsites' ? Ok :
    T extends 'setSupergroupUsername' ? Ok :
    T extends 'setSupergroupStickerSet' ? Ok :
    T extends 'toggleSupergroupSignMessages' ? Ok :
    T extends 'toggleSupergroupIsAllHistoryAvailable' ? Ok :
    T extends 'toggleSupergroupIsBroadcastGroup' ? Ok :
    T extends 'reportSupergroupSpam' ? Ok :
    T extends 'getSupergroupMembers' ? ChatMembers :
    T extends 'closeSecretChat' ? Ok :
    T extends 'getChatEventLog' ? ChatEvents :
    T extends 'getPaymentForm' ? PaymentForm :
    T extends 'validateOrderInfo' ? ValidatedOrderInfo :
    T extends 'sendPaymentForm' ? PaymentResult :
    T extends 'getPaymentReceipt' ? PaymentReceipt :
    T extends 'getSavedOrderInfo' ? OrderInfo :
    T extends 'deleteSavedOrderInfo' ? Ok :
    T extends 'deleteSavedCredentials' ? Ok :
    T extends 'getSupportUser' ? User :
    T extends 'getBackgrounds' ? Backgrounds :
    T extends 'getBackgroundUrl' ? HttpUrl :
    T extends 'searchBackground' ? Background :
    T extends 'setBackground' ? Background :
    T extends 'removeBackground' ? Ok :
    T extends 'resetBackgrounds' ? Ok :
    T extends 'getLocalizationTargetInfo' ? LocalizationTargetInfo :
    T extends 'getLanguagePackInfo' ? LanguagePackInfo :
    T extends 'getLanguagePackStrings' ? LanguagePackStrings :
    T extends 'synchronizeLanguagePack' ? Ok :
    T extends 'addCustomServerLanguagePack' ? Ok :
    T extends 'setCustomLanguagePack' ? Ok :
    T extends 'editCustomLanguagePackInfo' ? Ok :
    T extends 'setCustomLanguagePackString' ? Ok :
    T extends 'deleteLanguagePack' ? Ok :
    T extends 'registerDevice' ? PushReceiverId :
    T extends 'processPushNotification' ? Ok :
    T extends 'getPushReceiverId' ? PushReceiverId :
    T extends 'getRecentlyVisitedTMeUrls' ? TMeUrls :
    T extends 'setUserPrivacySettingRules' ? Ok :
    T extends 'getUserPrivacySettingRules' ? UserPrivacySettingRules :
    T extends 'getOption' ? OptionValue :
    T extends 'setOption' ? Ok :
    T extends 'setAccountTtl' ? Ok :
    T extends 'getAccountTtl' ? AccountTtl :
    T extends 'deleteAccount' ? Ok :
    T extends 'removeChatActionBar' ? Ok :
    T extends 'reportChat' ? Ok :
    T extends 'reportChatPhoto' ? Ok :
    T extends 'getChatStatistics' ? ChatStatistics :
    T extends 'getMessageStatistics' ? MessageStatistics :
    T extends 'getStatisticalGraph' ? StatisticalGraph :
    T extends 'getStorageStatistics' ? StorageStatistics :
    T extends 'getStorageStatisticsFast' ? StorageStatisticsFast :
    T extends 'getDatabaseStatistics' ? DatabaseStatistics :
    T extends 'optimizeStorage' ? StorageStatistics :
    T extends 'setNetworkType' ? Ok :
    T extends 'getNetworkStatistics' ? NetworkStatistics :
    T extends 'addNetworkStatistics' ? Ok :
    T extends 'resetNetworkStatistics' ? Ok :
    T extends 'getAutoDownloadSettingsPresets' ? AutoDownloadSettingsPresets :
    T extends 'setAutoDownloadSettings' ? Ok :
    T extends 'getBankCardInfo' ? BankCardInfo :
    T extends 'getPassportElement' ? PassportElement :
    T extends 'getAllPassportElements' ? PassportElements :
    T extends 'setPassportElement' ? PassportElement :
    T extends 'deletePassportElement' ? Ok :
    T extends 'setPassportElementErrors' ? Ok :
    T extends 'getPreferredCountryLanguage' ? Text :
    T extends 'sendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberVerificationCode' ? Ok :
    T extends 'sendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkEmailAddressVerificationCode' ? Ok :
    T extends 'getPassportAuthorizationForm' ? PassportAuthorizationForm :
    T extends 'getPassportAuthorizationFormAvailableElements' ? PassportElementsWithErrors :
    T extends 'sendPassportAuthorizationForm' ? Ok :
    T extends 'sendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberConfirmationCode' ? Ok :
    T extends 'setBotUpdatesStatus' ? Ok :
    T extends 'uploadStickerFile' ? File :
    T extends 'getSuggestedStickerSetName' ? Text :
    T extends 'checkStickerSetName' ? CheckStickerSetNameResult :
    T extends 'createNewStickerSet' ? StickerSet :
    T extends 'addStickerToSet' ? StickerSet :
    T extends 'setStickerSetThumbnail' ? StickerSet :
    T extends 'setStickerPositionInSet' ? Ok :
    T extends 'removeStickerFromSet' ? Ok :
    T extends 'getMapThumbnailFile' ? File :
    T extends 'acceptTermsOfService' ? Ok :
    T extends 'sendCustomRequest' ? CustomRequestResult :
    T extends 'answerCustomQuery' ? Ok :
    T extends 'setAlarm' ? Ok :
    T extends 'getCountries' ? Countries :
    T extends 'getCountryCode' ? Text :
    T extends 'getPhoneNumberInfo' ? PhoneNumberInfo :
    T extends 'getPhoneNumberInfoSync' ? PhoneNumberInfo :
    T extends 'getApplicationDownloadLink' ? HttpUrl :
    T extends 'getDeepLinkInfo' ? DeepLinkInfo :
    T extends 'getApplicationConfig' ? JsonValue :
    T extends 'saveApplicationLogEvent' ? Ok :
    T extends 'addProxy' ? Proxy :
    T extends 'editProxy' ? Proxy :
    T extends 'enableProxy' ? Ok :
    T extends 'disableProxy' ? Ok :
    T extends 'removeProxy' ? Ok :
    T extends 'getProxies' ? Proxies :
    T extends 'getProxyLink' ? HttpUrl :
    T extends 'pingProxy' ? Seconds :
    T extends 'setLogStream' ? Ok :
    T extends 'getLogStream' ? LogStream :
    T extends 'setLogVerbosityLevel' ? Ok :
    T extends 'getLogVerbosityLevel' ? LogVerbosityLevel :
    T extends 'getLogTags' ? LogTags :
    T extends 'setLogTagVerbosityLevel' ? Ok :
    T extends 'getLogTagVerbosityLevel' ? LogVerbosityLevel :
    T extends 'addLogMessage' ? Ok :
    T extends 'testCallEmpty' ? Ok :
    T extends 'testCallString' ? TestString :
    T extends 'testCallBytes' ? TestBytes :
    T extends 'testCallVectorInt' ? TestVectorInt :
    T extends 'testCallVectorIntObject' ? TestVectorIntObject :
    T extends 'testCallVectorString' ? TestVectorString :
    T extends 'testCallVectorStringObject' ? TestVectorStringObject :
    T extends 'testSquareInt' ? TestInt :
    T extends 'testNetwork' ? Ok :
    T extends 'testProxy' ? Ok :
    T extends 'testGetDifference' ? Ok :
    T extends 'testUseUpdate' ? Update :
    T extends 'testReturnError' ? Error :
  never>

  export type Execute = <T>(query: { readonly _: T } & (
    getAuthorizationState
    | setTdlibParameters
    | checkDatabaseEncryptionKey
    | setAuthenticationPhoneNumber
    | resendAuthenticationCode
    | checkAuthenticationCode
    | requestQrCodeAuthentication
    | registerUser
    | checkAuthenticationPassword
    | requestAuthenticationPasswordRecovery
    | checkAuthenticationPasswordRecoveryCode
    | recoverAuthenticationPassword
    | checkAuthenticationBotToken
    | logOut
    | close
    | destroy
    | confirmQrCodeAuthentication
    | getCurrentState
    | setDatabaseEncryptionKey
    | getPasswordState
    | setPassword
    | getRecoveryEmailAddress
    | setRecoveryEmailAddress
    | checkRecoveryEmailAddressCode
    | resendRecoveryEmailAddressCode
    | requestPasswordRecovery
    | checkPasswordRecoveryCode
    | recoverPassword
    | resetPassword
    | cancelPasswordReset
    | createTemporaryPassword
    | getTemporaryPasswordState
    | getMe
    | getUser
    | getUserFullInfo
    | getBasicGroup
    | getBasicGroupFullInfo
    | getSupergroup
    | getSupergroupFullInfo
    | getSecretChat
    | getChat
    | getMessage
    | getMessageLocally
    | getRepliedMessage
    | getChatPinnedMessage
    | getCallbackQueryMessage
    | getMessages
    | getMessageThread
    | getMessageViewers
    | getFile
    | getRemoteFile
    | loadChats
    | getChats
    | searchPublicChat
    | searchPublicChats
    | searchChats
    | searchChatsOnServer
    | searchChatsNearby
    | getTopChats
    | removeTopChat
    | addRecentlyFoundChat
    | removeRecentlyFoundChat
    | clearRecentlyFoundChats
    | getRecentlyOpenedChats
    | checkChatUsername
    | getCreatedPublicChats
    | checkCreatedPublicChatsLimit
    | getSuitableDiscussionChats
    | getInactiveSupergroupChats
    | getGroupsInCommon
    | getChatHistory
    | getMessageThreadHistory
    | deleteChatHistory
    | deleteChat
    | searchChatMessages
    | searchMessages
    | searchSecretMessages
    | searchCallMessages
    | deleteAllCallMessages
    | searchChatRecentLocationMessages
    | getActiveLiveLocationMessages
    | getChatMessageByDate
    | getChatSparseMessagePositions
    | getChatMessageCalendar
    | getChatMessageCount
    | getChatScheduledMessages
    | getMessagePublicForwards
    | getChatSponsoredMessage
    | removeNotification
    | removeNotificationGroup
    | getMessageLink
    | getMessageEmbeddingCode
    | getMessageLinkInfo
    | getChatAvailableMessageSenders
    | setChatMessageSender
    | sendMessage
    | sendMessageAlbum
    | sendBotStartMessage
    | sendInlineQueryResultMessage
    | forwardMessages
    | resendMessages
    | sendChatScreenshotTakenNotification
    | addLocalMessage
    | deleteMessages
    | deleteChatMessagesBySender
    | deleteChatMessagesByDate
    | editMessageText
    | editMessageLiveLocation
    | editMessageMedia
    | editMessageCaption
    | editMessageReplyMarkup
    | editInlineMessageText
    | editInlineMessageLiveLocation
    | editInlineMessageMedia
    | editInlineMessageCaption
    | editInlineMessageReplyMarkup
    | editMessageSchedulingState
    | getTextEntities
    | parseTextEntities
    | parseMarkdown
    | getMarkdownText
    | getFileMimeType
    | getFileExtension
    | cleanFileName
    | getLanguagePackString
    | getJsonValue
    | getJsonString
    | setPollAnswer
    | getPollVoters
    | stopPoll
    | hideSuggestedAction
    | getLoginUrlInfo
    | getLoginUrl
    | getInlineQueryResults
    | answerInlineQuery
    | getCallbackQueryAnswer
    | answerCallbackQuery
    | answerShippingQuery
    | answerPreCheckoutQuery
    | setGameScore
    | setInlineGameScore
    | getGameHighScores
    | getInlineGameHighScores
    | deleteChatReplyMarkup
    | sendChatAction
    | openChat
    | closeChat
    | viewMessages
    | openMessageContent
    | clickAnimatedEmojiMessage
    | getInternalLinkType
    | getExternalLinkInfo
    | getExternalLink
    | readAllChatMentions
    | createPrivateChat
    | createBasicGroupChat
    | createSupergroupChat
    | createSecretChat
    | createNewBasicGroupChat
    | createNewSupergroupChat
    | createNewSecretChat
    | upgradeBasicGroupChatToSupergroupChat
    | getChatListsToAddChat
    | addChatToList
    | getChatFilter
    | createChatFilter
    | editChatFilter
    | deleteChatFilter
    | reorderChatFilters
    | getRecommendedChatFilters
    | getChatFilterDefaultIconName
    | setChatTitle
    | setChatPhoto
    | setChatMessageTtl
    | setChatPermissions
    | setChatTheme
    | setChatDraftMessage
    | setChatNotificationSettings
    | toggleChatHasProtectedContent
    | toggleChatIsMarkedAsUnread
    | toggleChatDefaultDisableNotification
    | setChatClientData
    | setChatDescription
    | setChatDiscussionGroup
    | setChatLocation
    | setChatSlowModeDelay
    | pinChatMessage
    | unpinChatMessage
    | unpinAllChatMessages
    | joinChat
    | leaveChat
    | addChatMember
    | addChatMembers
    | setChatMemberStatus
    | banChatMember
    | canTransferOwnership
    | transferChatOwnership
    | getChatMember
    | searchChatMembers
    | getChatAdministrators
    | clearAllDraftMessages
    | getChatNotificationSettingsExceptions
    | getScopeNotificationSettings
    | setScopeNotificationSettings
    | resetAllNotificationSettings
    | toggleChatIsPinned
    | setPinnedChats
    | downloadFile
    | getFileDownloadedPrefixSize
    | cancelDownloadFile
    | getSuggestedFileName
    | uploadFile
    | cancelUploadFile
    | writeGeneratedFilePart
    | setFileGenerationProgress
    | finishFileGeneration
    | readFilePart
    | deleteFile
    | getMessageFileType
    | getMessageImportConfirmationText
    | importMessages
    | replacePrimaryChatInviteLink
    | createChatInviteLink
    | editChatInviteLink
    | getChatInviteLink
    | getChatInviteLinkCounts
    | getChatInviteLinks
    | getChatInviteLinkMembers
    | revokeChatInviteLink
    | deleteRevokedChatInviteLink
    | deleteAllRevokedChatInviteLinks
    | checkChatInviteLink
    | joinChatByInviteLink
    | getChatJoinRequests
    | processChatJoinRequest
    | processChatJoinRequests
    | createCall
    | acceptCall
    | sendCallSignalingData
    | discardCall
    | sendCallRating
    | sendCallDebugInformation
    | getVideoChatAvailableParticipants
    | setVideoChatDefaultParticipant
    | createVideoChat
    | getGroupCall
    | startScheduledGroupCall
    | toggleGroupCallEnabledStartNotification
    | joinGroupCall
    | startGroupCallScreenSharing
    | toggleGroupCallScreenSharingIsPaused
    | endGroupCallScreenSharing
    | setGroupCallTitle
    | toggleGroupCallMuteNewParticipants
    | inviteGroupCallParticipants
    | getGroupCallInviteLink
    | revokeGroupCallInviteLink
    | startGroupCallRecording
    | endGroupCallRecording
    | toggleGroupCallIsMyVideoPaused
    | toggleGroupCallIsMyVideoEnabled
    | setGroupCallParticipantIsSpeaking
    | toggleGroupCallParticipantIsMuted
    | setGroupCallParticipantVolumeLevel
    | toggleGroupCallParticipantIsHandRaised
    | loadGroupCallParticipants
    | leaveGroupCall
    | endGroupCall
    | getGroupCallStreamSegment
    | toggleMessageSenderIsBlocked
    | blockMessageSenderFromReplies
    | getBlockedMessageSenders
    | addContact
    | importContacts
    | getContacts
    | searchContacts
    | removeContacts
    | getImportedContactCount
    | changeImportedContacts
    | clearImportedContacts
    | sharePhoneNumber
    | getUserProfilePhotos
    | getStickers
    | searchStickers
    | getInstalledStickerSets
    | getArchivedStickerSets
    | getTrendingStickerSets
    | getAttachedStickerSets
    | getStickerSet
    | searchStickerSet
    | searchInstalledStickerSets
    | searchStickerSets
    | changeStickerSet
    | viewTrendingStickerSets
    | reorderInstalledStickerSets
    | getRecentStickers
    | addRecentSticker
    | removeRecentSticker
    | clearRecentStickers
    | getFavoriteStickers
    | addFavoriteSticker
    | removeFavoriteSticker
    | getStickerEmojis
    | searchEmojis
    | getAnimatedEmoji
    | getEmojiSuggestionsUrl
    | getSavedAnimations
    | addSavedAnimation
    | removeSavedAnimation
    | getRecentInlineBots
    | searchHashtags
    | removeRecentHashtag
    | getWebPagePreview
    | getWebPageInstantView
    | setProfilePhoto
    | deleteProfilePhoto
    | setName
    | setBio
    | setUsername
    | setLocation
    | changePhoneNumber
    | resendChangePhoneNumberCode
    | checkChangePhoneNumberCode
    | setCommands
    | deleteCommands
    | getCommands
    | getActiveSessions
    | terminateSession
    | terminateAllOtherSessions
    | toggleSessionCanAcceptCalls
    | toggleSessionCanAcceptSecretChats
    | setInactiveSessionTtl
    | getConnectedWebsites
    | disconnectWebsite
    | disconnectAllWebsites
    | setSupergroupUsername
    | setSupergroupStickerSet
    | toggleSupergroupSignMessages
    | toggleSupergroupIsAllHistoryAvailable
    | toggleSupergroupIsBroadcastGroup
    | reportSupergroupSpam
    | getSupergroupMembers
    | closeSecretChat
    | getChatEventLog
    | getPaymentForm
    | validateOrderInfo
    | sendPaymentForm
    | getPaymentReceipt
    | getSavedOrderInfo
    | deleteSavedOrderInfo
    | deleteSavedCredentials
    | getSupportUser
    | getBackgrounds
    | getBackgroundUrl
    | searchBackground
    | setBackground
    | removeBackground
    | resetBackgrounds
    | getLocalizationTargetInfo
    | getLanguagePackInfo
    | getLanguagePackStrings
    | synchronizeLanguagePack
    | addCustomServerLanguagePack
    | setCustomLanguagePack
    | editCustomLanguagePackInfo
    | setCustomLanguagePackString
    | deleteLanguagePack
    | registerDevice
    | processPushNotification
    | getPushReceiverId
    | getRecentlyVisitedTMeUrls
    | setUserPrivacySettingRules
    | getUserPrivacySettingRules
    | getOption
    | setOption
    | setAccountTtl
    | getAccountTtl
    | deleteAccount
    | removeChatActionBar
    | reportChat
    | reportChatPhoto
    | getChatStatistics
    | getMessageStatistics
    | getStatisticalGraph
    | getStorageStatistics
    | getStorageStatisticsFast
    | getDatabaseStatistics
    | optimizeStorage
    | setNetworkType
    | getNetworkStatistics
    | addNetworkStatistics
    | resetNetworkStatistics
    | getAutoDownloadSettingsPresets
    | setAutoDownloadSettings
    | getBankCardInfo
    | getPassportElement
    | getAllPassportElements
    | setPassportElement
    | deletePassportElement
    | setPassportElementErrors
    | getPreferredCountryLanguage
    | sendPhoneNumberVerificationCode
    | resendPhoneNumberVerificationCode
    | checkPhoneNumberVerificationCode
    | sendEmailAddressVerificationCode
    | resendEmailAddressVerificationCode
    | checkEmailAddressVerificationCode
    | getPassportAuthorizationForm
    | getPassportAuthorizationFormAvailableElements
    | sendPassportAuthorizationForm
    | sendPhoneNumberConfirmationCode
    | resendPhoneNumberConfirmationCode
    | checkPhoneNumberConfirmationCode
    | setBotUpdatesStatus
    | uploadStickerFile
    | getSuggestedStickerSetName
    | checkStickerSetName
    | createNewStickerSet
    | addStickerToSet
    | setStickerSetThumbnail
    | setStickerPositionInSet
    | removeStickerFromSet
    | getMapThumbnailFile
    | acceptTermsOfService
    | sendCustomRequest
    | answerCustomQuery
    | setAlarm
    | getCountries
    | getCountryCode
    | getPhoneNumberInfo
    | getPhoneNumberInfoSync
    | getApplicationDownloadLink
    | getDeepLinkInfo
    | getApplicationConfig
    | saveApplicationLogEvent
    | addProxy
    | editProxy
    | enableProxy
    | disableProxy
    | removeProxy
    | getProxies
    | getProxyLink
    | pingProxy
    | setLogStream
    | getLogStream
    | setLogVerbosityLevel
    | getLogVerbosityLevel
    | getLogTags
    | setLogTagVerbosityLevel
    | getLogTagVerbosityLevel
    | addLogMessage
    | testCallEmpty
    | testCallString
    | testCallBytes
    | testCallVectorInt
    | testCallVectorIntObject
    | testCallVectorString
    | testCallVectorStringObject
    | testSquareInt
    | testNetwork
    | testProxy
    | testGetDifference
    | testUseUpdate
    | testReturnError
  )) => null | error | (
    T extends 'getAuthorizationState' ? AuthorizationState :
    T extends 'setTdlibParameters' ? Ok :
    T extends 'checkDatabaseEncryptionKey' ? Ok :
    T extends 'setAuthenticationPhoneNumber' ? Ok :
    T extends 'resendAuthenticationCode' ? Ok :
    T extends 'checkAuthenticationCode' ? Ok :
    T extends 'requestQrCodeAuthentication' ? Ok :
    T extends 'registerUser' ? Ok :
    T extends 'checkAuthenticationPassword' ? Ok :
    T extends 'requestAuthenticationPasswordRecovery' ? Ok :
    T extends 'checkAuthenticationPasswordRecoveryCode' ? Ok :
    T extends 'recoverAuthenticationPassword' ? Ok :
    T extends 'checkAuthenticationBotToken' ? Ok :
    T extends 'logOut' ? Ok :
    T extends 'close' ? Ok :
    T extends 'destroy' ? Ok :
    T extends 'confirmQrCodeAuthentication' ? Session :
    T extends 'getCurrentState' ? Updates :
    T extends 'setDatabaseEncryptionKey' ? Ok :
    T extends 'getPasswordState' ? PasswordState :
    T extends 'setPassword' ? PasswordState :
    T extends 'getRecoveryEmailAddress' ? RecoveryEmailAddress :
    T extends 'setRecoveryEmailAddress' ? PasswordState :
    T extends 'checkRecoveryEmailAddressCode' ? PasswordState :
    T extends 'resendRecoveryEmailAddressCode' ? PasswordState :
    T extends 'requestPasswordRecovery' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkPasswordRecoveryCode' ? Ok :
    T extends 'recoverPassword' ? PasswordState :
    T extends 'resetPassword' ? ResetPasswordResult :
    T extends 'cancelPasswordReset' ? Ok :
    T extends 'createTemporaryPassword' ? TemporaryPasswordState :
    T extends 'getTemporaryPasswordState' ? TemporaryPasswordState :
    T extends 'getMe' ? User :
    T extends 'getUser' ? User :
    T extends 'getUserFullInfo' ? UserFullInfo :
    T extends 'getBasicGroup' ? BasicGroup :
    T extends 'getBasicGroupFullInfo' ? BasicGroupFullInfo :
    T extends 'getSupergroup' ? Supergroup :
    T extends 'getSupergroupFullInfo' ? SupergroupFullInfo :
    T extends 'getSecretChat' ? SecretChat :
    T extends 'getChat' ? Chat :
    T extends 'getMessage' ? Message :
    T extends 'getMessageLocally' ? Message :
    T extends 'getRepliedMessage' ? Message :
    T extends 'getChatPinnedMessage' ? Message :
    T extends 'getCallbackQueryMessage' ? Message :
    T extends 'getMessages' ? Messages :
    T extends 'getMessageThread' ? MessageThreadInfo :
    T extends 'getMessageViewers' ? Users :
    T extends 'getFile' ? File :
    T extends 'getRemoteFile' ? File :
    T extends 'loadChats' ? Ok :
    T extends 'getChats' ? Chats :
    T extends 'searchPublicChat' ? Chat :
    T extends 'searchPublicChats' ? Chats :
    T extends 'searchChats' ? Chats :
    T extends 'searchChatsOnServer' ? Chats :
    T extends 'searchChatsNearby' ? ChatsNearby :
    T extends 'getTopChats' ? Chats :
    T extends 'removeTopChat' ? Ok :
    T extends 'addRecentlyFoundChat' ? Ok :
    T extends 'removeRecentlyFoundChat' ? Ok :
    T extends 'clearRecentlyFoundChats' ? Ok :
    T extends 'getRecentlyOpenedChats' ? Chats :
    T extends 'checkChatUsername' ? CheckChatUsernameResult :
    T extends 'getCreatedPublicChats' ? Chats :
    T extends 'checkCreatedPublicChatsLimit' ? Ok :
    T extends 'getSuitableDiscussionChats' ? Chats :
    T extends 'getInactiveSupergroupChats' ? Chats :
    T extends 'getGroupsInCommon' ? Chats :
    T extends 'getChatHistory' ? Messages :
    T extends 'getMessageThreadHistory' ? Messages :
    T extends 'deleteChatHistory' ? Ok :
    T extends 'deleteChat' ? Ok :
    T extends 'searchChatMessages' ? Messages :
    T extends 'searchMessages' ? Messages :
    T extends 'searchSecretMessages' ? FoundMessages :
    T extends 'searchCallMessages' ? Messages :
    T extends 'deleteAllCallMessages' ? Ok :
    T extends 'searchChatRecentLocationMessages' ? Messages :
    T extends 'getActiveLiveLocationMessages' ? Messages :
    T extends 'getChatMessageByDate' ? Message :
    T extends 'getChatSparseMessagePositions' ? MessagePositions :
    T extends 'getChatMessageCalendar' ? MessageCalendar :
    T extends 'getChatMessageCount' ? Count :
    T extends 'getChatScheduledMessages' ? Messages :
    T extends 'getMessagePublicForwards' ? FoundMessages :
    T extends 'getChatSponsoredMessage' ? SponsoredMessage :
    T extends 'removeNotification' ? Ok :
    T extends 'removeNotificationGroup' ? Ok :
    T extends 'getMessageLink' ? MessageLink :
    T extends 'getMessageEmbeddingCode' ? Text :
    T extends 'getMessageLinkInfo' ? MessageLinkInfo :
    T extends 'getChatAvailableMessageSenders' ? MessageSenders :
    T extends 'setChatMessageSender' ? Ok :
    T extends 'sendMessage' ? Message :
    T extends 'sendMessageAlbum' ? Messages :
    T extends 'sendBotStartMessage' ? Message :
    T extends 'sendInlineQueryResultMessage' ? Message :
    T extends 'forwardMessages' ? Messages :
    T extends 'resendMessages' ? Messages :
    T extends 'sendChatScreenshotTakenNotification' ? Ok :
    T extends 'addLocalMessage' ? Message :
    T extends 'deleteMessages' ? Ok :
    T extends 'deleteChatMessagesBySender' ? Ok :
    T extends 'deleteChatMessagesByDate' ? Ok :
    T extends 'editMessageText' ? Message :
    T extends 'editMessageLiveLocation' ? Message :
    T extends 'editMessageMedia' ? Message :
    T extends 'editMessageCaption' ? Message :
    T extends 'editMessageReplyMarkup' ? Message :
    T extends 'editInlineMessageText' ? Ok :
    T extends 'editInlineMessageLiveLocation' ? Ok :
    T extends 'editInlineMessageMedia' ? Ok :
    T extends 'editInlineMessageCaption' ? Ok :
    T extends 'editInlineMessageReplyMarkup' ? Ok :
    T extends 'editMessageSchedulingState' ? Ok :
    T extends 'getTextEntities' ? TextEntities :
    T extends 'parseTextEntities' ? FormattedText :
    T extends 'parseMarkdown' ? FormattedText :
    T extends 'getMarkdownText' ? FormattedText :
    T extends 'getFileMimeType' ? Text :
    T extends 'getFileExtension' ? Text :
    T extends 'cleanFileName' ? Text :
    T extends 'getLanguagePackString' ? LanguagePackStringValue :
    T extends 'getJsonValue' ? JsonValue :
    T extends 'getJsonString' ? Text :
    T extends 'setPollAnswer' ? Ok :
    T extends 'getPollVoters' ? Users :
    T extends 'stopPoll' ? Ok :
    T extends 'hideSuggestedAction' ? Ok :
    T extends 'getLoginUrlInfo' ? LoginUrlInfo :
    T extends 'getLoginUrl' ? HttpUrl :
    T extends 'getInlineQueryResults' ? InlineQueryResults :
    T extends 'answerInlineQuery' ? Ok :
    T extends 'getCallbackQueryAnswer' ? CallbackQueryAnswer :
    T extends 'answerCallbackQuery' ? Ok :
    T extends 'answerShippingQuery' ? Ok :
    T extends 'answerPreCheckoutQuery' ? Ok :
    T extends 'setGameScore' ? Message :
    T extends 'setInlineGameScore' ? Ok :
    T extends 'getGameHighScores' ? GameHighScores :
    T extends 'getInlineGameHighScores' ? GameHighScores :
    T extends 'deleteChatReplyMarkup' ? Ok :
    T extends 'sendChatAction' ? Ok :
    T extends 'openChat' ? Ok :
    T extends 'closeChat' ? Ok :
    T extends 'viewMessages' ? Ok :
    T extends 'openMessageContent' ? Ok :
    T extends 'clickAnimatedEmojiMessage' ? Sticker :
    T extends 'getInternalLinkType' ? InternalLinkType :
    T extends 'getExternalLinkInfo' ? LoginUrlInfo :
    T extends 'getExternalLink' ? HttpUrl :
    T extends 'readAllChatMentions' ? Ok :
    T extends 'createPrivateChat' ? Chat :
    T extends 'createBasicGroupChat' ? Chat :
    T extends 'createSupergroupChat' ? Chat :
    T extends 'createSecretChat' ? Chat :
    T extends 'createNewBasicGroupChat' ? Chat :
    T extends 'createNewSupergroupChat' ? Chat :
    T extends 'createNewSecretChat' ? Chat :
    T extends 'upgradeBasicGroupChatToSupergroupChat' ? Chat :
    T extends 'getChatListsToAddChat' ? ChatLists :
    T extends 'addChatToList' ? Ok :
    T extends 'getChatFilter' ? ChatFilter :
    T extends 'createChatFilter' ? ChatFilterInfo :
    T extends 'editChatFilter' ? ChatFilterInfo :
    T extends 'deleteChatFilter' ? Ok :
    T extends 'reorderChatFilters' ? Ok :
    T extends 'getRecommendedChatFilters' ? RecommendedChatFilters :
    T extends 'getChatFilterDefaultIconName' ? Text :
    T extends 'setChatTitle' ? Ok :
    T extends 'setChatPhoto' ? Ok :
    T extends 'setChatMessageTtl' ? Ok :
    T extends 'setChatPermissions' ? Ok :
    T extends 'setChatTheme' ? Ok :
    T extends 'setChatDraftMessage' ? Ok :
    T extends 'setChatNotificationSettings' ? Ok :
    T extends 'toggleChatHasProtectedContent' ? Ok :
    T extends 'toggleChatIsMarkedAsUnread' ? Ok :
    T extends 'toggleChatDefaultDisableNotification' ? Ok :
    T extends 'setChatClientData' ? Ok :
    T extends 'setChatDescription' ? Ok :
    T extends 'setChatDiscussionGroup' ? Ok :
    T extends 'setChatLocation' ? Ok :
    T extends 'setChatSlowModeDelay' ? Ok :
    T extends 'pinChatMessage' ? Ok :
    T extends 'unpinChatMessage' ? Ok :
    T extends 'unpinAllChatMessages' ? Ok :
    T extends 'joinChat' ? Ok :
    T extends 'leaveChat' ? Ok :
    T extends 'addChatMember' ? Ok :
    T extends 'addChatMembers' ? Ok :
    T extends 'setChatMemberStatus' ? Ok :
    T extends 'banChatMember' ? Ok :
    T extends 'canTransferOwnership' ? CanTransferOwnershipResult :
    T extends 'transferChatOwnership' ? Ok :
    T extends 'getChatMember' ? ChatMember :
    T extends 'searchChatMembers' ? ChatMembers :
    T extends 'getChatAdministrators' ? ChatAdministrators :
    T extends 'clearAllDraftMessages' ? Ok :
    T extends 'getChatNotificationSettingsExceptions' ? Chats :
    T extends 'getScopeNotificationSettings' ? ScopeNotificationSettings :
    T extends 'setScopeNotificationSettings' ? Ok :
    T extends 'resetAllNotificationSettings' ? Ok :
    T extends 'toggleChatIsPinned' ? Ok :
    T extends 'setPinnedChats' ? Ok :
    T extends 'downloadFile' ? File :
    T extends 'getFileDownloadedPrefixSize' ? Count :
    T extends 'cancelDownloadFile' ? Ok :
    T extends 'getSuggestedFileName' ? Text :
    T extends 'uploadFile' ? File :
    T extends 'cancelUploadFile' ? Ok :
    T extends 'writeGeneratedFilePart' ? Ok :
    T extends 'setFileGenerationProgress' ? Ok :
    T extends 'finishFileGeneration' ? Ok :
    T extends 'readFilePart' ? FilePart :
    T extends 'deleteFile' ? Ok :
    T extends 'getMessageFileType' ? MessageFileType :
    T extends 'getMessageImportConfirmationText' ? Text :
    T extends 'importMessages' ? Ok :
    T extends 'replacePrimaryChatInviteLink' ? ChatInviteLink :
    T extends 'createChatInviteLink' ? ChatInviteLink :
    T extends 'editChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLink' ? ChatInviteLink :
    T extends 'getChatInviteLinkCounts' ? ChatInviteLinkCounts :
    T extends 'getChatInviteLinks' ? ChatInviteLinks :
    T extends 'getChatInviteLinkMembers' ? ChatInviteLinkMembers :
    T extends 'revokeChatInviteLink' ? ChatInviteLinks :
    T extends 'deleteRevokedChatInviteLink' ? Ok :
    T extends 'deleteAllRevokedChatInviteLinks' ? Ok :
    T extends 'checkChatInviteLink' ? ChatInviteLinkInfo :
    T extends 'joinChatByInviteLink' ? Chat :
    T extends 'getChatJoinRequests' ? ChatJoinRequests :
    T extends 'processChatJoinRequest' ? Ok :
    T extends 'processChatJoinRequests' ? Ok :
    T extends 'createCall' ? CallId :
    T extends 'acceptCall' ? Ok :
    T extends 'sendCallSignalingData' ? Ok :
    T extends 'discardCall' ? Ok :
    T extends 'sendCallRating' ? Ok :
    T extends 'sendCallDebugInformation' ? Ok :
    T extends 'getVideoChatAvailableParticipants' ? MessageSenders :
    T extends 'setVideoChatDefaultParticipant' ? Ok :
    T extends 'createVideoChat' ? GroupCallId :
    T extends 'getGroupCall' ? GroupCall :
    T extends 'startScheduledGroupCall' ? Ok :
    T extends 'toggleGroupCallEnabledStartNotification' ? Ok :
    T extends 'joinGroupCall' ? Text :
    T extends 'startGroupCallScreenSharing' ? Text :
    T extends 'toggleGroupCallScreenSharingIsPaused' ? Ok :
    T extends 'endGroupCallScreenSharing' ? Ok :
    T extends 'setGroupCallTitle' ? Ok :
    T extends 'toggleGroupCallMuteNewParticipants' ? Ok :
    T extends 'inviteGroupCallParticipants' ? Ok :
    T extends 'getGroupCallInviteLink' ? HttpUrl :
    T extends 'revokeGroupCallInviteLink' ? Ok :
    T extends 'startGroupCallRecording' ? Ok :
    T extends 'endGroupCallRecording' ? Ok :
    T extends 'toggleGroupCallIsMyVideoPaused' ? Ok :
    T extends 'toggleGroupCallIsMyVideoEnabled' ? Ok :
    T extends 'setGroupCallParticipantIsSpeaking' ? Ok :
    T extends 'toggleGroupCallParticipantIsMuted' ? Ok :
    T extends 'setGroupCallParticipantVolumeLevel' ? Ok :
    T extends 'toggleGroupCallParticipantIsHandRaised' ? Ok :
    T extends 'loadGroupCallParticipants' ? Ok :
    T extends 'leaveGroupCall' ? Ok :
    T extends 'endGroupCall' ? Ok :
    T extends 'getGroupCallStreamSegment' ? FilePart :
    T extends 'toggleMessageSenderIsBlocked' ? Ok :
    T extends 'blockMessageSenderFromReplies' ? Ok :
    T extends 'getBlockedMessageSenders' ? MessageSenders :
    T extends 'addContact' ? Ok :
    T extends 'importContacts' ? ImportedContacts :
    T extends 'getContacts' ? Users :
    T extends 'searchContacts' ? Users :
    T extends 'removeContacts' ? Ok :
    T extends 'getImportedContactCount' ? Count :
    T extends 'changeImportedContacts' ? ImportedContacts :
    T extends 'clearImportedContacts' ? Ok :
    T extends 'sharePhoneNumber' ? Ok :
    T extends 'getUserProfilePhotos' ? ChatPhotos :
    T extends 'getStickers' ? Stickers :
    T extends 'searchStickers' ? Stickers :
    T extends 'getInstalledStickerSets' ? StickerSets :
    T extends 'getArchivedStickerSets' ? StickerSets :
    T extends 'getTrendingStickerSets' ? StickerSets :
    T extends 'getAttachedStickerSets' ? StickerSets :
    T extends 'getStickerSet' ? StickerSet :
    T extends 'searchStickerSet' ? StickerSet :
    T extends 'searchInstalledStickerSets' ? StickerSets :
    T extends 'searchStickerSets' ? StickerSets :
    T extends 'changeStickerSet' ? Ok :
    T extends 'viewTrendingStickerSets' ? Ok :
    T extends 'reorderInstalledStickerSets' ? Ok :
    T extends 'getRecentStickers' ? Stickers :
    T extends 'addRecentSticker' ? Stickers :
    T extends 'removeRecentSticker' ? Ok :
    T extends 'clearRecentStickers' ? Ok :
    T extends 'getFavoriteStickers' ? Stickers :
    T extends 'addFavoriteSticker' ? Ok :
    T extends 'removeFavoriteSticker' ? Ok :
    T extends 'getStickerEmojis' ? Emojis :
    T extends 'searchEmojis' ? Emojis :
    T extends 'getAnimatedEmoji' ? AnimatedEmoji :
    T extends 'getEmojiSuggestionsUrl' ? HttpUrl :
    T extends 'getSavedAnimations' ? Animations :
    T extends 'addSavedAnimation' ? Ok :
    T extends 'removeSavedAnimation' ? Ok :
    T extends 'getRecentInlineBots' ? Users :
    T extends 'searchHashtags' ? Hashtags :
    T extends 'removeRecentHashtag' ? Ok :
    T extends 'getWebPagePreview' ? WebPage :
    T extends 'getWebPageInstantView' ? WebPageInstantView :
    T extends 'setProfilePhoto' ? Ok :
    T extends 'deleteProfilePhoto' ? Ok :
    T extends 'setName' ? Ok :
    T extends 'setBio' ? Ok :
    T extends 'setUsername' ? Ok :
    T extends 'setLocation' ? Ok :
    T extends 'changePhoneNumber' ? AuthenticationCodeInfo :
    T extends 'resendChangePhoneNumberCode' ? AuthenticationCodeInfo :
    T extends 'checkChangePhoneNumberCode' ? Ok :
    T extends 'setCommands' ? Ok :
    T extends 'deleteCommands' ? Ok :
    T extends 'getCommands' ? BotCommands :
    T extends 'getActiveSessions' ? Sessions :
    T extends 'terminateSession' ? Ok :
    T extends 'terminateAllOtherSessions' ? Ok :
    T extends 'toggleSessionCanAcceptCalls' ? Ok :
    T extends 'toggleSessionCanAcceptSecretChats' ? Ok :
    T extends 'setInactiveSessionTtl' ? Ok :
    T extends 'getConnectedWebsites' ? ConnectedWebsites :
    T extends 'disconnectWebsite' ? Ok :
    T extends 'disconnectAllWebsites' ? Ok :
    T extends 'setSupergroupUsername' ? Ok :
    T extends 'setSupergroupStickerSet' ? Ok :
    T extends 'toggleSupergroupSignMessages' ? Ok :
    T extends 'toggleSupergroupIsAllHistoryAvailable' ? Ok :
    T extends 'toggleSupergroupIsBroadcastGroup' ? Ok :
    T extends 'reportSupergroupSpam' ? Ok :
    T extends 'getSupergroupMembers' ? ChatMembers :
    T extends 'closeSecretChat' ? Ok :
    T extends 'getChatEventLog' ? ChatEvents :
    T extends 'getPaymentForm' ? PaymentForm :
    T extends 'validateOrderInfo' ? ValidatedOrderInfo :
    T extends 'sendPaymentForm' ? PaymentResult :
    T extends 'getPaymentReceipt' ? PaymentReceipt :
    T extends 'getSavedOrderInfo' ? OrderInfo :
    T extends 'deleteSavedOrderInfo' ? Ok :
    T extends 'deleteSavedCredentials' ? Ok :
    T extends 'getSupportUser' ? User :
    T extends 'getBackgrounds' ? Backgrounds :
    T extends 'getBackgroundUrl' ? HttpUrl :
    T extends 'searchBackground' ? Background :
    T extends 'setBackground' ? Background :
    T extends 'removeBackground' ? Ok :
    T extends 'resetBackgrounds' ? Ok :
    T extends 'getLocalizationTargetInfo' ? LocalizationTargetInfo :
    T extends 'getLanguagePackInfo' ? LanguagePackInfo :
    T extends 'getLanguagePackStrings' ? LanguagePackStrings :
    T extends 'synchronizeLanguagePack' ? Ok :
    T extends 'addCustomServerLanguagePack' ? Ok :
    T extends 'setCustomLanguagePack' ? Ok :
    T extends 'editCustomLanguagePackInfo' ? Ok :
    T extends 'setCustomLanguagePackString' ? Ok :
    T extends 'deleteLanguagePack' ? Ok :
    T extends 'registerDevice' ? PushReceiverId :
    T extends 'processPushNotification' ? Ok :
    T extends 'getPushReceiverId' ? PushReceiverId :
    T extends 'getRecentlyVisitedTMeUrls' ? TMeUrls :
    T extends 'setUserPrivacySettingRules' ? Ok :
    T extends 'getUserPrivacySettingRules' ? UserPrivacySettingRules :
    T extends 'getOption' ? OptionValue :
    T extends 'setOption' ? Ok :
    T extends 'setAccountTtl' ? Ok :
    T extends 'getAccountTtl' ? AccountTtl :
    T extends 'deleteAccount' ? Ok :
    T extends 'removeChatActionBar' ? Ok :
    T extends 'reportChat' ? Ok :
    T extends 'reportChatPhoto' ? Ok :
    T extends 'getChatStatistics' ? ChatStatistics :
    T extends 'getMessageStatistics' ? MessageStatistics :
    T extends 'getStatisticalGraph' ? StatisticalGraph :
    T extends 'getStorageStatistics' ? StorageStatistics :
    T extends 'getStorageStatisticsFast' ? StorageStatisticsFast :
    T extends 'getDatabaseStatistics' ? DatabaseStatistics :
    T extends 'optimizeStorage' ? StorageStatistics :
    T extends 'setNetworkType' ? Ok :
    T extends 'getNetworkStatistics' ? NetworkStatistics :
    T extends 'addNetworkStatistics' ? Ok :
    T extends 'resetNetworkStatistics' ? Ok :
    T extends 'getAutoDownloadSettingsPresets' ? AutoDownloadSettingsPresets :
    T extends 'setAutoDownloadSettings' ? Ok :
    T extends 'getBankCardInfo' ? BankCardInfo :
    T extends 'getPassportElement' ? PassportElement :
    T extends 'getAllPassportElements' ? PassportElements :
    T extends 'setPassportElement' ? PassportElement :
    T extends 'deletePassportElement' ? Ok :
    T extends 'setPassportElementErrors' ? Ok :
    T extends 'getPreferredCountryLanguage' ? Text :
    T extends 'sendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberVerificationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberVerificationCode' ? Ok :
    T extends 'sendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'resendEmailAddressVerificationCode' ? EmailAddressAuthenticationCodeInfo :
    T extends 'checkEmailAddressVerificationCode' ? Ok :
    T extends 'getPassportAuthorizationForm' ? PassportAuthorizationForm :
    T extends 'getPassportAuthorizationFormAvailableElements' ? PassportElementsWithErrors :
    T extends 'sendPassportAuthorizationForm' ? Ok :
    T extends 'sendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'resendPhoneNumberConfirmationCode' ? AuthenticationCodeInfo :
    T extends 'checkPhoneNumberConfirmationCode' ? Ok :
    T extends 'setBotUpdatesStatus' ? Ok :
    T extends 'uploadStickerFile' ? File :
    T extends 'getSuggestedStickerSetName' ? Text :
    T extends 'checkStickerSetName' ? CheckStickerSetNameResult :
    T extends 'createNewStickerSet' ? StickerSet :
    T extends 'addStickerToSet' ? StickerSet :
    T extends 'setStickerSetThumbnail' ? StickerSet :
    T extends 'setStickerPositionInSet' ? Ok :
    T extends 'removeStickerFromSet' ? Ok :
    T extends 'getMapThumbnailFile' ? File :
    T extends 'acceptTermsOfService' ? Ok :
    T extends 'sendCustomRequest' ? CustomRequestResult :
    T extends 'answerCustomQuery' ? Ok :
    T extends 'setAlarm' ? Ok :
    T extends 'getCountries' ? Countries :
    T extends 'getCountryCode' ? Text :
    T extends 'getPhoneNumberInfo' ? PhoneNumberInfo :
    T extends 'getPhoneNumberInfoSync' ? PhoneNumberInfo :
    T extends 'getApplicationDownloadLink' ? HttpUrl :
    T extends 'getDeepLinkInfo' ? DeepLinkInfo :
    T extends 'getApplicationConfig' ? JsonValue :
    T extends 'saveApplicationLogEvent' ? Ok :
    T extends 'addProxy' ? Proxy :
    T extends 'editProxy' ? Proxy :
    T extends 'enableProxy' ? Ok :
    T extends 'disableProxy' ? Ok :
    T extends 'removeProxy' ? Ok :
    T extends 'getProxies' ? Proxies :
    T extends 'getProxyLink' ? HttpUrl :
    T extends 'pingProxy' ? Seconds :
    T extends 'setLogStream' ? Ok :
    T extends 'getLogStream' ? LogStream :
    T extends 'setLogVerbosityLevel' ? Ok :
    T extends 'getLogVerbosityLevel' ? LogVerbosityLevel :
    T extends 'getLogTags' ? LogTags :
    T extends 'setLogTagVerbosityLevel' ? Ok :
    T extends 'getLogTagVerbosityLevel' ? LogVerbosityLevel :
    T extends 'addLogMessage' ? Ok :
    T extends 'testCallEmpty' ? Ok :
    T extends 'testCallString' ? TestString :
    T extends 'testCallBytes' ? TestBytes :
    T extends 'testCallVectorInt' ? TestVectorInt :
    T extends 'testCallVectorIntObject' ? TestVectorIntObject :
    T extends 'testCallVectorString' ? TestVectorString :
    T extends 'testCallVectorStringObject' ? TestVectorStringObject :
    T extends 'testSquareInt' ? TestInt :
    T extends 'testNetwork' ? Ok :
    T extends 'testProxy' ? Ok :
    T extends 'testGetDifference' ? Ok :
    T extends 'testUseUpdate' ? Update :
    T extends 'testReturnError' ? Error :
  never)
}
